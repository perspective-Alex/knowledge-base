 

МИНИСТЕРСТВО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ 

НИЖЕГОРОДСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ 

им. Н.И. ЛОБАЧЕВСКОГО 

 
 
 
 
 
 
 
 
 
 

 
 
 

 

 

В.Е. АЛЕКСЕЕВ, В.А. ТАЛАНОВ 

ГРАФЫ. МОДЕЛИ ВЫЧИСЛЕНИЙ. 

СТРУКТУРЫ ДАННЫХ 

Учебник  

 
 
 
 
 
 
 
 
 
 
 
 
 

Нижний Новгород 

Издательство Нижегородского госуниверситета 

2004 

1

 
 
 

 

Предисловие 

В этой книге под одной обложкой собраны учебные тексты, по внеш-
ности  разнородные,  но  относящиеся  к  одной  сравнительно  молодой  об-
ласти человеческой деятельности. Это деятельность по созданию и иссле-
дованию алгоритмов, для которой пока не придумано общеупотребитель-
ного объединяющего названия (она является частью того, что охватывает-
ся терминами «computer science» и «информатика»). Работа в этой области 
требует определенных математических знаний и представления о пробле-
мах, связанных с разработкой компьютерных программ, но она не сводит-
ся к математике или программированию. Ее роль можно сравнить с ролью 
технологии по отношению к науке и производству. 

Материал настоящего пособия в целом соответствует программе курса 
«анализ  и  разработка  алгоритмов»,  читавшегося  в  течение  ряда  лет  для 
магистрантов  факультета  ВМК  ННГУ,  а  отдельные  его  фрагменты  ис-
пользуются в различных спецкурсах. Книга состоит из трех частей, кото-
рые могут изучаться независимо друг от друга и в произвольном порядке. 
Первая часть посвящена алгоритмам на графах. Значительный объем в 
ней занимает глава 1, в которой приводятся базовые понятия и факты из 
теории  графов.  В  других  двух  главах  излагаются  некоторые  алгоритмы 
для  решения  задач  на  графах.  Основной  принцип  отбора  и  организации 
материала этих глав состоял в том, что каждый рассматриваемый пример 
должен  нести  определенную  идейную  нагрузку,  знакомить  слушателя  с 
одним из важных изобретений или открытий в алгоритмической области. 
При этом предпочтение отдавалось не самым последним или рекордным 
алгоритмам, а самым простым для понимания и убедительно демонстри-
рующим ту или иную идею. Для большинства рассматриваемых алгорит-
мов даются доказательства их правильности (т.е. того, что алгоритм дей-
ствительно решает поставленную задачу) и оценок трудоемкости. Умение 
достаточно строго обосновывать алгоритмы и оценивать их трудоемкость 
является  существенной  частью  квалификации  алгоритмиста.  Материал 
первой части может быть использован и в общем курсе дискретной мате-
матики. Каждая из глав этой части содержит задания для самостоятельной 
работы – математические задачи или упражнения, в которых предлагается 
разработать какой-нибудь алгоритм. 

 

3

Во второй части книги рассматриваются классические модели вычис-
лений, которые сыграли основную роль в формировании математического 
понятия алгоритма. Дается описание машин Тьюринга, алгорифмов Мар-
кова, «машины абак», и как наиболее реалистичной модели вычислитель-
ного  автомата  −  модели  с  адресуемой  памятью  РАМ.  Приводятся  также 
основные сведения о формальных языках и способах их конструктивного 
задания.  Приводятся  теоретические  основы логического программирова-
ния.  Важность  этих  вопросов  вытекает  не  только  из  общенаучных  про-
блем развития математики, но также из практических задач общества, ис-
пользующего вычислительную технику в производстве, экономике, инже-
нерных расчетах и нуждающегося в адекватном представлении о возмож-
ностях вычислительных автоматов. 

В  третьей  части  рассматриваются способы структурирования инфор-
мации  в  моделях  с  адресуемой  памятью.  Одной  из  основных  целей  при 
разработке структур данных является формирование математических по-
нятий,  которые  пока  не  входят  в  классическую  математику,  но  требуют 
формального описания и математического анализа их свойств. Основной 
интерес здесь представляют сложностные аспекты выполнения типичных 
операций. Возникновение наиболее удачных структур, использующихся в 
различных алгоритмах, приводит к формированию так называемых абст-
рактных  типов  данных,  которые  позволяют  проектирование  нетривиаль-
ных алгоритмов вести на более высоком уровне, не упуская из виду кон-
кретные  реализации.  Методы  реализации  абстрактных  типов  данных 
можно рассматривать как переход от описания алгоритма с использовани-
ем  прикладных  или  математических  понятий  к  описанию  в  конкретной 
системе вычислений. В нашей книге рассматриваются методы реализации 
приоритетных  очередей,  динамически  меняющихся  отношений  эквива-
лентности,  а  также  некоторые  способы  организации  словарей,  основы-
вающиеся на использовании так называемых поисковых деревьев. В книге 
также  приводятся  примеры  использования  рассматриваемых  структур  в 
алгоритмах решения некоторых задач из теории графов. 

В этой книге не принят какой-либо стандартный способ для описания 
алгоритмов.  Каждое  такое  описание  имеет  целью  продемонстрировать 
алгоритм в целом и взаимодействие его частей, не вдаваясь в излишнюю 
детализацию, но и не теряя ничего существенного. Иногда даются поша-
говые описания разной степени подробности, иногда тексты на «псевдо-
языке», использующем (не слишком последовательно) элементы синтак-
сиса языка Pascal и математическую символику. 

Часть 1 написана В.Е. Алексеевым, части 2 и 3 – В.А. Талановым. 

4

 

Часть 1. ГРАФЫ И АЛГОРИТМЫ 

Глава 1. Элементы теории графов 

Графы являются существенным элементом математических моделей в 
самых разнообразных областях науки и практики. Они помогают нагляд-
но  представить  взаимоотношения  между  объектами  или  событиями  в 
сложных системах. Многие алгоритмические задачи дискретной матема-
тики могут быть сформулированы как задачи, так или иначе связанные с 
графами,  например,  задачи,  в  которых  требуется  выяснить  какие-либо 
особенности  устройства  графа,  или  найти  в  графе  часть,  удовлетворяю-
щую некоторым требованиям, или построить граф с заданными свойства-
ми. 

Настоящая глава является кратким введением в теорию графов. В ней 
приводится минимум понятий, необходимый для того, чтобы можно было 
начать какую-либо содержательную работу с графами или приступить к 
более глубокому изучению теории графов. Доказательства даются только 
в тех случаях, когда их сложность не превышает некоторый интуитивно 
ощущаемый порог. Поэтому, например, такие важные факты, как теорема 
Кирхгофа или теорема Понтрягина – Куратовского, сообщаются без дока-
зательств.  
 

1.1. Начальные понятия 

 
 
 

 

 

 

 

1.1.1. Определение графа 
Для  описания  строения  различных  систем,  состоящих  из  связанных 
между собой элементов, часто используют графические схемы, изображая 
элементы  точками  (кружками,  прямоугольниками  и  т.д.),  а  связи  между 
ними – линиями или стрелками, соединяющими элементы. При этом по-
лучаются диаграммы вроде тех, что показаны на рис. 1.1.  

На  таких  диаграммах  часто  ни  способ  изображения  элементов,  ни 
форма или длина линий не имеют значения – важно лишь, какие именно 
пары  элементов  соединены  линиями.  Если  посмотреть  внимательно,  то 
можно заметить, что рис. 1.1,а и 1.1,б изображают одну и ту же структуру 
связей между элементами A, B, C, D, E, F. Эту же структуру можно опи-
сать, не прибегая к графическому изображению, а просто перечислив па-
ры связанных между собой элементов: (A, B), (A, D), (B, C), (B, E), (B, F), 

 

5

(C, F), (D, E). Таким образом, когда мы отвлекаемся от всех несуществен-
ных подробностей, у нас остаются два списка: список элементов и список 
пар элементов. Вместе они составляют то, что математики называют «гра-
фом». Из этого примера видно, что понятие графа само по себе не связано 
прямо с геометрией или графикой. Тем не менее, возможность нарисовать 
граф – одна из привлекательных черт этого математического объекта. 

F 

E 

B 

 
 
 
 
 
 
 
                                         а)                                                                            б) 

D 

F 

B 

C

A

E 

C

F

Рис. 1 

A 

 

 

 

Термин  «граф»  неоднозначен,  это  легко  обнаружить,  сравнивая  при-
водимые в разных книгах определения графа. Однако во всех этих опре-
делениях есть и общее. В любом случае граф состоит из двух множеств – 
множества вершин и множества ребер, причем для каждого ребра указана 
пара вершин, которые это ребро соединяет. Вершины и ребра называются 
элементами графа. Здесь будут рассматриваться только конечные графы, 
то есть такие, у которых оба множества конечны. Чтобы получить закон-
ченное определение графа того или иного типа, необходимо уточнить еще 
следующие три момента. 

1. Ориентированный или неориентированный? Прежде всего, нуж-
но договориться, считаем ли мы пары (a, b) и (b, a) различными. Если да, 
то  говорят,  что  рассматриваются  упорядоченные  пары  (порядок  элемен-
тов в паре важен), если нет – неупорядоченные. Если ребро e соединяет 
вершину  a  с  вершиной  b  и  пара  (a,  b)  считается  упорядоченной,  то  это 
ребро называется ориентированным, вершина a – его началом, вершина b 
– концом. Если же эта пара считается неупорядоченной, то ребро называ-
ется неориентированным, а обе вершины – его концами. Чаще всего рас-
сматривают графы, в которых все ребра имеют один тип – либо ориенти-
рованные,  либо  неориентированные.  В  соответствии  с  этим  и  весь  граф 
называют  ориентированным  или  неориентированным.  На  рисунках  ори-
ентацию ребра (направление от начала к концу) указывают стрелкой. На 
рис.1.1 показаны неориентированные графы, а на рис. 1.2 – ориентирован- 
ванные. 

6

 

2. Кратные ребра. Следующий пункт, требующий уточнения – могут 
ли разные ребра иметь одинаковые начала и концы? Если да, то говорят, 
что в графе допускаются кратные ребра. Граф с кратными ребрами назы-
вают также мультиграфом. На рис. 1.2 изображены два графа, левый яв-
ляется  ориентированным  мультиграфом,  а  правый  –  ориентированным 
графом без кратных ребер. 

3. Петли. Ребро, которому поставлена в соответствие пара вида (a, a), 
то есть ребро, соединяющее вершину a с нею же самой, называется пет-
лей.  Если  такие  ребра  не  допускаются,  то  говорят,  что  рассматриваются 
графы без петель. 
 
 
 
 
 
 
 

 

 

Рис. 1.2 

Комбинируя эти три признака, можно получить разные варианты оп-
ределения  понятия  графа.  Особенно  часто  встречаются  неориентирован-
ные  графы  без  петель  и  кратных  ребер.  Такие  графы  называют  обыкно-
венными. Если в графе нет кратных ребер, то можно просто отождествить 
ребра с соответствующими парами вершин – считать, что ребро это и есть 
пара вершин. Чтобы исключить петли, достаточно оговорить, что верши-
ны, образующие ребро, должны быть различны. Это приводит к следую-
щему определению обыкновенного графа. 

Определение. Обыкновенным графом называется пара G = (V, E), где 
V – конечное множество, E – множество неупорядоченных пар различных 
элементов  из  V.  Элементы  множества  V  называются  вершинами  графа, 
элементы множества E – его ребрами. 

Слегка  модифицируя  это  определение,  можно  получить  определения 
других типов графов без кратных ребер: если заменить слово «неупорядо-
ченных»  словом  «упорядоченных»,  получится  определение  ориентиро-
ванного графа без петель, если убрать слово «различных», получится оп-
ределение графа с петлями. Ориентированный граф часто называют орг-
рафом. 

В дальнейшем термин «граф» будем употреблять в смысле «обыкно-
венный граф», а рассматривая другие типы графов, будем специально это 
оговаривать. 

 

7

Множество  вершин  графа  G  будем  обозначать  через  VG,  множество 

ребер – EG, число вершин – n(G), число ребер – m(G). 

Из  определения  видно,  что  для  задания  обыкновенного  графа  доста-

точно  перечислить  его  вершины  и  ребра,  причем  каждое  ребро  долж-       
но  быть  парой  вершин.  Положим,  например,  VG  =  {a,  b,  c,  d,  e,  f  },                 
G = {(a,c), (a,f), (b,c), (c,d), (d,f)}. Тем самым задан граф G с n(G) = 6, 
m(G)  =  5.  Если  граф  не  слишком  велик,  то  более  наглядным  способом 
представить  его  является  рисунок,  на  котором  вершины  изображаются 
кружками или иными значками, а ребра – линиями, соединяющими вер-
шины. Заданный выше граф G показан на рис. 1.3. Мы будем часто поль-
зоваться именно этим способом представления графа, при этом обозначе-
ния  вершин  иногда  будут  помещаться  внутри  кружков,  изображающих 
вершины, иногда рядом с ними, а иногда, когда имена вершин не сущест-
венны, и вовсе опускаться. 
 
 
 
 
 
 
 
 

a

d

b

f

e

c

Рис. 1.3 

 

 

1.1.2. Графы и бинарные отношения 
Напомним,  что  бинарным  отношением  на  множестве  A  называется 
любое подмножество R множества A2, состоящего из всевозможных упо-
рядоченных  пар  элементов  множества  A.  Каждому  такому  отношению 
можно поставить в соответствие граф отношения G = (A, R). Сравнивая с 
тем, что говорилось выше об определениях различных типов графов, ви-
дим, что понятие бинарного отношения эквивалентно понятию ориенти-
рованного графа с петлями. Другие типы графов без кратных ребер – это 
частные виды бинарных отношений. Отношение R называется рефлексив-
ным, если для любого x ∈ A пара (x, x) принадлежит R, и антирефлексив-
ным, если ни одна такая пара не принадлежит R. Отношение называется 
симметричным, если из (x, y) ∈ A следует, что (y, x) ∈ R. В графе анти-
рефлексивного и симметричного отношения нет петель и для каждой па-
ры  вершин  либо  нет  ни  одного,  либо  есть  два  ребра,  соединяющих  эти 
вершины. Если в таком графе каждую пару ориентированных ребер, со-

8

 

единяющих одни и те же две вершины, заменить одним неориентирован-
ным ребром, то получится обыкновенный граф. 

 

1.1.3. Откуда берутся графы 
Легко найти примеры графов в самых разных областях науки и прак-
тики.  Сеть  дорог,  трубопроводов,  электрическая  цепь,  структурная  фор-
мула  химического  соединения,  блок-схема  программы  –  в  этих  случаях 
графы  возникают  очень  естественно  и  видны  «невооруженным  глазом». 
При  желании  графы  можно  обнаружить  практически  где  угодно.  Яркая 
демонстрация этого содержится в книге Д. Кнута [D.E.Knuth, The Stanford 
GraphBase] – графы извлекаются из романа «Анна Каренина», из картины 
Леонардо да Винчи, из материалов Бюро Экономического Анализа США 
и из других источников. 

Немало поводов для появления графов и в самой математике. Наибо-
лее очевидный пример – любой многогранник в трехмерном пространст-
ве. Вершины и ребра многогранника можно рассматривать как вершины и 
ребра графа. При этом мы отвлекаемся от того, как расположены элемен-
ты многогранника в пространстве, оставляя лишь информацию о том, ка-
кие вершины соединены ребрами. На рис. 1.4 показаны три способа изо-
бразить один и тот же граф трехмерного куба. 
 
 
 
 
 
 
 

Рис. 1.4 

Еще один способ образования графов из геометрических объектов ил-

 

 

 

 

B 

A 

люстрирует рис. 1.5.  
 
 
 
 
 
 
 
 

F 

D

 

 

A

D

B

C 

F 

E

C

E 

Рис. 1.5 

9

Слева показаны шесть кругов на плоскости, а справа – граф, в котором 
каждая вершина соответствует одному из этих кругов и две вершины со-
единены ребром в том и только том случае, когда соответствующие круги 
пересекаются.  Такие  графы  называют  графами  пересечений.  Можно  по-
строить  граф  пересечений  семейства  интервалов  на  прямой,  или дуг ок-
ружности,  или  параллелепипедов.  Вообще,  для  любого  семейства  мно-
жеств {S1, …, Sn} можно построить граф пересечений с множеством вер-
шин {1, …, n}, в котором ребро (i, j) имеется тогда и только тогда, когда 
i ≠ j и Si ∩ Sj ≠ ∅. Известно, что любой граф можно представить как граф 
пересечений некоторого семейства множеств. 

 

1.1.4. Число графов 
Возьмем какое-нибудь множество V, состоящее из n элементов, и бу-
дем рассматривать всевозможные (обыкновенные!) графы с множеством 
вершин V. Обозначим число таких графов через gn . Эти графы различают-
ся только множествами ребер, а каждое ребро – это неупорядоченная пара 
различных элементов из V. В комбинаторике такие пары называются со-
четаниями из n по 2, их число равно 

 

n
2

⎛
⎜⎜
⎝

⎞
=⎟⎟
⎠

)1

.

 

nn
(
−
2

=

ng

(2 −
nn

Каждая пара может быть включена или не включена в множество ребер 
графа. Применяя правило произведения, приходим к следующему резуль-
тату. 

Теорема 1.1. 
1.1.5. Смежность, инцидентность, степени 
Если в графе имеется ребро e = (a, b), , то говорят, что вершины a и b 
смежны в этом графе, ребро e инцидентно каждой из вершин a, b, а каж-
дая из них инцидентна этому ребру. 

Множество всех вершин графа, смежных с данной вершиной а, назы-

2)1

. 

вается окрестностью этой вершины и обозначается через V(a). 

На практике удобным и эффективным при решении многих задач спо-
собом  задания  графа  являются  так  называемые  списки  смежности.  Эти 
списки могут быть реализованы различными способами в виде конкрет-
ных структур данных, но в любом случае речь идет о том, что для каждой 
вершины a перечисляются все смежные с ней вершины, то есть элементы 
множества  V(a).  Такой  способ  задания  дает  возможность  быстрого  про-
смотра окрестности вершины. 

 

 

 

 

 

 

10

 

Число вершин, смежных с вершиной a, называется степенью вершины 

a и обозначается через deg(a). 

Если сложить степени всех вершин некоторого графа, то каждое ребро 
внесет в эту сумму вклад, равный 2, поэтому справедливо следующее ут-
верждение. 

Теорема 1.2. 

deg

a
)(

=

Gm
(2

)

. 

∑

VGa
∈

Это равенство известно как «лемма о рукопожатиях». Из него следует, 

что число вершин нечетной степени в любом графе четно. 

Вершину степени 0 называют изолированной. 
Граф  называют  регулярным  степени d,  если  степень  каждой  его  вер-

шины равна d. 

Набор степеней графа – это последовательность степеней его вершин, 

выписанных в неубывающем порядке. 

1.1.6. Некоторые специальные графы 
Рассмотрим некоторые особенно часто встречающиеся графы. 
Пустой граф – граф, не содержащий ни одного ребра. Пустой граф с 

множеством вершин {1, 2, ..., n} обозначается через On. 

Полный граф – граф, в котором каждые две вершины смежны. Полный 
граф с множеством вершин {1, 2, ..., n} обозначается через Kn. Граф K1, в 
частности,  имеет  одну  вершину  и  ни  одного  ребра.  Очевидно,  K1  =  O1. 
Будем считать также, что существует граф K0, у которого VG = EG = ∅. 

Цепь (путь) Pn – граф с множеством вершин {1, 2, ..., n} и множест-

вом ребер {(1, 2), (2, 3), …, (n – 1, n)}. 

Цикл Cn – граф, который получается из графа Pn добавлением ребра 

(1, n). 

Все эти графы при n = 4 показаны на рис. 1.6. 
1 

1 

2

2

1

 

 

 
 
 
 
 
 

 

 

 

 

2

3

1 

4 

2 

3 

4 

3

4 

3

4

O4                               K4                              P4                              C4  

Рис. 1.6 

1.1.7. Графы и матрицы 
Пусть G – граф с n вершинами, причем VG = {1, 2, …, n}. Построим 
квадратную матрицу A порядка n, в которой элемент Aij, стоящий на пере-

 

11

сечении строки с номером i и столбца с номером j, определяется следую-
щим образом: 

Aij

=

⎧
  ,1
⎪
⎨
  ,0
⎪⎩

если
если

j
),(  
j
),(  

i
i

∈
∉

EG
,
EG
.

 

 

 

Она  называется  матрицей  смежности  графа.  Матрицу  смежности 
можно построить и для ориентированного графа, и для неориентирован-
ного, и для графа с петлями. Для обыкновенного графа она обладает дву-
мя  особенностями:  из-за  отсутствия  петель  на  главной  диагонали  стоят 
нули, а так как граф неориентированный, то матрица симметрична отно-
сительно  главной  диагонали.  Обратно,  каждой  квадратной  матрице  по-
рядка n, составленной из нулей и единиц и обладающей двумя указанны-
ми свойствами, соответствует обыкновенный граф с множеством вершин 
{1, 2, …, n}.  

Другая матрица, ассоциированная с графом – это матрица инцидент-
ности. Для ее построения занумеруем вершины графа числами от 1 до n, а 
ребра – числами от 1 до m. Матрица инцидентности I имеет n строк и m 
столбцов, а ее элемент Iij равен 1, если вершина с номером i инцидентна 
ребру с номером j, в противном случае он равен нулю. На рис. 1.7 показан 
граф с занумерованными вершинами и ребрами и его матрицы смежности 
и инцидентности.  
 
 
 
 
 
 
 
 

6

5

4

1

5

6

7

1

2

4

3

3

2

010110
011001
110001
000010
100111
010100

,

I

=

⎞
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

⎛
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

8
00000111
00011001
01100100
00001000
10110010
11000000

. 

⎞
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠

Рис. 1.7 

A

=

⎛
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝

 

12

 

Для  ориентированного  графа  матрица  инцидентности  определяется 
несколько иначе: ее элемент Iij равен 1, если вершина i является началом 
ребра j, он равен –1, если она является концом этого ребра, и он равен 0, 
если эта вершина и это ребро не инцидентны друг другу. 

 

1.1.8. Взвешенные графы 
Часто, особенно когда графы используются для моделирования реаль-
ных систем, их вершинам, или ребрам, или и тем и другим приписывают-
ся некоторые числа. Природа этих чисел может быть самая разнообразная. 
Например, если граф представляет собой модель железнодорожной сети, 
то  число,  приписанное  ребру,  может  указывать  длину  перегона  между 
двумя  станциями,  или  наибольший  вес  состава,  который  допустим  для 
этого  участка  пути,  или  среднее  число  поездов,  проходящих  через  этот 
участок в течение суток и т.п. Что бы ни означали эти числа, сложилась 
традиция называть их весами, а граф с заданными весами вершин и/или 
ребер – взвешенным графом.  
 

1.2. Изоморфизм 

 

 

 

 

1.2.1. Определение изоморфизма 
На рис. 1.8 изображены два графа с одним и тем же множеством вер-
шин {a, b, c, d}. При внимательном рассмотрении можно обнаружить, что  
это разные графы – в левом имеется ребро (a, c), в правом же такого нет. 
В то же время, если не обращать внимания на наименования вершин, то 
эти  графы  явно  одинаково  устроены:  каждый  из  них  –  цикл  из  четырех 
вершин. Во многих случаях при исследовании строения графов имена или 
номера вершин не играют роли, и такие графы, один из которых получа-
ется из другого переименованием вершин, удобнее было бы считать оди-
наковыми. Для того чтобы это можно было делать «на законном основа-
нии», вводится понятие изоморфизма графов. 
 
 
 
 
 
 
 
                                     G1                                            G2

a 

c 

d

d

b

c

a

b

 

Рис. 1.8 

Определение. Графы G1 и G2 называются изоморфными, если суще-

 

13

ствует такая биекция f множества VG1 на множество VG2, что (a, b) ∈ EG1 
тогда и только тогда, когда (f (a), f (b)) ∈ EG2. Отображение f в этом слу-
чае называется изоморфизмом графа G1 на граф G2. 

Тот факт, что графы G1 и G2 изоморфны, записывается так: G1 ≅ G2. 

Для графов, изображенных на рис. 1.8, изоморфизмом является, например, 
отображение, задаваемое таблицей: 
 

x (вершина графа G1) 
f (x) (вершина графа G2) 

a 
a 

b 
b 

c 
d 

d 
c 

 

фа на второй. 

Заметим, что в этом примере есть и другие изоморфизмы первого гра-

 

Сформулированное определение изоморфизма годится и для ориенти-
рованных  графов,  нужно  только  обе  упоминаемые  в  нем  пары  вершин 
считать упорядоченными. 

Изоморфизм – бинарное отношение на множестве графов. Очевидно, 
это отношение рефлексивно, симметрично и транзитивно, то есть является 
отношением эквивалентности. Классы эквивалентности называются абст-
рактными  графами.  Когда  говорят,  что  рассматриваются  абстрактные 
графы, это означает, что изоморфные графы считаются одинаковыми. Аб-
страктный  граф  можно  представлять  себе  как  граф,  у  которого  стерты 
имена  (пометки)  вершин,  поэтому  абстрактные  графы  иногда  называют 
также непомеченными графами. 
 

1.2.2. Инварианты 
В общем случае узнать, изоморфны ли два графа, достаточно сложно. 
Если буквально следовать определению, то нужно перебрать все биекции 
множества вершин одного из них на множество вершин другого и для ка-
ждой из этих биекций проверить, является ли она изоморфизмом. Для n 
вершин  имеется  n!  биекций  и  эта  работа  становится  практически  невы-
полнимой уже для не очень больших n (например, 20! > 2⋅1018). Однако 
во  многих  случаях  бывает  довольно  легко  установить,  что  два  данных 
графа  не  изоморфны.  Рассмотрим,  например,  графы,  изображенные  на 
рис. 1.9.  

Так  как  при  изоморфизме  пара  смежных  вершин  переходит  в  пару 
смежных, а пара несмежных – в пару несмежных, то ясно, что число ребер 
у  двух  изоморфных  графов  должно  быть  одинаковым.  Поэтому  сразу 
можно  сказать,  что  графы  G1  и  G2,  у  которых  разное  количество  ребер, 
неизоморфны. У графов G1 и G3 одинаковое число ребер, но они тоже не-
изоморфны. Это можно установить, сравнивая степени вершин. Очевидно, 

14

 

при изоморфизме каждая вершина переходит в вершину той же степени. 
Следовательно,  изоморфные  графы  должны  иметь  одинаковые  наборы 
степеней, а у графов G1 и G3 эти наборы различны. С графами G1 и G4 де-
ло обстоит немного сложнее – у них и наборы степеней одинаковы. Все 
же и эти графы неизоморфны: можно заметить, что в графе G4 есть цикл 
длины 3, а в графе G1 таких циклов нет. Ясно, что при изоморфизме каж-
дый подграф одного графа переходит в изоморфный ему подграф другого. 
 
 
 
 
 
 
            G1                                G2                               G3                                  G4

 

Рис. 1.9 

 

 

 

 

 

Характеристики  графов,  которые  сохраняются  при  изоморфизме,  на-
зываются инвариантами. В этом примере мы видели некоторые простые 
инварианты – число ребер, набор степеней, число циклов заданной длины, 
в  дальнейшем  будут  введены  еще  многие  другие.  Если  удается  устано-
вить, что для двух исследуемых графов некоторый инвариант принимает 
разные  значения,  то  эти  графы  неизоморфны.  Для  того  чтобы  доказать, 
что  два  графа  изоморфны,  необходимо  предъявить  соответствующую 
биекцию. 

1.3. Операции над графами 

Для получения новых графов можно использовать разнообразные опе-
рации над графами. Здесь мы рассмотрим два вида операций – локальные, 
при которых заменяются, удаляются или добавляются отдельные элемен-
ты графа, и алгебраические, когда новый граф строится по определенным 
правилам из нескольких имеющихся. 

 

1.3.1. Локальные операции 
Простейшая операция – удаление ребра. При удалении ребра сохраня-
ются  все  вершины  графа  и  все  его  ребра,  кроме  удаляемого.  Обратная 
операция – добавление ребра. 

При удалении вершины вместе с вершиной удаляются и все инцидент-
ные ей ребра. Граф, получаемый из графа G удалением вершины a, обо-
значают G – a. При добавлении вершины к графу добавляется новая изо-
лированная  вершина.  С  помощью  операций  добавления  вершин  и  ребер 
можно «из ничего», то есть из графа K0, построить любой граф. 

 

15

Операция стягивания ребра (a, b) определяется следующим образом. 
Вершины a и b удаляются из графа, к нему добавляется новая вершина c и 
она соединяется ребром с каждой вершиной, с которой была смежна хотя 
бы одна из вершин a, b. 

Операция  подразбиения  ребра  (a,  b)  действует  следующим  образом. 
Из графа удаляется это ребро, к нему добавляется новая вершина c и два 
новых  ребра  (a,  c)  и  (b,  c).  На  рис.  1.10  изображены  исходный  граф  G, 
граф G′, полученный из него стягиванием ребра (3, 4) и G″, полученный 
подразбиением того же ребра. В обоих случаях вновь добавленная верши-
на обозначена цифрой 7. 
 
 
 
 
 
 
5 
 
                 G                                                 G′                                               G″ 

2 

2 

6 

4 

7 

6 

1 

4 

3 

2

1

1

6

5

5

7

3

 

Рис. 1.10 

 

 

 

 

 

 

 

1.3.2. Подграфы 
Граф G′ называется подграфом графа G, если VG′ ⊆ VG, EG′ ⊆ EG. 
Всякий подграф может быть получен из графа удалением некоторых вер-
шин и ребер. На рис. 1.11 изображены граф G и его подграфы G1, G2, G3, 
G4. 
 
 
 
 
 
 
 
      
4 

1 

2 

4 

5 

3 

3 

2 

1 

4 

3 

1 

5

4

5

4

3

2

2

1

2

1

    G                          G1                          G2                           G3                         G4

Рис. 1.11 

Подграф G′ графа G называется остовным, если VG′ = VG. Остовный 
подграф может быть получен из графа удалением некоторых ребер, вер-
шины  же  остаются  в  неприкосновенности.  На  рис.  1.11  G1  –  остовный 
подграф графа G, а G2, G3 и G4 не являются остовными подграфами. 

16

 

Другая  важная  разновидность  подграфов  –  порожденные  подграфы. 
Пусть задан граф G = (V, E) и в нем выбрано множество вершин U ⊆ V. 
Рассмотрим подграф G′ = (U, E′), где E′ состоит из всех тех ребер графа 
G, у которых оба конца принадлежат U. Говорят, что этот подграф поро-
жден  множеством  вершин  U.  Он  обозначается  через  G〈U  〉.  Порожден-
ный подграф может быть получен из графа удалением «лишних» вершин, 
то есть вершин, не принадлежащих U. 

Можно определить также подграф, порожденный множеством ребер 
F ⊆ E.. Это подграф G′ = (V ′, F), где V ′состоит из всех вершин, инци-
дентных ребрам из F. 

На рис. 1.11 G2 – подграф графа G, порожденный множеством вершин 
{1, 2, 4, 5}, то есть G2 = G〈{1, 2, 4, 5}〉, он же порождается множеством 
ребер {(1,2), (1,4), (4,5)}; подграф G3 не порождается множеством вершин, 
но порождается множеством ребер {(1,2), (2,3), (3,4)}; подграф G4 не яв-
ляется ни остовным, ни порожденным в каком-либо смысле. 

1.3.3. Алгебраические операции 
Поскольку граф состоит из двух множеств (вершины и ребра), то раз-
личные  операции  над  множествами  естественным  образом  порождают 
соответствующие  операции  над  графами.  Например,  объединение  двух 
графов G1 и G2 определяется как граф G = = G1 ∪ G2, у которого VG = 
VG1 ∪ VG2, EG = EG1 ∪ EG2, а пересечение – как граф G = G1 ∩ G2, у ко-
торого VG = VG1 ∩ VG2, EG = EG1 ∩ EG2. Обе операции иллюстрирует 
рис. 1.12. 
 
 
 
 
 
 
         G1                                G2                                    G1 ∪ G2                        G1 ∩ G2 

f 

f 

a

b

c

a

c

a

e

f

a

e

f

b

c

 

 

 

 

c

Рис.1.12 

Дополнением (дополнительным графом) к графу G = (V, E) называется 
,G  у которого множество вершин то же, что у G, а множество ребер 
граф 
является дополнением множества E до множества всех неупорядоченных 
пар  вершин.  Иначе говоря, две различные вершины смежны в графе  G  
тогда и только тогда, когда они не смежны в графе G. Например, 
. 
n

n K

O =

 

17

GG =

. 

Другой пример показан на рис. 1.13. Очевидно, всегда 
 
 
 
 
 
 
 
                                  G                                                             G  

Рис. 1.13 

 

 

Под суммой G1 + G2 двух абстрактных графов понимают объединение 
графов с непересекающимися множествами вершин. Точнее говоря, име-
ется в виду следующее. Сначала вершинам графов-слагаемых присваива-
ются имена (пометки, номера) так, чтобы множества вершин не пересека-
лись,  затем  полученные  графы  объединяются.  Операция  сложения  ассо-
циативна, то есть (G1 + G2) + G3 = G1 + (G2 + G3) для любых трех графов. 
Поэтому  можно  образовывать  сумму  любого  числа  графов,  не  указывая 
порядок действий с помощью скобок. Если складываются k экземпляров 
одного  и  того  же  графа  G,  то  полученный  граф  обозначается  через  kG. 
Например, On ≅ nK1. На рис. 1.14 изображен граф C4 + 2K2 + 4K1. 

Соединением двух графов G1 и G2 называется граф, получаемый из их 
суммы  добавлением  всех  ребер,  соединяющих  вершины  первого  слагае-
1 GG (cid:68)
. 
мого с вершинами второго. Будем записывать эту операцию как 
2
На рис. 1.15 представлен граф 
 
 
 
 
 
 
 
 
                                              Рис. 1.14                                                     Рис. 1.15 

3 OP (cid:68)
2

. 

Легко  видеть,  что  операции  сложения  и  соединения  графов  связаны 

друг с другом следующими простыми соотношениями: 
 

GGGG
1
2

=

+

(cid:68)

1

2

,

 

18

 

GGGG
1
2

+

=

(cid:68)

1

2

.

 

OO
q

(cid:68)

p

=,
qp

1KCW

Введем еще два типа специальных графов, которые легко описывают-
ся с помощью операции соединения. Первый – полный двудольный граф 
K
. В этом графе множество вершин разбито на два подмно-
жества (доли), в одном из которых p вершин, в другом q, и две вершины в 
нем  смежны  тогда  и  только  тогда,  когда  они  принадлежат  разным  под-
. На рис. 1.16 показаны графы 
множествам. Второй – колесо 
K3,4 и W6
 
 
 
 
 
 
 
 
                                                K34                                                              W6  

=

(cid:68)

n

n

Рис. 1.16 

 

 

 

 

Произведение G = G1  × G2 графов G1 и G2 определяется следующим 
образом. Множеством вершин графа G является декартово произведение 
множеств VG1 и VG2, то есть вершины этого графа – упорядоченные пары 
(x, y), где x – вершина первого сомножителя, y – вершина второго. Вер-
шины (x1, y1) и (x2, y2) в G смежны тогда и только тогда, когда x1 = y1 и y1 
смежна с y2 в графе G2, или y1 = y2 и x1 смежна с x2 в графе G1. С помо-
щью  операции  произведения  можно  выразить  некоторые  важные  графы 
через простейшие. Например, произведение двух цепей дает прямоуголь-
ную  решетку  –  см.  рис.  1.17.  Если  один  из  сомножителей  превратить  в 
цикл,  добавив  одно  ребро,  то  прямоугольная  решетка  превратится  в  ци-
линдрическую, а если и второй сомножитель превратить в цикл, то полу-
чится тороидальная решетка.  
 
 
 
 
 
                     P3                        P4                                  P3 × P4

 

 

Рис. 1.17 

Другой пример – k-мерный куб Qk, описывамый в задаче 3. С помо-

 

19

щью  операции  произведения  его  (точнее,  изоморфный  ему граф) можно 
определить рекурсивно: 

.
 
На рис. 1.18 показано, как получается Q4 из Q3. 

QQ
k

K

KQ
1

=

×

=

1
−

,

2

2

k

 
 
 
 
 
 
 
 
          Q3                                      K2                                             Q4 = Q3 × K2

 

Рис. 1.18 

1.4. Маршруты, связность, расстояния 

 

 

 

 

 

 
 

20

 

 

1.4.1. Маршруты, пути, циклы 
Маршрут в графе – это последовательность вершин x1, x2, …, xn, та-
кая, что для каждого i = 1, 2, .., n – 1 вершины xi и xi+1 соединены ребром. 
Эти  n  –  1  ребер  называются  ребрами  маршрута,  говорят,  что  маршрут 
проходит через них, а число n – 1 называют длиной маршрута. Говорят, 
что маршрут соединяет вершины x1 и xn, они называются соответственно 
началом и концом маршрута, вершины x2, …, xn−1 называются промежу-
точными. Маршрут называется замкнутым, если x1 = xn. 

Путь – это маршрут, в котором все ребра различны. Путь называется 

простым, если и все вершины в нем различны. 

Цикл  –  это  замкнутый  путь.  Цикл  x1,  x2, …, xn−1, x1  называется  про-

стым, если вершины x1, x2, …, xn−1 все попарно различны. 

В графе на рис. 1.19 последовательность вершин 
2, 3, 5, 4 – не маршрут; 
2, 3, 4, 5, 1, 4, 3 – маршрут, но не путь; 
3, 1, 4, 5, 1, 2 – путь, но не простой; 
2, 3, 1, 4, 3, 1, 2 – замкнутый маршрут, но не цикл; 
2, 3, 1, 4, 5, 1, 2 – цикл, но не простой; 
2, 3, 4, 5, 1, 2 – простой цикл. 

 
 
 
 
 
 
 

 

1

2 

3

4

Рис. 1.19 

5

Установим некоторые простые свойства маршрутов. 
Лемма 1.3. В любом маршруте, соединяющем две различные вершины, 
содержится простой путь, соединяющий те же вершины. В любом цик-
ле, проходящем через некоторое ребро, содержится простой цикл, про-
ходящий через это ребро. 

Доказательство. Пусть x1, x2, …, xn – маршрут. Если все его верши-
ны различны, то это уже простой путь. В противном случае, пусть xi = xj,  
i < j. Тогда последовательность x1, x2, …, xi−1, xi, xi+1, xn, полученная из 
этого маршрута удалением отрезка последовательности от xi+1 до xj, тоже 
является маршрутом. Новый маршрут соединяет те же вершины и имеет 
меньшую длину. Продолжая действовать таким образом, после конечного 
числа «спрямлений» получим простой путь, соединяющий x1 и xn. Второе 
утверждение доказывается аналогично. (cid:0) 

Отметим,  что  в  формулировке  леммы  1.3  нельзя  заменить  слово 
«цикл» словами «замкнутый маршрут». Действительно, если (a, b) – реб-
ро графа, то последовательность a, b, a – замкнутый маршрут, проходя-
щий через это ребро, но никакого цикла в нем нет. 

Лемма 1.4. Если в графе степень каждой вершины не меньше 2, то в 

нем есть цикл. 

Доказательство.  Найдем  в  графе  простой  путь  наибольшей  длины. 
Пусть это x1, x2, …, xn. Вершина xn смежна с xn–1, а так как ее степень не 
меньше  двух,  то  она  смежна  еще  хотя  бы  с  одной  вершиной,  скажем,          
y. Если y была бы отлична от всех вершин пути, то последовательность x1, 
x2, …, xn, y была бы простым путем большей длины. Следовательно, y – 
это одна из вершин пути, y = xi, причем i < n – 1. Но тогда xi, xi+1, …, xn, xi 
– цикл. (cid:0) 

 1.4.2. Связность и компоненты 
Граф называется связным, если в нем для любых двух вершин имеется 
маршрут,  соединяющий  эти  вершины.  Заметим,  что  ввиду  леммы  1.3 
можно в этом определении заменить слово «маршрут» словами «простой 
путь». 

 

21

Для  произвольного  графа  определим  на  множестве  вершин  отноше-
ние соединимости: вершина a соединима с вершиной b, если существует 
соединяющий их маршрут. Легко видеть, что это отношение рефлексивно, 
симметрично и транзитивно, то есть является отношением эквивалентно-
сти. Классы эквивалентности называются областями связности, а порож-
даемые ими подграфы – компонентами связности графа. В связном графе 
имеется  только  одна  компонента  связности  –  весь  граф.  Компоненты 
связности  можно  определить  также  как  максимальные  по  включению 
связные подграфы данного графа. 

У  графа  на  рис.  1.20  имеются  четыре  области  связности  – {1, 2, 9}, 

1 

2

{3, 10, 11}, {4}, {5, 6, 7, 8, 12, 13, 14, 15}. 
 
 
 
 
 

11

10

9 

3 

4

Рис. 1.20 

5

6

7

8 

12

13

14

15

 

 

Вершина называется шарниром (или точкой сочленения), если при ее 
удалении число компонент связности увеличивается. У графа на рис. 1.20 
имеется четыре шарнира – это вершины 3, 6, 7, 8. 

Ребро, при удалении которого увеличивается число компонент связно-
сти, называется перешейком. Перешейками графа, изображенного на рис. 
1.20, являются ребра (3, 10), (3, 11), (6, 7), (7, 8), (7, 13). 

Легко доказываются следующие свойства шарниров и перешейков. 
Лемма 1.5. Вершина a является шарниром тогда и только тогда, ко-
гда  в  графе  имеются  такие  отличные  от  a  вершины  b  и  c,  что  любой 
путь, соединяющий b и c, проходит через a. 

Лемма 1.6. Ребро является перешейком в том и только том случае, 

если в графе нет простого цикла, содержащего это ребро. 

 

1.4.3. Метрические характеристики графов 
Расстоянием между двумя вершинами графа называется длина крат-
чайшего пути, соединяющего эти вершины. Расстояние между вершинами 
a и b обозначается через d (a, b). Если в графе нет пути, соединяющего a и 
b, то есть эти вершины принадлежат разным компонентам связности, то 
расстояние между ними считается бесконечным. 

Легко видеть, что функция d (x, y) обладает свойствами: 
1) d (x, y) ≥ 0, причем d (x, y) = 0 тогда и только тогда, когда x = y; 
2) d (x, y) = d (y, x); 

22

 

3) d (x, y) + d (y, z) ≥ d (x, z) (неравенство треугольника). 
В  математике  функцию  двух  переменных,  определенную  на  некото-
ром множестве и удовлетворяющую условиям 1) – 3), называют метри-
кой, а множество, на котором задана метрика – метрическим простран-
ством. Таким образом, множество вершин любого графа можно рассмат-
ривать как метрическое пространство. 

Расстояние от данной вершины a до наиболее удаленной от нее вер-
шины  называется  эксцентриситетом  вершины  a  и  обозначается  через 
ecc(a). Таким образом, 

ecc

a
)(

=

max
VGx∈

xad
),(

. 

Вершину  с  наименьшим  эксцентриситетом  называют  центральной,  а 
вершину  с  наибольшим  эксцентриситетом  –  периферийной.  Множество 
всех  центральных  вершин  называется  центром  графа.  Сама  величина 
наименьшего эксцентриситета называется радиусом графа и обозначается 
через  rad(G),  а  величина  наибольшего  –  диаметром  и  обозначается 
diam(G). Иначе говоря, 

 

 

 

G
)
rad
(
=
G
)
diam(

=

min
VGx
∈
max
VGx
∈

max
VGy
∈
max
VGy
∈

yxd
,(
),
 
yxd
).
,(

 

Наименьший диаметр имеет полный граф – его диаметр равен 1. Сре-
ди  связных  графов  с  n  вершинами  наибольший  диаметр,  равный  n  –  1, 
имеет цепь Pn. 

Если  расстояние  между  двумя  вершинами  равно  диаметру  графа,  то 
кратчайший  путь,  соединяющий  эти  вершины,  называется  диаметраль-
ным путем, а подграф, образованный вершинами и ребрами этого пути,    
– диаметральной цепью. 

Для графа, изображенного на рис. 1.21 эксцентриситеты вершин при-

ведены в таблице: 
 

x 

eсс (x) 

1  2  3  4  5  6  7  8  9 
5  4  4  3  5  3  3  4  5 

 
Центр этого графа составляют вершины 4, 6, 7; периферийные вершины – 
1, 5 и 9; радиус его равен 3, а диаметр 5. Одна из диаметральных цепей 
порождается множеством вершин {1, 3, 6, 7, 8, 9}. 
 
 
 

 

23

 
 
 
 
 
 
 

 

 

1 

3 

6 

2

4

7

5

9

8
Рис. 1.21 

1.4.4. Маршруты и связность в орграфах 
Для ориентированного графа можно определить два типа маршрутов. 
Неориентированный  маршрут  (или  просто  маршрут)  –  это  последова-
тельность вершин x1, x2, …, xn,    такая, что для каждого i = 1, 2, …, n – 1 
хотя бы одно из ребер (xi, xi+1), (xi+1, xi) принадлежит графу. Маршрут на-
зывается ориентированным (или ормаршрутом), если для каждого i пара 
(xi, xi+1) является ребром графа. Таким образом, при движении вдоль мар-
шрута в орграфе ребра могут проходиться как в направлении ориентации, 
так и в обратном направлении, а при движении вдоль ормаршрута – толь-
ко в направлении ориентации. Это различие очевидным образом распро-
страняется на пути и циклы, так что в орграфе можно рассматривать пути 
и  орпути,  циклы  и  орциклы.  Будем  говорить,  что  маршрут  x1,  x2,  …, xn 
соединяет вершины x1 и xn, а ормаршрут x1, x2, …, xn ведет из x1 в xn. 

Соответственно  двум  типам  маршрутов  определяются  и  два  типа 
связности орграфов. Орграф называется связным (или слабо связным), ес-
ли для каждой пары вершин в нем имеется соединяющий их маршрут; он 
называется сильно связным, если для каждой упорядоченной пары вершин 
(a,  b)  в  нем  имеется  ормаршрут,  ведущий  из  a  в  b.  Максимальные  по 
включению  подмножества  вершин  орграфа,  порождающие  сильно  связ-
ные  подграфы,  называются  его  областями  сильной  связности,  а  порож-
даемые  ими  подграфы  –  компонентами  сильной  связности.  Очевидно, 
разные области сильной связности не могут иметь общих вершин, так что 
множество  вершин  каждого  орграфа  разбивается  на  области  сильной 
связности.  Областями  сильной  связности  орграфа  на  рис.  1.22  являются 
множества {1, 2, 5}, {3, 4, 6, 7, 8}, {9}. 
 
 
 
 
 

1 

2 

3

6 

7

4

8

 

5 

24

 

Рис. 1.22

9

1.5. Деревья 

 

 

1.5.1. Определение и элементарные свойства 
Деревом называется связный граф, не имеющий циклов. В графе без 
циклов,  таким  образом,  каждая  компонента  связности  является  деревом. 
Такой граф называют лесом. 

Из  леммы  1.4  следует,  что  во  всяком  дереве,  в  котором  не  меньше 
двух вершин, имеется вершина степени 1. Такие вершины называют вися-
чими вершинами, или листьями. В действительности легко доказать, что в 
каждом дереве не меньше двух листьев, а цепь Pn – пример дерева, в ко-
тором точно два листа. 

В следующих двух теоремах устанавливаются некоторые свойства де-

Теорема 1.7. Граф с n вершинами и m ребрами является деревом то-
гда и только тогда, когда он удовлетворяет любым двум из следующих 
трех условий: 

ревьев. 

(1) связен; 
(2) не имеет циклов; 
(3) m = n – 1. 

Доказательство. Первые два условия вместе составляют определение 
дерева. Покажем, что выполнение любых двух из условий (1)–(3) влечет 
выполнение третьего. 

(1) и (2)  ⇒ (3). Индукция по числу вершин. При n = 1 утверждение 
очевидно. При n ≥ 1 в дереве имеется хотя бы один лист. Если из дерева 
удалить  лист,  то  снова  получится  дерево,  так  как  циклов  не  появится, а 
связность, очевидно, сохранится. В этом новом дереве n – 1 вершина и, по 
предположению индукции, n – 2 ребра. Следовательно, в исходном дереве 
было n – 1 ребро. 

(1) и (3) ⇒ (2). Пусть в графе, не имеющем циклов, n – 1 ребро, а его 
компонентами связности являются G1, G2, …, Gk, причем Gi состоит из ni 
вершин, i = 1, …, k. Каждая компонента является деревом, поэтому, как 
доказано  выше,  число  ребер  в  Gi  равно  ni  –  1,  а  всего  ребер  в  графе 
k
−=−=−∑
n

n
i
(2) и (3) ⇒ (1). Рассмотрим связный граф с n – 1 ребром. Если бы в 
нем  был  цикл,  то,  удалив  любое  цикловое  ребро,  получили  бы  связный 
граф с меньшим числом ребер. Мы можем продолжать такое удаление ре-
бер до тех пор, пока не останется связный граф без циклов, то есть дерево. 
Но ребер в этом дереве было бы меньше, чем n – 1, а это противоречит 

. Значит, k = 1 и граф связен. 

kn

)1

1

(

i

1
=

 

25

доказанному выше. (cid:0) 

Теорема 1.8. Если G – дерево, то 

1) в G любая пара вершин соединена единственным путем; 
2) при добавлении к G любого нового ребра образуется цикл; 
3) при удалении из G любого ребра он превращается в несвязный 

граф. 

Доказательство. Существование пути между любыми двумя верши-
нами следует из связности дерева. Допустим, что в некотором дереве су-
ществуют два различных пути, соединяющих вершины a и b. Начальные 
отрезки  этих  путей  совпадают  (оба  пути  начинаются  в  одной  и  той  же 
вершине a). Пусть x – последняя вершина этого совпадающего начала, а 
после x в одном пути следует вершина y1, а в другом – вершина y2. Рас-
смотрим ребро (x, y1). Если его удалить из графа, то в оставшемся под-
графе  вершины  y1  и  x  будут  соединимыми  –  соединяющий  их  маршрут 
можно построить так: взять отрезок первого пути от y1 до b и к нему при-
соединить отрезок второго от x до b, взятый в обратном порядке. Но это 
означает, что ребро (x, y1) не является перешейком. Однако из леммы 1.6 
следует, что в дереве каждое ребро является перешейком. Этим доказано 
утверждение 1). Если к дереву добавить новое ребро, то, поскольку вер-
шины, соединяемые этим ребром, уже были соединены путем, образуется 
цикл. Утверждение 3) следует из леммы 1.6. (cid:0) 

Отметим, что единственный путь, соединяющий две вершины дерева, 
всегда простой (если путь не является простым, в нем обязательно содер-
жится цикл). 

1.5.2. Центр дерева 
Центр графа может состоять из одной вершины (как, например, в гра-
фе K1,q), а может включать все его вершины (полный граф). Для дерева, 
как мы увидим, имеется гораздо более ограниченный диапазон возможно-
стей.  

Теорема  1.9.  Центр  дерева  состоит  из  одной  вершины  или  из  двух 

 

 

смежных вершин. 

Доказательство. Допустим, что в некотором дереве имеются две не-
смежных центральных вершины c1 и c2. На пути, соединяющем эти вер-
шины, найдем промежуточную вершину a с максимальным эксцентриси-
тетом и пусть b1 и b2 – вершины, соседние с a на этом пути (см. рис. 1.23). 
Пусть x – вершина, наиболее удаленная от a в дереве, то есть d(a, x) = 
= ecc(a). Путь, соединяющий a с x, не может проходить через обе верши-
ны b1 и b2. Допустим, он не проходит через b1. Тогда единственный путь 

26

 

c1                         b1                a                 b2                         c2

из b1 в x проходит через a и d(b1, x) = d(a, x). Отсюда следует, что ecc(b1) 
> ecc(a), а это противоречит выбору вершины a. 
 
 
 
 
 
 
 

x

 

 

Рис. 1.23 

 

Следовательно, любые две центральные вершины смежны, а так как в 
дереве не может быть трех попарно смежных вершин, то в нем не больше 
двух центральных вершин. (cid:0) 
 
1.5.3. Корневые деревья 
Часто в дереве особо выделяется одна вершина, играющая роль своего 
рода «начала отсчета». Дерево с выделенной вершиной называют корне-
вым  деревом,  а  саму  эту  вершину  –  корнем.  Из  дерева  с  n  вершинами 
можно, таким образом, образовать n различных корневых деревьев. 

При  графическом  изображении  корневого  дерева  обычно  придержи-
ваются  какого-нибудь  стандарта.  Один  из  наиболее  распространенных 
состоит  в  следующем.  Возьмем  на  плоскости  семейство  параллельных 
прямых с равными расстояниями между соседними прямыми. Изобразим 
корень  точкой  на  одной  из  этих  прямых,  смежные  с  корнем  вершины  – 
точками на соседней прямой, вершины, находящиеся на расстоянии 2 от 
корня – на следующей, и т.д. Ребра изобразим отрезками прямых. Ясно, 
что  вершины  на  каждой  прямой  можно  разместить  так,  чтобы  ребра  не 
пересекались.  Пример  нарисованного  таким  образом  корневого  дерева 
показан  на  рис.  1.24  (корень  обведен  кружком).  Чаще,  впрочем,  дерево 
рисуют корнем вверх, а не вниз.  
 
 
 
 
 
 
 
 
 

Рис. 1.24 

 

27

Иногда  бывает  полезно  ребра  корневого  дерева  ориентировать  так, 
чтобы в каждую вершину вел ориентированный путь из корня (для дерева 
на рис. 1.24 это означает, что каждое ребро ориентируется снизу вверх). 
Такое ориентированное корневое дерево будем называть исходящим дере-
вом. В исходящем дереве каждая вершина, кроме корня, является концом 
единственного ребра. Если в исходящем дереве имеется ребро xy, то вер-
шину x называют отцом вершины y, а вершину y – сыном вершины x. Ес-
тественный и для многих целей удобный способ задания корневого дерева 
состоит в указании для каждой вершины ее отца. При этом иногда счита-
ют, что корень приходится отцом самому себе – это равносильно добав-
лению петли при корне. 

Если в исходящем дереве T имеется ориентированный путь из верши-
ны x в вершину y, то говорят, что x – предок y, а y – потомок x. В частно-
сти, каждая вершина является предком и потомком самой себя. Множест-
во всех предков вершины x порождает ориентированный путь из корня в 
x.  Множество  всех  потомков  вершины  x  порождает  исходящее  дерево  с 
корнем в x, оно называется ветвью дерева T в вершине x. 

Высотой корневого дерева называется эксцентриситет его корня. Если 
мы хотим превратить некоторое дерево в корневое и притом минимальной 
высоты, то в качестве корня следует взять центральную вершину. 
 

1.5.4. Каркасы 
Пусть  G  –  обыкновенный  граф.  Его  каркасом  называется  остовный 
подграф, в котором нет циклов, а области связности совпадают с областя-
ми связности графа G. Таким образом, каркас связного графа – дерево, а в 
общем случае – лес. 

 

28

 

У  любого  графа  есть  хотя  бы  один  каркас.  Действительно,  если  в G 
нет  циклов,  то  он  сам  является  собственным  каркасом.  Если  же  циклы 
есть,  то  можно  удалить  из  графа  любое  ребро,  принадлежащее  какому-
нибудь циклу. Такое ребро не является перешейком, поэтому при его уда-
лении области связности не изменятся. Продолжая действовать таким об-
разом,  после  удаления  некоторого  количества  ребер  получим  остовный 
подграф, в котором циклов уже нет, а области связности – те же, что у ис-
ходного графа, то есть этот подграф и будет каркасом. Можно даже точно 
сказать, сколько ребер необходимо удалить для получения каркаса. Если в 
графе n вершин, m ребер и k компонент связности, то в каркасе будет то-
же n вершин и k компонент связности. Но в любом лесе с n вершинами и k 
компонентами связности имеется ровно n – k ребер. Значит, удалено бу-
дет  m  –  n  +  k    ребер.  Это  число  называется  цикломатическим  числом      

графа и обозначается через v(G). 

Если  в  графе  есть циклы, то у него больше одного каркаса. Опреде-
лить  точное  число  каркасов  связного  графа  позволяет  так  называемая 
матричная теорема Кирхгофа. Приведем ее без доказательства. Для графа 
G определим матрицу K(G) – квадратную матрицу порядка n с элемента-
ми 

 

 

Kij

=

i

j
EG
),(   
   ,1
,
если
∈
−
⎧
⎪
EG
j
i
i
   
),(   
   ,0
   
если
и
∉
⎨
⎪
j
i
i
   
deg(
   
),
.
если
=
⎩

≠

j

,

 

Иначе говоря, K(G) получается из матрицы смежности, если заменить 
все 1 на –1, а вместо нулей на главной диагонали поставить степени вер-
шин. Заметим, что матрица K(G) – вырожденная, так как сумма элементов 
каждой строки равна 0, то есть столбцы линейно зависимы. 

Теорема  1.10.  (матричная  теорема  Кирхгофа).  Если  G  –  связный 
граф с не менее чем двумя вершинами, то алгебраические дополнения всех 
элементов  матрицы  K(G)  равны  между  собой  и  равны  числу  каркасов 
графа G. 
 

1.6. Эйлеровы графы 

 

Первая теорема теории графов была доказана задолго до того, как ста-
ло  употребляться  словосочетание  «теория  графов».  В  1736  г.  появилась 
работа Эйлера, в которой не только была решена предложенная ему зада-
ча о кенигсбергских мостах, но и сформулировано общее правило, позво-
ляющее решить любую задачу такого рода. Интересно, что в одном из пи-
сем Эйлер писал по этому поводу: «...это решение по своему характеру, 
по-видимому, имеет мало отношения к математике, и мне непонятно, по-
чему следует скорее от математика ожидать этого решения, нежели от ка-
кого-нибудь другого человека...». 

На языке теории графов задача состоит в том, чтобы определить, име-
ется  ли  в  графе  путь,  проходящий  через  все  его  ребра  (напомним,  что 
путь, по определению, не может дважды проходить по одному ребру). Та-
кой путь называется эйлеровым путем, а если он замкнут, то эйлеровым 
циклом. Граф, в котором есть эйлеров цикл, называют эйлеровым графом. 
В графе, изображенном на рис. 1.25,а, эйлеров цикл существует – напри-
мер, последовательность вершин 1, 2, 4, 5, 2, 3, 5, 6, 3, 1 образует такой 
цикл. В графе же на рис. 1.25,б эйлерова цикла нет, но есть эйлеровы пу-
ти, например, 2, 4, 5, 2, 1, 3, 5, 6, 3. 

 

29

1

2

 
 
 
 
 
 
                                 а)                                                                     б) 
 

5 

5

6

4

4

3

2

1

 

Рис. 1.25 

3

6 

 

 

Рассмотрим  сначала  условия  существования  эйлерова  цикла  в  обык-
новенном графе. Ясно, что в несвязном графе эйлеров цикл может суще-
ствовать  только  в  том  случае,  когда  все  его  ребра  принадлежат  одной 
компоненте связности, а все остальные компоненты – просто изолирован-
ные вершины. Поэтому достаточно рассматривать связные графы. 

Теорема  1.11.  Связный  граф  эйлеров  тогда  и  только  тогда,  когда  в 

нем степени всех вершин четны. 

Доказательство. Необходимость условия очевидна, так как при каж-
дом  прохождении  цикла  через  какую-либо  вершину  используются  два 
ребра – по одному из них маршрут входит в вершину, по другому выходит 
из нее (это относится и к стартовой вершине – в ней ведь маршрут должен 
закончиться). Докажем его достаточность. 

Пусть G – связный граф, в котором больше одной вершины и степени 
всех  вершин  четны.  Значит,  степень  каждой  вершины  не  меньше  2,  по-
этому  по  лемме  1.4  в  графе G  имеется  цикл Z1.  Если  удалить  все  ребра 
этого цикла из графа G, то получится граф G1, в котором степени вершин 
также четны. Если в G1 нет ни одного ребра, то Z1 – эйлеров цикл. В про-
тивном  случае,  применяя  ту  же  лемму  1.4  к  графу,  полученному  из  G1 
удалением  всех  изолированных  вершин,  заключаем,  что  в  G1  имеется 
цикл Z2. Удалив из G1 все ребра цикла Z2, получим граф G2. Продолжая 
действовать таким образом, пока не придем к пустому графу, получим в 
итоге систему циклов Z1, …, Zk, причем каждое ребро графа принадлежит 
в точности одному из них. Покажем теперь, что из этих циклов можно со-
ставить  один  цикл.  Действительно,  из  того,  что  исходный  граф  связен, 
следует, что хотя бы один из циклов Z1, …, Zk–1 имеет общую вершину с 
Zk. Допустим, для определенности, что таков цикл Zk–1. Пусть Zk = x1, x2, 
…,  xp,  Zk–1  =  y1,  y2,  …,  yq,  и  xi  =  yj  для  некоторых  i  и  j.  Тогда 
последовательность вершин  
yx
,
i

xy
,
i
j

yy
,
q

− =′
k
1

xx
,
1

…

…

…

…

Z

x

y

1
+

1
+

,

j

+

2

,

2

,

2

 

p

,

j

,

,

,

,

,

 

30

 

очевидно, является циклом, а множество ребер этого цикла есть объеди-
нение множеств ребер циклов Zk–1 и Zk. Таким образом, получаем систему 
из меньшего числа циклов, по-прежнему обладающую тем свойством, что 
каждое ребро графа принадлежит в точности одному из них. Действуя да-
лее таким же образом, в конце концов получим один цикл, который и бу-
дет эйлеровым (cid:0). 

Теорема  1.11  верна  и  для  мультиграфов  (кстати,  в  задаче  о  кенигс-
бергских мостах ситуация моделируется именно мультиграфом). Она ос-
тается верной и при наличии петель, если при подсчете степеней вершин 
каждую петлю считать дважды. 

Теперь нетрудно получить и критерий существования эйлерова пути. 
Теорема  1.12.  Эйлеров  путь  в  связном  графе  существует  тогда  и 
только  тогда,  когда  в  нем  имеется  не  более  двух  вершин  с  нечетными 
степенями.  

Доказательство.  Если  в  графе  нет  вершин  с  нечетными  степенями, 
то,  по  предыдущей  теореме,  в  нем  имеется  эйлеров  цикл,  он  является  и 
эйлеровым путем. Не может быть точно одной вершины с нечетной сте-
пенью – это следует из теоремы 1.2. Если же имеются точно две вершины 
с нечетными степенями, то построим новый граф, добавив ребро, соеди-
няющее эти вершины. В новом графе степени всех вершин четны и, сле-
довательно, существует эйлеров цикл (возможно, что при добавлении но-
вого ребра получатся кратные ребра, но, как отмечалось выше, теорема об 
эйлеровом цикле верна и для мультиграфов). Так как циклический сдвиг 
цикла – тоже цикл, то существует и такой эйлеров цикл, в котором добав-
ленное  ребро  –  последнее.  Удалив  из  этого  цикла  последнюю  вершину, 
получим эйлеров путь в исходном графе (cid:0). 

В ориентированном графе под эйлеровым путем (циклом) понимают 
ориентированный путь (цикл), проходящий через все ребра графа. Ориен-
тированный вариант критерия существования эйлерова цикла формулиру-
ется следующим образом. 

Теорема 1.13. Эйлеров цикл в связном орграфе существует тогда и 
только  тогда,  когда  у  каждой  его  вершины  полустепень  исхода  равна 
полустепени захода.  
 

1.7. Двудольные графы 

 

Граф называется двудольным, если множество его вершин можно так 
разбить на два подмножества, чтобы концы каждого ребра принадлежали 
разным  подмножествам.  Эти  подмножества  называются  долями.  Таким 
образом, каждая из долей порождает пустой подграф. Примером двудоль-

 

31

ного графа является простая цепь Pn при любом n: одна доля порождается 
вершинами с четными номерами, другая – с нечетными. Граф K3 – пример 
графа, не являющегося двудольным: при любом разбиении множества его 
вершин на два подмножества в одном из этих подмножеств окажутся две 
смежных вершины. 

Прикладное значение понятия двудольного графа связано с тем, что с 
помощью таких графов моделируются отношения между объектами двух 
типов, а такие отношения часто встречаются на практике (например, от-
ношение  «продукт  x  используется  в  производстве  изделия y»  между  ис-
ходными  продуктами  и  готовыми  изделиями,  или  «работник  x  владеет 
профессией y» между работниками и профессиями). В математике такие 
отношения тоже не редки, один из наиболее распространенных их видов – 
отношения  инцидентности.  Пусть  A  –  множество,  а  B  –  семейство  его 
подмножеств. Элемент x ∈ A и множество X ∈ B инцидентны друг другу, 
если  x  ∈  X.  Отношение  инцидентности  можно  описать  с  помощью  дву-
дольного графа G, в котором VG = A ∪ B, EG = {(x, X)| x ∈ A, X ∈ B, x ∈ X}. 
На рис. 1.26 показан граф отношения инцидентности для A = (a, b, c}, B = 
= {B1, B2, B3, B4}, где B1 = {a}, B2 = {a, b, c}, B3 = {b, c}, B4 = ∅. 
 
 
 
 
 
 
 

B3

B1

B2

B4

a 

b

c

Рис. 1.26 

 

Вообще  говоря,  разбиение  множества  вершин  двудольного  графа  на 
доли  можно  осуществить  не  единственным  способом.  Так,  в  графе  из 
только что приведенного примера можно взять в качестве долей множест-
ва {a, b, c, B4} и {B1, B2, B3}. В то же время в самом определении этого 
графа уже заложено «естественное» разбиение на доли A и B. Двудольные 
графы, возникающие в приложениях, нередко бывают заданы именно так 
– с множеством вершин, изначально состоящим из двух частей, и с мно-
жеством ребер, каждое из которых соединяет вершины из разных частей. 
Если разбиение на доли не задано, то может возникнуть вопрос, суще-
ствует ли оно вообще, то есть является ли данный граф двудольным? Если 
в  графе  n  вершин,  то  имеется  2n–1  разбиений  множества  вершин  на  два 
подмножества  и  непосредственная  проверка  всех  этих  разбиений  будет 
очень трудоемким делом. Следующая теорема дает критерий двудольно-

32

 

сти, а из ее доказательства можно извлечь и эффективный алгоритм про-
верки двудольности. Подробно такой алгоритм будет описан в следующей 
главе. 

Теорема 1.14. Следующие утверждения для графа G равносильны: 
(1) G – двудольный граф; 
(2) в G нет циклов нечетной длины; 
(3) в G нет простых циклов нечетной длины. 
Доказательство. Докажем, что из (1) следует (2). Пусть G – двудоль-
ный граф, в котором выбрано некоторое разбиение на доли, С = x1, x2, …, 
xk, x1 – цикл длины k в графе G. При любом i = 1, …, k – 1 вершины xi и 
xi+1  смежны  и,  следовательно,  принадлежат  разным  долям.  Таким  обра-
зом, одна доля состоит из всех вершин с нечетными индексами, то есть  
x1, x3, …, другая – из всех вершин с четными индексами. Но вершины xk и 
x1 тоже смежны и должны принадлежать разным долям. Следовательно,   
k – четное число. 

Очевидно, что из (2) следует (3); остается доказать, что из (3) следует 
(1). Рассмотрим граф G, в котором нет простых циклов нечетной длины. 
Ясно,  что  граф,  в  котором  каждая  компонента  связности  –  двудольный 
граф,  сам  двудольный.  Поэтому  можно  считать,  что  граф  G  связен.  За-
фиксируем в нем некоторую вершину a и докажем, что для любых двух 
смежных между собой вершин x и y имеет место равенство 

Действительно, допустим сначала, что | d(a, x) = d(a, y) | = t. Пусть x1, x2, 
…, xt – кратчайший путь из a в x, y1, y2, …, yt – кратчайший путь из a в y. 
Эти пути начинаются в одной вершине: x1 = y1 = a, а оканчиваются в раз-
ных: xt = x, yt = y. Поэтому найдется такое k, что xk = yk и xi ≠ yi при всех i 
>  k.  Но  тогда  последовательность  xk,  xk+1,  …,  xt,  yt,  …, yk+1, yk  является 
простым  циклом  длины  2(t  –  k)  +  1.  Следовательно,  d(a, x)  ≠  d(a,  y). 
Предположим, что d(a, x) < d(a, y). Если x1, x2, …, xt – кратчайший путь 
из a в x, то, очевидно, x1, x2, …, xt, y – кратчайший путь из a в y, следова-
тельно, d(a, y) = d(a, x) + 1. Итак, расстояния от двух смежных вершин до 
вершины a различаются ровно на единицу. Поэтому, если обозначить че-
рез A множество всех вершин графа, расстояние от которых до вершины a 
четно, а через B множество всех вершин с нечетными расстояниями до a, 
то для каждого ребра графа один из его концов принадлежит множеству 
A, другой – множеству B. Следовательно, граф G –двудольный. (cid:0) 

Пусть C – цикл в графе G. Множество вершин цикла C порождает в G 

 

33

 

 

| d(a, x) – d(a, y) | = 1. 

подграф, который содержит все ребра этого цикла, но может содержать и 
ребра,  ему  не  принадлежащие.  Такие  ребра  называют  хордами  цикла  C. 
Простой  цикл,  не  имеющий  хорд,  –  это  порожденный  простой  цикл.  В 
графе, изображенном на рис. 1.27, хордами цикла 4, 1, 2, 6, 5, 4 являются 
ребра (1, 5), (1, 6) и (2, 5), а цикл 2, 3, 7, 6, 2 – порожденный простой 
цикл.  
 
 
 
 
 
 
 
 

C1

C2

C

x

y

2

6

1

5

3

7

4

Рис. 1.27 

Заметим,  что  любой  цикл  длины  3  является  порожденным  простым 

циклом. 

Пусть C – простой цикл длины k в некотором графе, (x, y) – хорда это-
го цикла. Ребро (x, y) вместе с ребрами цикла C образует два цикла мень-
шей длины, C1 и C2 (см. рис. 1.28), сумма длин которых равна k + 2. 

Значит, если C – цикл нечетной длины, то один из циклов C1, C2 тоже 
имеет нечетную длину. Отсюда следует, что в графе, в котором есть цикл 
нечетной длины, имеется и порожденный простой цикл нечетной длины. 
Поэтому критерий двудольности справедлив и в следующей формулиров-
ке. 

Следствие. Граф является двудольным тогда и только тогда, когда в 

нем нет порожденных простых циклов нечетной длины. 
 

1.8. Планарные графы 

Геометрический  граф  –  это  плоская  фигура,  состоящая  из  вершин  – 
точек плоскости и ребер – линий, соединяющих некоторые пары вершин. 
Всякий  граф  можно  многими  способами  представить  геометрическим 
графом, и мы уже не раз пользовались этой возможностью. На рис. 1.29 
показаны  два  геометрических  графа  Г1  и  Г2,  представляющих,  как  не-
трудно проверить, один и тот же обыкновенный граф. Простое устройство 
этого графа, очевидное на левом изображении, не так легко обнаружить, 
рассматривая  правое.  Главная  причина  этого  –  в  том,  что  в  Г1  ребра  не 
имеют «лишних» пересечений. 

Геометрический граф, в котором никакие два ребра не имеют общих 

 

 

34

 

точек, кроме инцидентной им обоим вершины, называют плоским графом, 
а по отношению к представляемому им обыкновенному графу – его пло-
ской  укладкой.  Не  каждый  граф  допускает  плоскую  укладку.  Граф,  для 
которого  существует  плоская  укладка,  называется  планарным  графом. 
Кроме удобства визуального анализа, есть немало поводов, в том числе и 
сугубо практических, для интереса к планарным графам и их плоским ук-
ладкам. 
 
 
 
 
 
 
 
 
 
 
                                          Г1                                                      Г2

3 

7 

5 

1 

4

5

6

4

6

8

1

7

3

2

2

8

Рис. 1.29 

 

 

Если плоскость разрезать по ребрам плоского графа, она распадется на 
связные  части,  которые  называют  гранями. Всегда имеется одна неогра-
ниченная  внешняя грань, все остальные грани называются внутренними. 
Если в плоском графе нет циклов, то у него имеется только одна грань. 
Если же циклы есть, то граница каждой грани содержит цикл, но не обяза-
тельно является циклом. На рис. 1.30 показан плоский граф с пятью зану-
мерованными гранями. Граница грани с номером 3 состоит из двух цик-
лов, а граница грани с номером 2 кроме цикла длины 5 включает еще де-
рево из трех ребер. Множества ребер, образующие границы граней, могут 
быть  разными  для  разных  плоских  укладок  одного  и  того  же  графа.  На 
рис.  1.31  показаны  две  плоские  укладки  одного  графа.  В  левой  укладке 
есть две грани, границы которых являются простыми циклами длины 5. В 
правой  укладке  таких  граней  нет,  но  есть  грани,  ограниченные циклами 
длины 4 и 6. Однако число граней, как показывает следующая теорема, не 
зависит от укладки, то есть является инвариантом планарного графа. 
 
 
 
 
 
 

Рис. 1.30                                                                   Рис. 1.31

5 

3 

2 

1 

4

 

35

Теорема 1.15. (формула Эйлера). Количество граней в любой плоской 
укладке  планарного  графа,  имеющего  n  вершин,  m  ребер  и  k  компонент 
связности, равно m – n + k + 1. 

Доказательство. Докажем сначала утверждение теоремы при k = 1. 
Рассмотрим связный плоский граф G . Если в нем нет циклов, то имеется 
единственная грань, а m = n – 1, и формула верна. Если же есть хотя бы 
один  цикл,  то  возьмем  какое-нибудь  ребро  e,  принадлежащее  простому 
циклу C. Это ребро принадлежит границе двух граней, одна из которых 
целиком лежит внутри цикла C, другая – снаружи. Если удалить ребро e 
из графа, эти две грани сольются в одну. Граф G1, полученный из графа G 
удалением  ребра  e,  очевидно,  будет  плоским  и  связным,  в  нем  на  одно 
ребро и на одну грань меньше, чем в G, а число вершин осталось преж-
ним. Если в G1 еще есть циклы, то, удалив еще одно цикловое ребро, по-
лучим граф G2. Будем продолжать удаление цикловых ребер до тех пор, 
пока не получится связный плоский граф Gr без циклов, то есть дерево. У 
него  n  –  1  ребро  и  единственная  грань.  Значит,  всего  было  удалено r =          
= m – n + 1 ребер, а так как при удалении каждого ребра число граней 
уменьшалось на единицу, то в исходном графе было m – n + 2 грани. Та-
ким  образом,  формула  верна  для  любого  связного  плоского  графа. Если 
граф не связен, то в компоненте связности, имеющей ni вершин и mi ре-
бер, как доказано выше, будет mi – ni + 1 внутренняя грань. Суммируя по 
всем компонентам и прибавляя 1 для учета внешней грани, убеждаемся в 
справедливости формулы в общем случае. (cid:0) 

Следствие 1. Если в планарном графе n вершин, n ≥ 3, и m ребер, то 

m ≤ 3(n – 2). 

Доказательство. Если в графе нет циклов, то m = n – k и неравенство 
выполняется при n ≥ 3. Рассмотрим плоский граф G с r гранями, в кото-
ром имеются циклы. Занумеруем грани числами от 1 до r и обозначим че-
рез ai количество ребер, принадлежащих грани с номером i. Так как гра-
ница каждой грани содержит цикл, то ai ≥ 3 для каждого i, следовательно, 
r
≥∑
. С другой стороны, каждое ребро принадлежит границе не бо-

r
3

a

i

i
1
=
лее чем двух граней, поэтому 

r

≤∑

a
i

i

1
=

2

m

. Из этих двух неравенств следу-

ет, что 3r ≤ 2m. Применяя формулу Эйлера, получаем m ≤ 3n – 3k – 3 ≤     
≤ 3n – 6 (cid:0). 

Следствие 1 дает необходимое условие планарности, которое в неко-

36

 

торых  случаях  позволяет  установить,  что  граф  не  является  планарным. 
Рассмотрим, например, полный граф K5. У него n = 5, m = 10 и мы видим, 
что неравенство из следствия 1 не выполняется. Значит, этот граф не пла-
нарен. В то же время существуют графы, не являющиеся планарными, для 
которых  неравенство  следствия  1  выполняется.  Пример  –  полный  дву-
дольный граф K3,3. У него 6 вершин и 9 ребер. Неравенство выполняется, 
но мы сейчас установим, что он не планарен. Заметим, что в этом графе 
нет циклов длины 3 (так как он двудольный, в нем вообще нет циклов не-
четной длины). Поэтому граница каждой грани содержит не менее четы-
рех  ребер.  Повторяя  рассуждения  из  доказательства  следствия  1,  но  ис-
пользуя неравенство ai ≥ 4 вместо ai ≥ 3, получаем следующий результат. 
Следствие 2. Если в планарном графе n вершин, n ≥ 3, m ребер и нет 

циклов длины 3, то m ≤ 2(n – 2). 

ет, что он не планарен. 

Для графа K3,3 неравенство следствия 2 не выполняется, это доказыва-

Известно несколько критериев планарности, сформулируем без дока-
зательства два из них. Два графа называют гомеоморфными, если из них с 
помощью  подразбиения  ребер  можно  получить  изоморфные  графы.  На 
рис. 1.32 изображены гомеоморфные графы.  
 
 
 
 
 
 

Рис. 1.32 

 

Сформулируем без доказательства два критерия планарности. 
Теорема 1.16. (Критерий Понтрягина – Куратовского). Граф плана-
рен тогда и только тогда, когда у него нет подграфов, гомеоморфных K5 
или K3,3. 

Граф G называется стягиваемым к графу H, если H можно получить 

из G последовательностью операций стягивания ребер. 

Теорема  1.17.  (Критерий  Вагнера).  Граф  планарен  тогда  и  только 

тогда, когда у него нет подграфов, стягиваемых к K5 или K3,3. 

Отметим,  что,  несмотря  на  внешнее  сходство  двух  теорем,  фигури-
рующие в них понятия гомеоморфизма и стягиваемости существенно раз-
личны. Так, граф Петерсена стягивается к графу K5, но в нем нет подгра-
фа, гомеоморфного K5 (см. задачу 2). 
 

 

37

1.  Определите  число  неориентированных  графов  с  n  вершинами,  в 

которых нет кратных ребер, но могут быть петли. 

2. Определите число ориентированных графов с n вершинами без пе-

тель, в которых каждая пара различных вершин соединена 

а) не более чем одним ребром; 
б) точно одним ребром. 
3.  Для  любого  натурального  числа k определим граф Qk следующим 
образом. Вершинами его являются всевозможные упорядоченные двоич-
ные наборы длины k. Всего, таким образом, в этом графе 2k вершин. Вер-
шины x = (x1, …, xk) и y = (y1, …, yk) смежны в нем тогда и только тогда, 
когда наборы x и y различаются точно в одной координате. Этот граф на-
зывается k-мерным кубом. Определите число ребер в графе Qk. 

4.  Граф  перестановок  порядка  k    строится  следующим  образом. Его 
вершины соответствуют всевозможным перестановкам элементов 1, 2, ..., 
k. В этом графе, следовательно, k! вершин. Две вершины смежны тогда и 
только  тогда,  когда  одна  из  соответствующих  перестановок  может  быть 
получена  из  другой  одной  транспозицией  (перестановкой  двух  элемен-
тов). При k = 3 этот граф показан на рис. 1.33. Определите число ребер в 
графе перестановок порядка k. 
 
 
 
 
 
 
 
 
 

2,1,3

2,3,1

3,2,1

3,1,2

1,3,2

1,2,3

Рис. 1.33 

 

 

  

Задачи 

5. Перечислите все попарно неизоморфные графы 
а) с 4 вершинами; 
б) с 6 вершинами и 3 ребрами; 
в) с 6 вершинами и 13 ребрами. 
6. Найдите все (с точностью до изоморфизма) графы с 6 вершинами, у 

которых степень каждой вершины равна 3. 

7.  Выясните,  при  каких  значениях  n  существуют  регулярные  графы 

степени а) 3; б) 4 с n вершинами. 

38

 

8. Сколько имеется различных изоморфизмов G1 в G2 для графов, изо-

браженных на рис. 1.8? 

9.  Граф,  изоморфный  своему  дополнению,  называется  самодополни-

а) Докажите, что граф C5 – самодополнительный. 
б) Найдите самодополнительный граф с наименьшим числом вершин 

тельным. 

n > 1. 

в) Существуют ли самодополительные графы с 6 вершинами? 
10. Выясните, какие из графов, изображенных на рис. 1.34, изоморфны 

друг другу. 
 
 
 
 
 
 
           G1                        G2                         G3                         G4                         G5

Рис. 1.34 

11. На рис. 1.35 изображен граф Петерсена. Выясните, можно ли из 

него получить граф K5 с помощью операций 

а) удаления вершин и ребер и подразбиения ребер; 
б) стягивания ребер. 

 

 
 
 
 
 
 
 
 

 

Рис. 1.35 

12. Проверьте, что каждый граф с 3 вершинами является либо суммой, 
либо соединением меньших графов. Верно ли это для графов с 4 верши-
нами? 

13. В графе G1 имеется n1 вершин и m1 ребер, а в графе G2 – n2 вершин 

и m2 ребер. Сколько ребер будет в графе G1 ° G2? В графе G1 × G2? 

14.  Верен  ли  для  произвольных  графов  G1,  G2,  G3  «дистрибутивный 

закон» (G1 + G2) ° G3 = (G1 ° G3) + (G2 ° G3)? 

 

39

15. Найдите радиус и диаметр каждого из графов Cn, Qk, Kp,q, Wn. 
16. Сколько имеется в графе Qn путей длины n, соединяющих верши-

ну (0, 0, ..., 0) с вершиной (1, 1, ..., 1)? 

17. Какое наибольшее число шарниров может быть в графе с n верши-

нами? 

18. Докажите, что для любого графа G справедливы неравенства 

rad(G) ≤ diam(G) ≤ 2rad(G). 

19. Перечислите все (с точностью до изоморфизма) деревья с числом 

вершин, не превосходящим 6. 

20.  Пусть  в  дереве  с  n  вершинами  каждая  вершина,  не  являющаяся 

листом, имеет степень k. Сколько в нем листьев? 

21. Сколько ребер в лесе с n вершинами и k компонентами связности ? 
22. Какой может быть наименьшая высота корневого дерева, у которо-

го каждая вершина имеет не более двух сыновей, если 

а) дерево имеет n листьев? 
б) дерево имеет n вершин?  
23.    Выясните,  какие  из  следующих  утверждений  верны  для  любого 

графа G и любого его ребра e: 

а) в G существует каркас, содержащий e; 
б) в G существует каркас, не содержащий e; 
в) если e – не перешеек, то в G существует каркас, не содержащий e; 
24. Каждое дерево с множеством вершин {1, 2, …, n} является карка-
сом полного графа Kn. Применяя теорему Кирхгофа, найдите число раз-
личных деревьев с n вершинами. 

25. При каких n существует эйлеров цикл в графе Qn? 
26.  Докажите,  что  если  в  связном  графе  имеется  ровно  2k  вершин  с 
нечетными степенями, то множество его ребер можно разбить на k путей. 

 

 

 
 
 
 
 
 

 

27.  Верно  ли,  что  для  любых  двудольных  графов  G1  и  G2  граф               

а) G1 ∪ G2, б) G1 ∩ G2, в) G1 × G2 будет двудольным? 

26. Докажите, что граф Qk при любом k является двудольным. 
28. Выясните, какие из графов, изображенных на рис. 1.36 , планарны. 

Рис. 1.36 

40

 

29. Найдите в графе Петерсена подграф, гомеоморфный графу K3,3. 
30. Какое наименьшее количество ребер нужно удалить из графа K6, 

чтобы получить планарный граф? 

31.  Обобщите  необходимое  условие  планарности  из  следствия  2  на 

графы, в которых наименьшая длина цикла равна c. 

 

41

Глава 2. Анализ графов 

В этой главе рассматриваются некоторые задачи исследования струк-
турных свойств и метрических характеристик графов. Нельзя сказать, что 
это четко определенный круг задач, но, в общем, речь идет об инструмен-
тах,  с  помощью  которых  мы  можем  что-то  узнать  об  устройстве  графа. 
Эти знания могут помочь в решении более сложных задач. 

Многие задачи анализа графов могут быть решены путем обхода гра-
фа с посещением всех его вершин и исследованием всех его ребер. Такой 
обход можно выполнить многими способами, в действительности же ши-
рокое  распространение  благодаря  своей  простоте,  а  в  большей  степени 
благодаря своей полезности, получили две стратегии – поиск в глубину и 
поиск в ширину. Рассмотрение этих алгоритмов и их применений состав-
ляет  содержание  первых  трех  разделов  настоящей  главы.  В  остальных 
трех разделах рассматриваются задачи анализа циклов в графах. 
 

2.1. Поиск в ширину 

 
 
 

 

 

 

2.1.1. Метод поиска в ширину 
Работа  всякого  алгоритма  обхода  состоит  в  последовательном  посе-
щении  вершин  и  исследовании  ребер.  Какие  именно  действия  выполня-
ются при посещении вершины и исследовании ребра – это зависит от кон-
кретной задачи, для решения которой производится обход. В любом слу-
чае,  однако,  факт  посещения  вершины  запоминается,  так  что  с  момента 
посещения и до конца работы алгоритма она считается посещенной. Вер-
шину, которая еще не посещена, будем называть новой. В результате по-
сещения вершина становится открытой и остается такой, пока не будут 
исследованы все инцидентные ей ребра. После этого она превращается в 
закрытую. 

Идея поиска в ширину состоит в том, чтобы посещать вершины в по-
рядке  их  удаленности  от  некоторой  заранее  выбранной  или  указанной 
стартовой вершины a. Иначе говоря, сначала посещается сама вершина a, 
затем все вершины, смежные с a, то есть находящиеся от нее на расстоя-
нии 1, затем вершины, находящиеся от a на расстоянии 2, и т.д.  

Рассмотрим алгоритм поиска в ширину с заданной стартовой верши-
ной a. Вначале все вершины помечаются как новые. Первой посещается 
вершина  a,  она  становится  единственной  открытой  вершиной.  В  даль-

42

 

нейшем каждый очередной шаг начинается с выбора некоторой открытой 
вершины x. Эта вершина становится активной. Далее исследуются ребра, 
инцидентные активной вершине. Если такое ребро соединяет вершину x с 
новой вершиной y, то вершина y посещается и превращается в открытую. 
Когда все ребра, инцидентные активной вершине, исследованы, она пере-
стает быть активной и становится закрытой. После этого выбирается но-
вая  активная  вершина,  и  описанные  действия  повторяются.  Процесс  за-
канчивается, когда множество открытых вершин становится пустым. 

Основная  особенность  поиска  в  ширину,  отличающая  его  от  других 
способов обхода графов, состоит в том, что в качестве активной вершины 
выбирается  та  из  открытых,  которая  была  посещена  раньше  других. 
Именно  этим  обеспечивается  главное  свойство  поиска  в  ширину:  чем 
ближе вершина к старту, тем раньше она будет посещена. Для реализации 
такого правила выбора активной вершины удобно использовать для хра-
нения множества открытых вершин очередь – когда новая вершина стано-
вится открытой, она добавляется в конец очереди, а активная выбирается 
в ее начале. Схематически процесс изменения статуса вершин изображен 
на рис. 2.1. Черным кружком показана активная вершина. 
 
 
 
 
 
 

Открытые

Закрытые

Новые 

 

 

Рис. 2.1 

Опишем процедуру поиска в ширину (BFS – от английского названия 
этого алгоритма – Breadth First Search) из заданной стартовой вершины a. 
  обозначает  множество  всех  вершин,  смежных  с 
В  этом  описании 
вершиной x, Q – очередь открытых вершин. Предполагается, что при по-
сещении вершины она помечается как посещенная и эта пометка означает, 
что вершина уже не является новой.  

)(xV

Procedure BFS(a) 
1  посетить вершину a 
2  a ⇒ Q  
3  while Q ≠ ∅ do 
x ⇐ Q 
4 
for y ∈ V(x) do 
5 
6 

 
 

исследовать ребро (x, y) 

 

43

 

 
 
 

 
 
 

y ⇐ Q  

then  посетить  вершину y 
 

if  вершина  y  новая 
 
 

7 
8 
9 
Отметим некоторые свойства процедуры BFS. 
1. Процедура BFS заканчивает работу после конечного числа шагов. 
Действительно, при каждом повторении цикла while из очереди уда-
ляется одна вершина. Вершина добавляется к очереди только тогда, когда 
она посещается.  Каждая вершина может быть посещена не более одного 
раза, так как посещаются только новые вершины, а в результате посеще-
ния  вершина  перестает  быть  новой.  Таким  образом,  число  повторений 
цикла while не превосходит числа вершин.  

2. В результате выполнения процедуры BFS будет посещены все вер-

шины из компоненты связности, содержащей вершину a, и только они. 

Очевидно, что вершина может быть посещена только в том случае, ко-
гда существует путь, соединяющий ее с вершиной a (так как посещается 
всегда  вершина,  смежная  с  уже  посещенной).  То,  что  каждая  такая  вер-
шина  будет  посещена,  легко  доказывается  индукцией  по  расстоянию  от 
данной вершины до вершины a. 

3.  Время  работы  процедуры  BFS  естьO(m),  где  m  –  число  ребер  в 

компоненте связности, содержащей вершину a. 

Из предыдущих рассуждений видно, что каждая вершина из этой ком-
поненты  становится  активной  точно  один  раз.  Внутренний  цикл  for  для 
активной вершины x выполняется deg(x) раз. Следовательно, общее число 
повторений внутреннего цикла будет равно 

deg(

m

2

. 

x

=

)

∑

VGx
∈

 

 

Итак, процедура BFS(a) производит обход компоненты связности, со-
держащей  вершину  a.  Чтобы  перейти  к  другой  компоненте,  достаточно 
выбрать какую-нибудь новую вершину, если такие вершины еще имеют-
ся, в качестве стартовой. Пусть V – множество вершин графа. Следующий 
алгоритм осуществляет полный обход графа методом поиска в ширину. 

for a ∈ V  do  if a новая  then BFS(a) 

Алгоритм 1. Поиск в ширину. 
1  пометить все вершины как новые 
2  создать пустую очередь Q 
3 
Учитывая,  что  цикл  for  в  строке  3  повторяется  n  раз,  где  n  –  число 
вершин графа, получаем общую оценку трудоемкости O(m + n). Необхо-
димо отметить, что эта оценка справедлива в предположении, что время, 
требуемое для просмотра окрестности вершины пропорционально степе-

 

44

 

ни этой вершины. Это имеет место, например, если граф задан списками 
смежности.  Если  же  граф  задан  матрицей  смежности,  то  для  просмотра 
окрестности любой вершины будет затрачиваться время, пропорциональ-
ное  n.  В  этом  случае  общее  время  работы  алгоритма  будет  оценивать-      
ся  как  O(n2).  Наибольшее  значение  величины  m  при  данном  n  равно       
n(n – 1)/2, то есть имеет порядок n2. Таким образом, трудоемкость алго-
ритма поиска в ширину при задании графа списками смежности не выше, 
чем при задании матрицей смежности. В целом же первый способ задания 
предпочтительнее, так как дает выигрыш для графов с небольшим числом 
ребер.  

В  качестве  простейшего  примера  применения  поиска  в  ширину  рас-
смотрим задачу выявления компонент связности графа. Допустим, мы хо-
тим получить ответ в виде таблицы, в которой для каждой вершины x ука-
зан номер comp(x) компоненты, которой принадлежит эта вершина. Ком-
поненты будут получать номера в процессе обхода. Для решения этой за-
дачи  достаточно  ввести  переменную  c  со  значением,  равным  текущему 
номеру компоненты и каждый раз при посещении новой вершины x пола-
гать comp(x) = c. Значение c первоначально устанавливается равным 0 и 
модифицируется при каждом вызове процедуры BFS. 

 

 

2.1.2. BFS-дерево и вычисление расстояний 
Другая простая задача, для решения которой можно применить поиск 
в ширину – построение каркаса. Напомним, что каркасом графа называет-
ся  остовный  лес,  у  которого  области  связности  совпадают  с  областями 
связности графа. Каркас связного графа – остовное дерево. 

Ребра, исследуемые в процессе обхода графа, можно разделить на две 
категории: если ребро соединяет активную вершину x с новой вершиной 
y, то оно классифицируется как прямое, в противном случае – как обрат-
ное. В зависимости от решаемой задачи прямые и обратные ребра могут 
подвергаться различной обработке. 

Предположим, что алгоритм поиска в ширину применяется к связному 
графу. Покажем, что в этом случае по окончании обхода множество всех 
прямых ребер образует дерево. Действительно, допустим, что на некото-
ром шаге работы алгоритма обнаруживается новое прямое ребро (x, y), а 
множество прямых ребер, накопленных к этому шагу, образует дерево F. 
Тогда вершина x принадлежит дереву F, а вершина y не принадлежит ему. 
Поэтому при добавлении к дереву F ребра (x, y) связность сохранится, а 
циклов не появится. 

Итак, если применить поиск в ширину к связному графу и запомнить 

 

45

все прямые ребра, то получим каркас графа. Для произвольного графа бу-
дет получен лес, также, очевидно, являющийся каркасом. 

Каркас, который будет построен описанным образом в результате по-
иска в ширину в связном графе, называется BFS-деревом. Его можно рас-
сматривать  как  корневое  дерево  с  корнем  в  стартовой  вершине  a.  BFS-
дерево с заданным корнем a, вообще говоря, не единственно – зависит от 
того, в каком порядке просматриваются окрестности вершин. Однако вся-
кое  BFS-дерево  обладает  свойством,  на  котором  и  основаны  наиболее 
важные применения поиска в ширину. Каркас T связного графа G с кор-
нем a назовем геодезическим деревом, если для любой вершины x путь из 
x в a в дереве T является кратчайшим путем между x и a в графе G.  
Теорема 2.1. Любое BFS-дерево является геодезическим деревом. 
Доказательство. Обозначим через D(i) множество всех вершин гра-
фа,  находящихся  на  расстоянии  i  от  стартовой  вершины  a.  Работа  алго-
ритма начинается с посещения стартовой вершины, то есть единственной 
вершины, составляющей множество D(0). При первом выполнении цикла  
while будут посещены и помещены в очередь все вершины из множества 
D(1).  Затем  эти  вершины  будут  одна  за  другой  извлекаться  из  очереди, 
становиться  активными,  и  для  каждой  из  них  будут  исследоваться  все 
смежные  с  ней  вершины.  Те  из  них, которые еще не посещались, будут 
посещены и помещены в очередь. Но это как раз все вершины из множе-
ства D(2) (когда начинается исследование окрестностей вершин из D(1), 
ни одна вершина из D(2) еще не посещалась и каждая из них смежна хотя 
бы  с  одной  вершиной  из  D(1).  Следовательно,  каждая  вершина  из  D(2) 
будет посещена после всех вершин из D(1). Рассуждая далее таким обра-
зом, приходим к следующему выводу. 

(А)  Все вершины из D(i + 1) будут посещены после всех вершин из 

D(i), i = 0, 1, … 

следующий факт. 

Строгое доказательство легко провести индукцией по i. Отметим еще 

(Б)  Если  активной  является  вершина  из  D(i),  то  в  этот  момент  все 

вершины из D(i) уже посещены. 

В самом деле, из (А) следует, что вершины из D(i) попадут в очередь 
после вершин из D(i – 1). Поэтому, когда первая вершина из D(i) стано-
вится  активной,  все  вершины  из  D(i  –  1)  уже  закрыты.  Значит,  к  этому 
моменту окрестности всех вершин из D(i – 1) полностью исследованы, и, 
следовательно, все вершины из D(i) посещены. 

Рассмотрим теперь момент работы алгоритма, когда активной являет-

46

 

ся вершина x ∈ D(i) и обнаруживается смежная с ней новая вершина y. В 
BFS-дереве расстояние между y и a на 1 больше, чем расстояние между x 
и a. В графе расстояние между y и a не больше, чем i + 1, так как x и y 
смежны. Ввиду (А) это расстояние не может быть меньше i, а ввиду (Б) 
оно не может быть равно i. Значит, y ∈ D(i + 1), то есть в графе расстоя-
ние между y и a тоже на 1 больше, чем расстояние между x и a. Следова-
тельно, если до какого-то момента работы алгоритма расстояния от каж-
дой из посещенных вершин до стартовой вершины в графе и в дереве бы-
ли равны, то это будет верно и для вновь посещаемой вершины. Посколь-
ку это верно вначале, когда имеется единственная посещенная вершина a 
(оба расстояния равны 0), то это останется верным и тогда, когда будут 
посещены все вершины. 

Итак, мы можем применить поиск в ширину для вычисления расстоя-
ний  от  стартовой  вершины  a  до  всех  остальных  вершин  графа  –  нужно 
только в процессе обхода для каждой посещаемой вершины y определять 
расстояние от y до a в BFS-дереве. Это сделать легко: d(a, y) = d(a, x) + 1, 
где x – активная вершина. Вначале устанавливаем d(a, a) = 0. 

Если граф несвязен, некоторые расстояния будут бесконечными. Что-
бы учесть эту возможность, положим вначале d(a, x) = ∞ для всех x ≠ a. 
Пока вершина x остается новой, для нее сохраняется значение  d(a, x) = ∞, 
когда же она посещается, d(a, x) становится равным расстоянию между a 
и  x  и  больше  не  меняется.  Таким  образом,  бесконечность  расстояния 
можно использовать как признак того, что вершина новая. Если по окон-
чании работы d(a, x) = ∞ для некоторой вершины x, это означает, что x не 
достижима из a, то есть принадлежит другой компоненте связности. 

Для того чтобы не только определять расстояния, но и находить крат-
чайшие пути от a до остальных вершин, достаточно для каждой вершины 
y  знать ее отца F(y) в BFS-дереве. Очевидно, F(y) = x, где x – вершина, 
активная в момент посещения вершины y. Заполнение таблицы F факти-
чески означает построение BFS-дерева. 

Модифицируя процедуру BFS с учетом сделанных замечаний, получа-

ем следующий алгоритм. 

Алгоритм  2.  Построение  BFS-дерева  и  вычисление  расстояний  от 

вершины a до всех остальных  вершин 

for x ∈ V do d(a, x) := ∞ 

 

1 
2  d(a, a) := 0 
3  a ⇒ Q 
4  while Q ≠ ∅ do 

 

47

 
5 
 
6 
 
7 
 
8 
 
9 
10   

 

 

x ⇐ Q 
for y ∈ V(x) do 
 
 
 
 

if  d(a, y) = ∞ 
 
 
 

then  d(a, y) = d(a, x) + 1 
 
 

F (y) := x 
y ⇒ Q 

2.2. Поиск в глубину 

 

2.2.1. Метод поиска в глубину  
Поиск в глубину – вероятно, наиболее важная ввиду многочисленно-
сти приложений стратегия обхода графа. Идея этого метода – идти вперед 
в  неисследованную  область,  пока  это  возможно,  если  же  вокруг  все  ис-
следовано, отступить на шаг назад и искать новые возможности для про-
движения вперед. Метод поиска в глубину известен под разными назва-
ниями, например, «бэктрекинг», «поиск с возвращением». 

Понятия новой, открытой, закрытой и активной вершин для поиска в 
глубину имеют такой же смысл, как и для поиска в ширину. Отметим, что 
всегда имеется не более чем одна активная вершина. 

Обход начинается с посещения заданной стартовой вершины a, кото-
рая становится активной и единственной открытой вершиной. Затем вы-
бирается  инцидентное  вершине  a  ребро 
  и  посещается  вершина  y. 
Она становится открытой и активной. Заметим, что при поиске в ширину 
вершина a оставалась активной до тех пор, пока не были исследованы все 
инцидентные ей ребра. В дальнейшем, как и при поиске в ширину, каж-
дый очередной шаг начинается с выбора активной вершины из множества 
открытых вершин. Если все ребра, инцидентные активной вершине x, уже 
исследованы, она превращается в закрытую. В противном случае выбира-
ется  одно  из  неисследованных  ребер (x, y),  это  ребро  исследуется.  Если 
вершина y новая, то она посещается и превращается в открытую. 

Главное отличие от поиска в ширину состоит в том, что при поиске в 
глубину в качестве активной выбирается та из открытых вершин, которая 
была посещена последней. Для реализации такого правила выбора наибо-
лее удобной структурой хранения множества открытых вершин является 
стек: открываемые вершины складываются в стек в том порядке, в каком 
они открываются, а в качестве активной выбирается последняя вершина. 
Схематически это показано на рис. 2.2. 
 
 

ya
,(

)

48

 

 
 
 
 
 
 
 
 

 

 

 

 

Новые

Открытые

Закрытые

Рис. 2.2 

Обозначим стек для открытых вершин через S, остальные обозначения 
сохраняют тот же смысл, что и в предыдущем разделе. Через top(S) обо-
значается  верхний  элемент  стека  (то  есть  последний  элемент,  добавлен-
ный  к  стеку).  Процедура  обхода  одной  компоненты  связности  методом 
поиска  в  глубину  со  стартовой  вершиной  a  тогда  может  быть  записана 
следующим образом (DFS – от Depth First Search).  

x = top(S) 
if имеется неисследованное ребро (x, y) 
 
 
 
 
  

Procedure DFS(a) 
1  посетить вершину a 
2  a ⇒ S 
3  while S ≠ ∅ do 
 
4 
 
5 
 
6 
 
7 
 
8 
9 
 
10   
Еще  раз  обратим  внимание  на  основное  отличие  этой  процедуры  от 
аналогичной процедуры поиска в ширину. При поиске в ширину вершина, 
став активной, остается ею, пока не будет полностью исследована ее ок-
рестность,  после  чего  она  становится  закрытой.  При  поиске  в  глубину, 
если в окрестности активной вершины x обнаруживается новая вершина y, 
то y помещается в стек и при следующем повторении цикла while станет 
активной. При этом x остается в стеке и через какое-то время снова станет 
активной. Иначе говоря, ребра, инцидентные вершине x, будет исследова-
ны не подряд, а с перерывами.  

then посетить вершину y 
 

Алгоритм обхода всего графа – тот же, что и в случае поиска в шири-
ну (алгоритм 1), только нужно очередь заменить стеком, а процедуру BFS 
– процедурой DFS. 

then исследовать ребро (x, y) 
 
 
 
else удалить х из S 

 if вершина y новая 
 
 

y ⇒

 S

 

49

Свойства 1 и 2 поиска в ширину, отмеченные в предыдущем разделе, 
сохраняются и для поиска в глубину. Остается верной и оценка трудоем-
кости O(m + n), но ее доказательство требует несколько иных рассужде-
ний,  так  как  каждая  вершина  теперь  может  становиться  активной  не-
сколько раз. Однако каждое ребро рассматривается только два раза (один 
раз  для  каждой  инцидентной  ему  вершины),  поэтому  в  операторе  if  в 
строке 5 ветвь then (строки 6-9) повторяется O(m) раз. В этом же операто-
ре  ветвь  else  (строка  10)  повторяется  O(n)  раз,  так  как  каждая  верши-      
на  может  быть  удалена  из  стека  только  один  раз.  В  целом  получается     
O(m + n), причем остаются справедливыми сделанные в предыдущем раз-
деле замечания об условиях, при которых имеет место эта оценка. 

2.2.2. DFS-дерево 
Поиск в глубину можно применить для нахождения компонент связ-
ности графа или для построения каркаса точно таким же образом, как по-
иск в ширину. Понятия прямого и обратного ребра определяются так же, 
как в предыдущем разделе и так же доказывается, что прямые ребра при 
поиске в глубину образуют каркас графа. Для связного графа каркас, по-
лучаемый поиском в глубину, называется DFS-деревом. DFS-дерево рас-
сматривается как корневое дерево с корнем в стартовой вершине a. Это 
дерево обладает особыми свойствами, на использовании которых основа-
ны  многочисленные  применения  метода  поиска  в  глубину.  Рассмотрим 
наиболее важное из этих свойств.  

Относительно любого корневого остовного дерева все ребра графа, не 
принадлежащие дереву, можно разделить на две категории. Ребро назовем 
продольным, если одна из его вершин является предком другой, в против-
ном случае ребро назовем поперечным. В примере на рис. 2.3 ребра карка-
са выделены жирными линиями, корень – черным кружком. 
 
 
 
 
 
 
 
 

1 

7

5

8

3

6

4

2

9
Рис. 2.3 

 

 

 

 

50

 

Обратные  ребра показаны тонкими линиями, из них продольными явля-
ются ребра (1, 7), (2, 9), (3, 8), а поперечными – ребра (1, 2), (2, 5), (3, 5). 

Теорема 2.2. Пусть G – связный граф, T – DFS-дерево графа G. Тогда 

относительно T все обратные ребра являются продольными. 

Доказательство.  Убедимся  сначала,  что,  после  того,  как  стартовая 
вершина a помещена в стек, на каждом последующем шаге работы алго-
ритма  последовательность  вершин,  хранящаяся  в  стеке,  образует  путь  с 
началом в вершине a, а все ребра этого пути принадлежат дереву. Вначале 
это, очевидно, так. В дальнейшем всякий раз, когда новая вершина y по-
мещается в стек, к дереву добавляется прямое ребро (x, y), причем верши-
на x находится в стеке перед вершиной y. Значит, если указанное свойство 
имело  место  до  добавления  вершины  в  стек,  то  оно  сохранится  и  после 
добавления. Удаление же вершины из стека, конечно, не может нарушить 
этого свойства. 

Пусть теперь (x, y) – обратное ребро. Каждая из вершин x и y в ходе 
работы алгоритма когда-либо окажется в стеке. Допустим, x окажется там 
раньше,  чем  y.  Рассмотрим  шаг  алгоритма,  на  котором  y  помещается  в 
стек. В этот момент a еще находится в стеке. Действительно, вершина ис-
ключается из стека только тогда, когда в ее окрестности нет не посещен-
ных  вершин.  Но  непосредственно  перед  помещением  в  стек  вершина  y 
является  новой  и  принадлежит  окрестности  вершины  x.  Таким  образом, 
вершина x лежит на пути, принадлежащем дереву и соединяющем верши-
ны a и y. Но это означает, что вершина x является предком вершины y в 
дереве Т и, следовательно, ребро (x, y) – продольное (cid:0). 

 

Таким образом, каркас, изображенный на рис. 2.3, не мог быть постро-
ен методом поиска в глубину. Кстати, он не мог быть построен и с помо-
щью поиска в ширину (почему?). 
 

2.2.3. Другие варианты алгоритма поиска в глубину 
Ввиду  важности  этого  метода  опишем  еще  два  варианта  алгоритма 
поиска в глубину. Первый из них – рекурсивный, и, как обычно, рекурсия 
дает  возможность  представить  алгоритм  в  наиболее  компактной  форме. 
Для  того,  чтобы  алгоритм  выполнял  какую-то  полезную  работу,  будем 
нумеровать вершины в том порядке, в каком они встречаются при обходе. 
Номер, получаемый вершиной x, обозначается через Dnum(x) и называет-
ся ее глубинным номером. Вначале полагаем Dnum(x) = 0 для всех x. Это 
нулевое значение сохраняется до тех пор, пока вершина не становится от-
крытой, в этот момент ей присваивается ее настоящий глубинный номер. 
Таким образом, нет необходимости в какой-либо специальной структуре 
для запоминания новых вершин – они отличаются от всех других нулевым 
значением Dnum. Переменная c хранит текущий номер. Рекурсивная про-

 

51

цедура DFSR обходит одну компоненту связности, а алгоритм 2 обходит 
весь граф и присваивает вершинам глубинные номера. 

Алгоритм 2. Поиск в глубину с вычислением глубинных номеров – ре-

курсивный вариант 

 

for x ∈ V do Dnum(x) := 0 

for x ∈ V  do 
 

if Dnum(x) = 0 then DFSR(x) 

1 
2  с := 0 
3 
4 
Procedure DFSR(x) 
1  с := с + 1 
2  Dnum(x) := с 
for y ∈ V  do 
3 
if Dnum(y) = 0 then DFSR(y) 
4 
Следующий вариант алгоритма поиска в глубину отличается тем, что 
не использует стека для хранения открытых вершин. Стек нужен для того, 
чтобы  в  момент,  когда  окрестность  активной  вершины  x  исследована  и 
необходимо сделать «шаг назад», можно было определить вершину, в ко-
торую нужно вернуться. Но это та вершина, которая является отцом вер-
шины  x  в  DFS-дереве.  Поэтому,  если  решение  задачи  предусматривает 
построение DFS-дерева, то это дерево можно использовать и для органи-
зации «возвратных движений» в процессе обхода. Описываемый ниже ал-
горитм строит каркас произвольного графа, каждая компонента связности 
этого каркаса является DFS-деревом соответствующей компоненты связ-
ности графа. Через F(x) обозначается отец вершины x в этом DFS-дереве, 
при  этом  для  корня  дерева  (стартовой  вершины)  a  полагаем  F(a)  =  a. 
Здесь  и  далее  в  описаниях  алгоритмов  инструкция  «открыть  (закрыть) 
вершину» означает, что вершина каким-то образом помечается как откры-
тая (закрытая). 

 

 

 

 

 

 

for a ∈ V do 
 

if вершина a новая then DFST(a) 

Алгоритм 3. Поиск в глубину с построением каркаса  
1  пометить все вершины как новые 
2 
 
Procedure DFST(a) 
1  F(a) := a 
2  открыть вершину a  
3  x := a 
4  while x открытая do 

52

 

 

 

 if вершина y новая 
then F(y) := x 
 
 
 
 
 

then исследовать ребро (x, y) 
 
  
 
 
 else закрыть вершину x  
 

открыть вершину y  
x := y 

if имеется неисследованное ребро (x, y) 
 
 
 
 
 
 
 

 
5 
 
6 
 
7 
 
8 
9 
 
10   
11   
12   
2.2.4. Шарниры  
В качестве примера задачи, для эффективного решения которой мож-
но  использовать  основное  свойство  DFS-дерева,  выражаемое  теоремой 
2.2,  рассмотрим  задачу  выявления  шарниров  в  графе.  Напомним,  что 
шарниром  называется  вершина,  при  удалении  которой  увеличивается 
число компонент связности. Для простоты будем сейчас считать, что рас-
сматриваемый граф связен, так что шарнир – это вершина, при удалении 
которой нарушается связность.  

x := F(x)  

Отсутствие  поперечных  ребер  относительно  DFS-дерева  позволяет 
очень просто узнать, является ли стартовая вершина a (корень этого дере-
ва) шарниром. 

Лемма 2.3. Стартовая вершина а является шарниром графа тогда и 

только тогда, когда ее степень в DFS-дереве больше 1. 

Доказательство. Если вершину a удалить из дерева, то оно распадет-
ся на поддеревья, называемые ветвями. Число ветвей равно степени вер-
шины a в дереве. Так как поперечных ребер нет, то вершины из разных 
ветвей не могут быть смежными в графе, и каждый путь из одной ветви в 
другую обязательно проходит через вершину a. Следовательно, если сте-
пень вершины a в DFS-дереве больше 1, то эта вершина – шарнир. Если 
же степень вершины a в DFS-дереве равна 1, то в дереве имеется единст-
венная вершина b, смежная с a, и каждая из остальных вершин графа со-
единена  с  вершиной  b  путем,  не  проходящим  через  a.  Поэтому  в  этом 
случае удаление вершины a не нарушает связности графа и эта вершина 
не является шарниром (cid:0). 

Это свойство корня DFS-дерева можно было бы использовать для вы-
явления всех шарниров, просто выполнив n раз поиск в глубину, стартуя 
поочередно в каждой вершине. Оказывается, все шарниры можно выявить 
однократным поиском в глубину. Следующая теорема характеризует все 
шарниры, отличные от корня DFS-дерева. Напомним, что каждая вершина 
дерева  является  и  предком  и  потомком  самой  себя.  Предок  (потомок) 

 

53

вершины,  отличный  от  самой  этой  вершины,  называется  собственным 
предком (потомком). 

Лемма 2.4. Пусть Т – DFS-дерево графа G с корнем a. Вершина x ≠ a 
является шарниром графа тогда и только тогда, когда у нее в дереве Т 
имеется такой сын y, что ни один потомок вершины y не соединен реб-
ром ни с одним собственным предком вершины x.  

Доказательство. Если y – сын вершины x и ни один потомок верши-
ны y не соединен ребром ни с одним собственным предком вершины x, то, 
ввиду отсутствия поперечных ребер, любой путь, соединяющий вершину 
y с корнем, проходит через x. Следовательно, в этом случае вершина x – 
шарнир.  Если  же  для  каждого  сына  y  вершины  x  имеется  ребро,  соеди-
няющее вершину y с каким-либо собственным предком вершины x, то ка-
ждый  сын  вершины  x  соединен  с  корнем  дерева  путем,  не  проходящим 
через x. Поэтому при удалении вершины x граф останется связным и x в 
этом случае не является шарниром (cid:0). 

Для  применения  этого  критерия  к  отысканию  шарниров  введем  на 
множестве вершин функцию Low, связанную с DFS-деревом: значением 
Low(x) является наименьший из глубинных номеров вершин, смежных с 
потомками  вершины  х.  Если  вершина  y  является  сыном  вершины  x,  то 
Low(y)  ≤  Dnum(x)  (так  как  вершина  y  является  потомком  самой  себя  и 
смежна с вершиной x). Из теоремы 2.3 следует, что вершина x, отличная 
от a, является шарниром тогда и только тогда, когда у нее имеется сын y 
такой, что Low(y) = Dnum(x). 

Функцию Low можно определить рекурсивно – если мы знаем ее зна-
чения  для  всех  сыновей  вершины  x  и  глубинные  номера  всех  вершин, 
смежных с x и не являющихся ее сыновьями, то Low(x) есть минимум из 
всех этих величин, то есть  
⎛
min
⎜
⎝

Dnum

Low

x
)(

min
By
∈

Low
(

y

),

min
Ay
∈

 где  A  обозначает  множество  всех  сыновей  вершины x,  а B  –  множество 
всех остальных вершин, смежных с x. Нетрудно видеть, что это определе-
ние  эквивалентно  первоначальному.  Исходя  из  него,  можно  вычислять 
значения функции Low в процессе поиска в глубину с помощью следую-
щей  рекурсивной  процедуры.  Предполагается,  что  вначале всем элемен-
там массива Dnum присвоены нулевые значения. 

y
)(

, 

⎞
⎟
⎠

 

 

54

 

=

Procedure ComputeLow(x) 
1  с := с + 1 
2  Dnum(x) := c 

3  Low(x) := c  
4 
5 
6 
7 
8 

for y ∈ V(x) do 
 
 
 
 

if  Dnum(y) = 0 
 
 
else Low(x) := min(Low(x), Dnum(y)) 

then ComputeLow(y) 
 

Low(x) := min(Low(x), Low(y)) 

2.3. Блоки 

Если граф состоит из нескольких компонент связности, то его можно 
изучать «по частям», и это может упростить описание графа и облегчить 
решение многих задач. Однако и связный граф иногда можно представить 
как состоящий из частей и такое представление также может быть полез-
ным.  После  компонент  связности  простейшими  частями  такого  рода  яв-
ляются блоки (называемые также компонентами двусвязности). Блок – это 
максимальный  подграф  графа,  не  имеющий  собственных  шарниров  (то 
есть некоторые шарниры графа могут принадлежать блоку, но своих шар-
ниров у блока нет). На рис. 2.4 изображены граф G и его блоки B1 – B5. 
Ниже  будет  дано  другое  определение  блока,  из  которого  видно,  почему 
блоки называют компонентами двусвязности. Затем в этом разделе будут 
рассмотрены  некоторые  свойства  блоков  и  описан  алгоритм  выявления 
блоков, основанный на поиске в глубину. 
 
 
 
 
 
 
 
 
 
 
 

11 
G                                              B4                             B5

B1                   B2               B3

12 

10 

12 

11

1

 

2

5

3

6

3

6

1

4

7

  

4

7

11

2

5

8

8

9

5

9

9

5

 

 

 

10

Рис. 2.4 

 

2.3.1. Двусвязность 
Связный граф с не менее чем тремя вершинами, в котором нет шарни-
ров,  называется  двусвязным.  Примеры  двусвязных  графов  –  цикл  Cn  и 
полный граф Kn, n ≥ 3, цепь же Pn не является двусвязным графом ни при 
каком n.  

 

55

Будем  говорить,  что  два  элемента  графа  (напомним,  что  элементы 
графа – это вершины и ребра) циклически связаны, если в графе имеется 
простой цикл, содержащий оба эти элемента.  

Теорема 2.5. В двусвязном графе любые два различных элемента цик-
лически связаны. Если в графе любые два ребра циклически связаны, то он 
двусвязен.  

Доказательство.  Докажем  сначала,  что  в  двусвязном  графе  G  для 
любых двух различных вершин a и b имеется простой цикл, проходящий 
через обе эти вершины. Доказательство проводим индукцией по расстоя-
нию между a и b. Если d(a, b) = 1, то a и b смежны. Ребро (a, b) не явля-
ется перешейком (иначе хотя бы одна из вершин a, b была бы шарниром). 
Но тогда из леммы 1.6 следует, что в графе имеется простой цикл, прохо-
дящий через это ребро. Пусть d(a, b) > 1. Рассмотрим кратчайший путь из 
a  в  b  и  пусть  x  –  предпоследняя  вершина  этого  пути.  Тогда  d(a,  x)  = 
= d(a, b) – 1 и, по предположению индукции, существует простой цикл C, 
содержащий вершины a и x. Так как вершина x – не шарнир, то существу-
ет простой путь P из b в a, не проходящий через x. Пусть y – первая вер-
шина этого пути, принадлежащая C (такая существует, так как a ∈ С). То-
гда отрезок пути P от b до y вместе с отрезком цикла от y до x, содержа-
щим вершину a, и с ребром (x, b) образует простой цикл, содержащий обе 
вершины a и b (показан стрелками на рис. 2.5). 
 
 
 
 
 
 
 

a 

C

y

x

b

P

 

 

56

 

Рис. 2.5 

Теперь покажем, что для любой вершины a и любого ребра (x, y) дву-
связного  графа  G  в  нем  имеется  цикл,  содержащий  эту  вершину  и  это 
ребро.  Как  доказано  выше,  существует  простой  цикл  C1,  содержащий 
вершины a и x. Если этот цикл проходит и через y, то, заменив в нем отре-
зок от x до y, не содержащий a, ребром (x, y), получим простой цикл, про-
ходящий  через  вершину  a  и  ребро  (x,  y).  В  противном  случае  возьмем 
цикл  C2,  содержащий  вершины  a  и  y.  Кратчайший  отрезок  этого  цикла, 
соединяющий y с какой-либо вершиной z на C1, вместе с отрезком цикла 
C1 от z до x, содержащим вершину a, и с ребром (x, y) образует простой 

цикл, содержащий это ребро и вершину a. 

Доказательство того, что в двусвязном графе через любые два ребра 
проходит простой цикл, почти в точности повторяет предыдущее, только 
вместо вершины a нужно рассматривать ребро (a, b). 

Остается  доказать,  что  если  в  графе  G  через  любые  два  различных 
элемента  проходит  простой  цикл,  то  этот  граф  –  двусвязный.  Действи-
тельно, допустим, что вершина a – шарнир графа G. Возьмем вершины x и 
y, смежные с a и принадлежащие разным компонентам связности графа, 
получающегося при удалении вершины a. Тогда в G не существует цикла, 
содержащего оба ребра (a, x) и (a, y) (cid:0). 

Из этой теоремы следует, что свойство двусвязности можно охаракте-

ризовать следующим образом. 

Следствие.  Граф  с  не  менее  чем  двумя  ребрами  двусвязен  тогда  и 
только тогда, когда в нем любые два различных ребра циклически связа-
ны. 

Рассмотрим подробнее отношение циклической связности ребер. Оно, 
очевидно, симметрично. Будем считать, что каждое ребро циклически свя-
зано  с  самим  собой,  тогда  это  отношение  будет  и  рефлексивным.  Дока-
жем, что оно на самом деле является отношением эквивалентности. 

Теорема 2.6. Для любого графа отношение циклической связанности 

ребер является отношением эквивалентности. 

Доказательство. Остается доказать транзитивность этого отношения. 
Пусть C1 – простой цикл, содержащий ребра e1 и e2, а C2 – простой цикл, 
содержащий ребра e2 и e3; покажем, что существует простой цикл, содер-
жащий  ребра  e1  и  e3.  Если e1  принадлежит C2,  то  последний  и  является 
этим  циклом.  Если  же  e1  не  принадлежит  C2,  то  в  C1  есть  отрезок  P1, 
включающий e1, у которого концевые вершины a и b принадлежат C2, а 
все внутренние вершины не принадлежат C2. Пусть P2 – отрезок цикла C2, 
концами которого являются a и b и который включает ребро e3. Соедине-
ние P1 и P2 дает простой цикл, содержащий e1 и e3 (cid:0). 

Итак,  множество  ребер  любого  графа  разбивается  на  классы  эквива-
лентности  по  отношению  циклической  связанности.  Каждый  перешеек 
образует отдельный класс эквивалентности. Если граф двусвязен, то име-
ется единственный класс циклической связанности. 

 

 

2.3.2. Блоки и BC-деревья 
Блоком графа G называется подграф B, удовлетворяющий одному из 

трех условий: 

а) B  состоит  из  одной  изолированной  вершины  графа G (такой блок 

 

57

называется тривиальным); 

ком в G; 

б)  B  порождается  единственным  ребром,  которое  является  перешей-

в) B является максимальным двусвязным подграфом графа G . 
Из  последних  двух  теорем  следует,  что  ребра  нетривиального  блока 
образуют класс циклической связанности. Следовательно, различные бло-
ки  не  имеют  общих  ребер.  Однако,  в  отличие  от  компонент  связности, 
блоки могут иметь общие вершины. Таким общими вершинами, как пока-
зывает следующая теорема, могут быть только шарниры графа.  

Теорема 2.7. Два различных блока одного графа могут иметь не более 
одной  общей  вершины.  Вершина  принадлежит  более  чем  одному  блоку 
тогда и только тогда, когда она является шарниром графа.  

Доказательство. Пусть B1 и B2 – различные блоки графа G. Рассмот-
рим подграф B = B1 ∪ B2. Он не является блоком, следовательно, или не-
связен, или имеет шарнир. Если B несвязен, то B1 и B2 – его компоненты 
связности и, следовательно, не имеют общих вершин. Если же B связен и 
a – шарнир в B, то после удаления вершины a граф B распадается на ком-
поненты связности. При этом все вершины подграфа B1, отличные от a, 
принадлежат одной компоненте, иначе a была бы шарниром в B1. То же 
верно  для  вершин  подграфа  B2.  Значит,  имеется  всего  две  компоненты, 
одна из которых состоит полностью из вершин графа B1, другая – из вер-
шин графа B2. Следовательно, a – единственная общая вершина B1 и B2. 

Если вершина x принадлежит более чем одному блоку, то она инци-
дентна двум ребрам, (x, y1) и (x, y2), принадлежащим разным блокам, то 
есть  не  являющимся  циклически  связанными. Но тогда всякий путь, со-
единяющий  y1  и  y2,  проходит  через  x,  следовательно,  по  лемме  1.5,  x  – 
шарнир. Обратно, если x – шарнир, то найдутся две смежные с x вершины 
y1 и y1, принадлежащие разным компонентам связности графа, получаемо-
го удалением вершины x. Но тогда ребра (x, y1) и (x, y2) не являются цик-
лически связанными, следовательно, принадлежат разным блокам (cid:0). 

Строение  связного  графа,  состоящего  из  нескольких  блоков,  может 
быть схематически описано с помощью так называемого дерева блоков и 
шарниров,  кратко  именуемого  ВС-деревом.  В  этом  дереве  имеются  две 
категории вершин – одни поставлены в соответствие блокам графа, дру-
гие – его шарнирам. Вершина-блок в дереве соединяется ребром с верши-
ной-шарниром, если в графе соответствующий шарнир принадлежит со-
ответствующему  блоку.  На  рис.  2.6  изображено  ВС-дерево  для  графа  с 
рис. 2.4. Блоки изображены белыми, а шарниры черными кружками. 
 

58

 

 
 
 
 
 
 
 

 

 

B1

5 

B2

B3

B4

B5

9

11

Рис. 2.6 

2.3.3. Выявление блоков  
Рассмотрим связный граф G и в нем DFS-дерево T, построенное поис-
ком в глубину из стартовой вершины a. Через F(x) будем обозначать отца 
вершины  x  в  этом  дереве,  при этом считаем, что F(a) = a. Будем также 
считать,  что  в  процессе  обхода  графа  вычисляются  значения  функций 
Dnum и Low, определенных в предыдущем разделе. 

Пусть В – блок графа, а x – вершина этого блока с наименьшим значе-
нием Dnum(x). Иначе говоря, x – вершина блока, посещаемая при обходе 
первой. Среди сыновей вершины x имеется единственная вершина y, при-
надлежащая блоку В. Вершину x будем называть начальной вершиной, а 
ребро (x, y) – начальным ребром блока В. 

Лемма 2.8. Пусть x = F(y) в DFS-дереве Т. Ребро (x, y) является на-
чальным ребром некоторого блока тогда и только тогда, когда Low(y) = 
= Dnum(x). 

Доказательство. Если x = a, то для каждого сына y вершины x имеет 
место равенство Low(y) = Dnum(x) и ребро (x, y) является начальным реб-
ром некоторого блока. 

Пусть  x  ≠  a  и  (x,  y)  –  начальное  ребро  блока  B.  Предположим,  что 
Low(y) ≠ Dnum(x). Это означает, что имеется ребро, соединяющее неко-
торого потомка вершины y с собственным предком вершины x. Но тогда 
ребра  (x,  y)  и  (x,  F(x))  оказываются  циклически  связанными,  а  отсюда 
следует, что вершина F(x) принадлежит блоку В. Это противоречит тому, 
что x – начальная вершина блока, так как Dnum (F(x) < Dnum(x). 

Обратно, пусть Low(y) = Dnum(x). Тогда вершина x является шарни-
ром графа. Рассмотрим поддерево, состоящее из всех потомков вершины 
y. Ни одна из вершин этого поддерева не смежна ни с одной отличной от x 
вершиной вне поддерева. Значит, все вершины блока, содержащего ребро 
(x, y), принадлежат этому поддереву, и (x, y) – начальное ребро этого бло-
ка. 

В основе описываемого ниже алгоритма выявления блоков лежит ре-

 

59

курсивная процедура вычисления функции Low из предыдущего раздела. 
Напомним, что Low(x) есть наименьший из глубинных номеров вершин, 
смежных с потомками вершины х. Переменная k – счетчик блоков, B(k) –
множество вершин блока с номером k. В стеке S накапливаются вершины 
графа,  впервые  встречающиеся  в  процессе  обхода  (то  есть  превращаю-
щиеся из новых в открытые).  

Множества вершин блоков строит процедура NewBlock. Она вызыва-
ется всякий раз, когда обнаруживается начальное ребро (x, y) некоторого 
блока (выполняется равенство Low(y) = Dnum(x). Эта процедура включа-
ет в новое множество B(k) вершины x, y и все вершины, находящиеся в 
стеке выше вершины y. Эти вершины удаляются из стека (кроме вершины 
x,  которая  является  начальной  вершиной  блока  и  может  принадлежать 
еще и другим блокам). Для обоснования алгоритма остается убедиться в 
том,  что  блок  состоит  именно  из  этих  вершин.  Доказательство  можно 
провести индукцией по номеру блока k. Вершина y помещается в стек S, 
когда она становится открытой, а условие Low(y) = Dnum(x) проверяется 
для вершины y тогда, когда она превращается в закрытую. Все вершины, 
помещаемые  в  стек  между  этими  двумя  событиями,  будут  потомками 
вершины y в DFS-дереве, каждый потомок вершины у будет помещен в 
стек после y, и когда y становится закрытой, все эти вершины уже закры-
ты. Если k = 1, то среди потомков вершины y нет начальных вершин бло-
ков  (иначе  номер  этого  блока  был  бы  больше  1),  следовательно,  блок  c 
начальным ребром (x, y) состоит из всех этих вершин и вершины x. Если 
же k > 1, то, по предположению индукции, все вершины других блоков, 
состоящих из потомков вершины y, не принадлежащие блоку B(k), к мо-
менту обнаружения начального ребра (x, y) уже удалены из стека, следо-
вательно, B(k) состоит в точности из x, y и вершин, находящиеся в стеке 
выше вершины y.  

 

 

for x ∈ V  do if Dnum(x) = 0 then Blocks(x)  

for x ∈ V do Dnum(x) := 0 

Алгоритм 4. Выявление блоков  
1 
2  с := 0 
3  k := 0 
4 
Procedure Blocks(x) 
5  с := с + 1 
6  Dnum(x) := с 
7  Low(x) := c  
8  x ⇒ S 

60

 

if Dnum(y) = 0 
 
 
 
else Low(x) := min(Low (x), Dnum(y)) 

then Blocks(y) 
 
 

Low(x) := min(Low (x), Low(y)) 
 

if Low(y) = Dnum(x) then NewBlock 

for y ∈ V (x) do 

9 
10   
11   
12   
13   
14   
Procedure NewBlock 
1  k := k + 1 
2  B(k) := x 
3  repeat 
4 
5 
5  until z = y 

 
 

z ⇐ S 
B(k) := B(k) ∪ {z} 

2.4. База циклов 

2.4.1. Пространство подграфов  
Зафиксируем  некоторое  множество  V  и  рассмотрим  множество  ΓV 
всех графов с множеством вершин V. Буквой O будем обозначать пустой 
граф из этого множества: O = (V, ∅).  

Для графов G1 = (V, E1) и G2 = (V, E2) из ΓV определим их сумму по 
модулю  2  (в  дальнейшем  в  этом  разделе  будем  называть  ее  просто  сум-
мой) как граф G1 ⊕ G2 = (V, E1 ⊕ E2), где E1 ⊕ E2 обозначает симметри-
ческую  разность  множеств  E1  и  E2.  Иначе  говоря,  ребро  принадлежит 
графу G1 ⊕ G2 тогда и только тогда, когда оно принадлежит в точности 
одному из графов G1 и G2. Пример показан на рис. 2.7. 
 
 
 
 
 
 
 
 

⊕

=

6

6

3

5

3

5

2

4

2

4

1

3

2

4

1

1

5
6
Рис. 2.7 

 

 

 

 

 

 

Следующие свойства введенной операции очевидны или легко прове-

ряются. 

1) Коммутативность: G1 ⊕ G2 = G2 ⊕ G1 для любых G1 и G2. 

 

61

2) Ассоциативность: G1 ⊕ (G2 ⊕ G3) = (G1 ⊕ G2) ⊕ G3  для любых G1, 

G2, G3. 

G

Gk

3) G ⊕ O = G для любого G. 
4) G ⊕ G = O для любого G. 
Отсюда следует, что множество ГV относительно операции ⊕ образует 
абелеву группу. Нейтральным элементом («нулем») этой группы служит 
граф  O,  а  противоположным  к  каждому  графу  является  сам  этот  граф. 
Уравнение G ⊕ X = H с неизвестным X и заданными графами G и H имеет 
единственное решение X = G ⊕ H. Благодаря свойству ассоциативности 
мы можем образовывать выражения вида  G
, не используя 
1
скобок для указания порядка действий. Легко понять, что ребро принад-
лежит графу G1 ⊕ G2 ⊕ … ⊕ Gk тогда и только тогда, когда оно принад-
лежит нечетному количеству из графов G1, G2, …, Gk. 

2⊕ ⊕ ⊕…

Рассмотрим множество из двух элементов {0, 1}. Оно является полем 
относительно операций умножения и сложения по модулю 2. Определим 
операцию умножения элементов этого поля на графы: 0 ⋅ G = O, 1 ⋅ G = G 
для любого графа G. Множество ГV  с введенными операциями сложения 
графов  и  умножения  на  элементы  поля  является  линейным  векторным 
пространством. 

Зафиксируем  некоторый  граф G  ∈  ΓV и рассмотрим множество всех 
его остовных подграфов, которое будем обозначать S [G]. Это множество 
состоит из 2m(G) элементов, среди них сам граф G и граф O. Оно замкнуто 
относительно сложения графов и умножения на элементы поля, следова-
тельно,  является  подпространством  пространства  ΓV.  Его  называют  про-
странством подграфов графа G. 

Любой  граф  из  S  [G]  может  быть  выражен  как  сумма  однореберных 
подграфов.  Всего  у  графа  G  имеется  m(G)  однореберных  подграфов  и 
они,  очевидно,  линейно  независимы.  Следовательно,  однореберные  под-
графы  образуют базис пространства S [G], а размерность этого простран-
ства равна m(G). 

В пространстве S [G] можно очень естественным способом ввести ко-
ординаты.  Занумеруем ребра графа G: EG = {e1, e2, …, em}. Теперь ос-
товному подграфу H можно поставить в соответствие характеристический 
вектор α(H) = { α1, α2, …, αm} его множества ребер: 
H
,
т
принадлежи

т
принадлежи
не

ребро
ребро

если
если

=α

H

.

e
i
e
i

i

,1
⎧
⎨
,0
⎩

 

 

62

 

 

 

 

Получаем взаимно однозначное соответствие между множеством S [G] 
и множеством всех  двоичных векторов с m координатами. Сумме графов 
соответствует векторная (покоординатная) сумма по модулю 2 их харак-
теристических векторов. 
2.4.2. Квазициклы  
В этом разделе слово «цикл» будем понимать несколько иначе, чем до 
сих  пор.  Именно,  циклом  будем  называть  граф,  у  которого  одна  компо-
нента связности является простым циклом, а остальные – изолированны-
ми вершинами. Рис. 2.7 показывает, что в результате сложения двух цик-
лов иногда получается цикл. Это не всегда так (например, когда склады-
ваемые циклы не имеют общих ребер), но все-таки графы, которые можно 
получить, складывая циклы, обладают определенными особенностями. На 
этом  основан  алгебраический  подход  к  изучению  устройства  множества 
циклов графа. 

Рассмотрим некоторый граф G ∈ ΓV. Среди его остовных подграфов, 
возможно, имеется некоторое количество циклов. Обозначим через C[G] 
подпространство  пространства  подграфов,  порождаемое  всеми  этими 
циклами. C[G] называется пространством циклов графа G. Оно содержит 
граф O (если в G нет циклов, то O является единственным элементом про-
странства циклов), а все остальные его элементы – это всевозможные ли-
нейные комбинации циклов графа G. Заметим, что коэффициентами в ли-
нейных комбинациях являются элементы множества {0, 1}, поэтому речь 
идет на самом деле просто о всевозможных суммах циклов. 

Остовный подграф, у  которого степени всех вершин четны, называет-
ся квазициклом. Оказывается, множество C[G] состоит в точности из всех 
квазициклов  графа  G.  Прежде  чем  доказать  это,  покажем  сначала,  что 
множество всех квазициклов замкнуто относительно сложения. 

Лемма 2.9. Сумма двух квазициклов есть квазицикл. 
Доказательство.  Пусть  H1  и  H2  –  квазициклы.  Рассмотрим  произ-
вольную вершину a ∈ V и пусть ее степени в H1 и H2 равны соответствен-
но d1 и d2. Тогда степень вершины a в графе H1 ⊕ H2 будет равна d = d1 + 
+ d2 – 2d1,2, где d1,2 – число вершин, с которыми a смежна в обоих графах 
H1 и H2. Отсюда видно, что число d четно, если четны оба числа d1 и d2 (cid:0). 

Следующая лемма объясняет строение квазициклов. 
Лемма 2.10. Любой квазицикл с непустым множеством ребер являет-

ся объединением простых циклов, не имеющих общих ребер. 

Доказательство. В квазицикле H в любой компоненте связности, со-
стоящей не менее чем из двух вершин, степени всех вершин не меньше 2, 

 

63

и, по лемме 1.4, в нем есть цикл, а, значит, и простой цикл. Взяв какой-
нибудь простой цикл в H и удалив его ребра из H, снова получим квази-
цикл.  Если  в  этом  новом  квазицикле  есть  хотя  бы  одно  ребро,  то  в нем 
также имеется простой цикл, и т.д. В конце концов, когда останется пус-
той граф, будет построено семейство простых циклов, не имеющих общих 
ребер и в совокупности содержащих все ребра графа H (cid:0). 

Теорема 2.11. Граф принадлежит множеству C[G] тогда и только 

тогда, когда он является квазициклом графа G. 

Доказательство. Всякий цикл является квазициклом. Так как элемен-
ты C[G] – это суммы циклов, то, по лемме 2.9, все они – квазициклы. Об-
ратное  утверждение  (каждый  квазицикл  принадлежит  C[G])  следует  из 
леммы 2.10, так как объединение циклов, не имеющих общих ребер, сов-
падает с их суммой (cid:0). 

 

 

2.4.3. Фундаментальные циклы  
Компактное  представление  пространства  дает  его  базис.  Если  выпи-
сать все простые циклы графа G, то это в большинстве случаев не будет 
его базисом, так как некоторые из этих циклов могут быть суммами дру-
гих (см. пример на рис. 2.7). Построить базис пространства C[G], состоя-
щий из простых циклов, можно следующим образом. Выберем в графе G 
какой-нибудь каркас T. Пусть e1, …, eS – все ребра графа G, не принадле-
жащие T. Если добавить к T ребро ei, то в полученном графе образуется 
единственный (простой) цикл Zi. Таким образом, получаем семейство из s 
циклов,  они  называются  фундаментальными циклами относительно кар-
каса T.  

Теорема  2.12.  Множество  всех  фундаментальных  циклов  относи-
тельно любого каркаса T графа G образует базис пространства циклов 
этого графа. 

Доказательство.  Зафиксируем  некоторый  каркас  T  и  рассмотрим 
фундаментальные циклы Z1, Z2, …, ZS относительно этого каркаса. В каж-
дом  из  этих  циклов  имеется  ребро  ei,  принадлежащее  этому  циклу  и  не 
принадлежащее  никакому  из  остальных.  Поэтому  при  сложении  этого 
цикла с другими фундаментальными циклами это ребро не «уничтожит-
ся» – оно будет присутствовать в суммарном графе. Следовательно, сумма  
различных фундаментальных циклов никогда не будет пустым графом, то 
есть фундаментальные циклы линейно независимы.  

Покажем теперь, что любой квазицикл графа G является суммой фун-
даментальных циклов. Действительно, пусть H – такой квазицикл. Пусть 
ee …,
  –  все  ребра  H,  не  принадлежащие  T.  Рассмотрим  граф 
i
1

e
ti

,

i
2

64

 

Z

i
1

,

j

Z

ti

…=

,1

…2
⊕⊕
i

⊕⊕=

. Каждое из ребер 
.jiZ

e ji
ZHF
 входит ров-
но в два слагаемых этой суммы – в H и в 
 Следовательно, при сложе-
нии все эти ребра уничтожатся. Все остальные ребра, присутствующие в 
графах-слагаемых, принадлежат T. Значит, F – подграф графа T. Так как 
все слагаемые являются квазициклами, значит, F – тоже квазицикл. Но в T 
нет  циклов,  поэтому  имеется  единственная  возможность:  F  =  O,  откуда 
получаем 

⊕⊕⊕=

ZH

(cid:0). 

Z

…2
i

Z

ti

,

s

,

i
1

Из этой теоремы следует, что размерность пространства циклов графа 

равна  числу  ребер,  не  входящих  в  его  каркас.  Так  как  каркас  содержит         
n – k ребер, где k – число компонент связности графа, то эта размерность 
равна  v(G)  =  m  –  n  +  k.  Это  число  называют  цикломатическим  числом 
графа.  

 

 

2.4.4. Построение базы циклов  
Базис пространства циклов графа коротко называют базой циклов. На 
основании  теоремы  2.12  можно  предложить  достаточно  простой  способ 
построения базы циклов графа. Сначала находится какой-нибудь каркас, 
затем для каждого ребра, не принадлежащего каркасу, отыскивается тот 
единственный цикл, который это ребро образует с ребрами каркаса. Таким 
образом,  любой  алгоритм  построения  каркаса  может  быть  использован 
для нахождения базы циклов.  

Поиск  в  глубину  особенно  удобен  благодаря  основному  свойству 
DFS-дерева  (теорема  2.2)    –  каждое  обратное  ребро  относительно  этого 
дерева  является  продольным.  Это  означает,  что  из  двух  вершин  такого 
ребра одна является предком другой в DFS-дереве. Каждое такое ребро в 
процессе поиска в глубину встретится дважды – один раз, когда активной 
вершиной будет предок, другой раз, когда ею будет потомок. В этом по-
следнем  случае  искомый  фундаментальный  цикл  состоит  из  рассматри-
ваемого обратного ребра и участка пути в DFS-дереве, соединяющего эти 
две вершины. Но этот путь так или иначе запоминается в процессе обхода 
в глубину, так как он необходим для последующего возвращения. Если, 
например, для хранения открытых вершин используется стек, то вершины 
этого  пути  находятся  в  верхней  части  стека.  В  любом  случае  этот  путь 
легко доступен и цикл находится без труда. Запишем процедуру построе-
ния фундаментальных циклов на базе алгоритма поиска в глубину с по-
строением DFS-дерева (алгоритм 3). Переменная k – счетчик циклов, C(k) 
– последовательность (список) вершин, составляющих цикл с номером k. 

 

 

65

 

Vx ∈

for  x ∈ V

if  имеется неисследованное ребро  (x, y) 
 
 
 
 
 
 
 
 

 if   вершина  y  новая 
 
 
 
 

F(y) := x 
x := y 

if  x  новая   then  CycleBase(x) 

then  открыть вершину  y 
 
 
else  NewCycle 

then  пометить ребро  (x, y)  как исследованное 
 
 
 
 
 
else  закрыть вершину  x  
         x := F(x)  

Алгоритм 5. Построение базы циклов  
1  пометить все вершины как новые 
2  k := 1 
  do 
3 
Procedure CycleBase(a) 
1  открыть вершину  a 
2  F(a) := a 
3  x := a 
4  while  x  открытая  do 
 
5 
 
6 
 
7 
 
8 
9 
 
10   
11   
12   
13   
Procedure  NewCycle 
1  k := k + 1 
2  Создать список  C(k)  из одного элемента  x 
3  z := x 
4  repeat  z := F(z)  
5 
6  until  z = y 
Хотя сам поиск в глубину выполняется за линейное от числа вершин и 
ребер время, решающее влияние на трудоемкость этого алгоритма оказы-
вает необходимость запоминать встречающиеся циклы. Подсчитаем сум-
марную длину этих циклов для полного графа с n вершинами. DFS-дерево 
в  этом  случае  является  простым  путем,  относительно  него  будет  n  –  2 
цикла длины 3, n – 3 цикла длины 4, ..., 1 цикл длины n. Сумма длин всех 
фундаментальных циклов будет равна 
n

добавить  z  к списку  C(k)  

8

n

−

+

 

2

3

n

−

2

∑

1
=

i

ni
(

1
=−+

)

i

n
3
6

. 

 

 

 

 

66

 

Таким образом, на некоторых графах число операций этого алгоритма 

будет величиной порядка n3. 

2.4.5. Рационализация  
Приведенный  алгоритм  нетрудно  модифицировать  так,  что  он  будет 
строить  базу  циклов  с  суммарной  длиной, ограниченной сверху величи-
ной порядка n2 (и такой же будет оценка трудоемкости алгоритма). Рас-
смотрим в графе произвольную вершину х и пусть y1, y2, …, yk – все ее 
предки  в  DFS-дереве,  соединенные  с  х  обратными  ребрами.  Положим 
также  yk+1  =  x.  Обозначим  через  Pi  для  i  =  1,  …,  k  путь  в  DFS-дереве,    
соединяющий  yi  и  yi+1.  Описанный  выше  алгоритм  выдает  циклы  вида         
, i = 1, …, k.  
Ci = aPiPi+1…Pka, i = 1, …, k,. Рассмотрим циклы 
Так как 
, то совокупность всех таких циклов так-
же  образует  базу  циклов  графа.  Назовем  эту  систему  циклов  сокращен-
ной. Алгоритм легко модифицировать так, чтобы вместо циклов Ci выда-
вались  циклы 
  –  нужно  только  после  обнаружения  обратного  ребра, 
ведущего от предка х к потомку y (строка 14) выписать вершины, содер-
жащиеся в стеке, начиная с y и заканчивая следующей вершиной, смеж-
ной с х. Для эффективной проверки этой смежности удобно использовать 
матрицу смежности. 

C
′⊕⊕′⊕′=
k

+ …1

C
i =′

aaP
i

CC

i

i

iC′

C

i

 

 

Оценим  суммарную  длину  S  циклов  сокращенной  системы.  Предпо-
ложим, что граф имеет n вершин и m ребер. Каждое обратное ребро при-
надлежит не более чем двум циклам сокращенной системы. Значит, сум-
марный вклад обратных ребер в S не превосходит 2m.  

Для каждого цикла из сокращенной системы назовем верхушкой этого 
цикла вершину цикла с наибольшим глубинным номером (это та вершина  
х, при исследовании окрестности которой был найден этот цикл). Очевид-
но, для каждого прямого ребра в сокращенной системе имеется не более 
одного цикла с данной верхушкой. Значит, число циклов, в которые вхо-
дит данное прямое ребро, не превосходит числа вершин, лежащих в дере-
ве выше этого ребра (то есть являющихся потомками вершин этого реб-
ра). Тем более это число не превосходит числа всех вершин графа. Так как 
имеется не более чем n – 1 прямое ребро, то для суммарного вклада всех 
прямых ребер в S получаем верхнюю оценку n2. Таким образом, S < 2m + 
+ n2 = O(n2), то есть на порядок меньше максимальной суммарной длины 
системы фундаментальных циклов. 
 

2.5. Эйлеровы циклы 

Напомним, что эйлеровым циклом называется замкнутый маршрут, в 
котором каждое ребро графа встречается точно один раз. Согласно теоре-
ме 1.11 для существования такого маршрута в связном графе необходимо 

 

67

и достаточно, чтобы степени всех вершин были четными. В этом разделе 
описывается алгоритм, который находит эйлеров цикл в заданном графе 
при условии, что это условия связности и четности степеней выполнены.  
Этот алгоритм похож на алгоритм поиска в глубину: начиная с произ-
вольно  выбранной  стартовой  вершины  a,  строим  путь,  выбирая  каждый 
раз для дальнейшего продвижения еще не пройденное ребро. Главное от-
личие от поиска в глубину состоит в том, что как пройденные помечаются 
именно ребра, а не вершины. Поэтому одна и та же вершина может посе-
щаться несколько раз, но каждое ребро проходится не более одного раза, 
так  что  в  полученном  маршруте  ребра  не  будут  повторяться.  Вершины 
пути  накапливаются  в  стеке  S.  Через  некоторое  количество  шагов  неиз-
бежно наступит тупик – все ребра, инцидентные активной (последней по-
сещенной) вершине x, уже пройдены. Так как степени всех вершин графа 
четны, то в этот момент x = a и пройденные ребра образуют цикл, но он 
может включать не все ребра графа. Для обнаружения еще не пройденных 
ребер возвращаемся по пройденному пути, перекладывая вершины из сте-
ка S в другой стек C, пока не встретим вершину x, которой инцидентно не 
пройденное  ребро.  Так  как  граф  связен,  то  такая  вершина  обязательно 
встретится. Тогда возобновляем движение вперед по не пройденным реб-
рам, пока не дойдем до нового тупика и т.д. Процесс заканчивается, когда 
в очередном тупике обнаруживается, что S пуст. В этот момент в стеке C 
находится последовательность вершин эйлерова цикла.  

 
 
 
 
 

x := top(S) 
if имеется не пройденное ребро (x, y)  
 
 
 

Алгоритм 6. Построение эйлерова цикла 
1  выбрать произвольно вершину  а 
2  a ⇒ S 
3  while S ≠ ∅ do  
4 
5 
6 
7 
8 
Для обоснования алгоритма заметим сначала, что первой в стек S по-
мещается вершина a, и она будет последней перемещена из S в C. Следо-
вательно, она будет последней вершиной в стеке С. Далее, как было отме-
чено выше, первый раз, когда обнаружится, что все инцидентные актив-
ной  вершине  ребра  пройдены  (то  есть  будет  выполняться  ветвь  else  в 
строке 8), активной будет стартовая вершина а. Значит, эта вершина будет 
первой перемещена из S в C. Итак, по окончании работы алгоритма в на-

then пометить ребро (x, y) как пройденное 
 
else переместить вершину x из S в C 

y ⇒ S 

 

 

 

68

 

чале и в конце последовательности вершин, содержащейся в стеке C, на-
ходится вершина a. Иначе говоря, если эта последовательность представ-
ляет маршрут (а далее будет показано, что это так и есть), то он замкнут. 

Далее отметим, что в конечном итоге каждое ребро будет пройдено. 
Действительно, допустим, что момент окончания работы алгоритма име-
ются еще не пройденные ребра. Так как граф связен, то должно существо-
вать хотя бы одно не пройденное ребро, инцидентное посещенной верши-
не.  Но  тогда  эта  вершина  не  могла  быть  удалена  из  стека S, и S не мог 
стать пустым.  

Будем говорить, что ребро (x, y) представлено в стеке (S или С), если в 
какой-то момент работы алгоритма в стеке рядом находятся вершины x и 
y. Ясно, что каждое ребро графа будет представлено в стеке S и что каж-
дые  две  вершины,  расположенные  рядом  в  этом  стеке,  образуют  ребро. 
Допустим, в какой-то момент из стека S в стек C перемещается вершина x, 
а непосредственно под ней в стеке S находится вершина y. Возможно, что 
вершина y будет перемещена из S в C при следующем повторении цикла 
while,  тогда  ребро  (x,  y)  будет  представлено  в  стеке  С.  Другая  возмож-
ность – между перемещением вершины x и следующим перемещением, то 
есть следующим выполнением ветви else будет несколько раз выполнена 
ветвь then (строки 6-7). Это означает, что будет пройдена некоторая по-
следовательность ребер, начинающаяся в вершине y. Ввиду четности сте-
пеней  эта  последовательность  может  закончиться  только  в  вершине  y. 
Значит, и в этом случае следующей за вершиной x будет перемещена из S 
в C вершина y. В любом случае ребро (x, y) будет представлено в стеке С. 
Из  этого  рассуждения  видно,  что  последовательность  вершин  в  стеке  C 
является  маршрутом,  и  что  каждое  ребро  графа  в  конечном итоге будет 
содержаться в этом маршруте, причем один раз.  

При каждом повторении цикла while в рассмотренном алгоритме либо 
проходится одно ребро, либо одна вершина перемещается из S в C. По-
следнее  можно  трактовать  как  прохождение  уже  пройденного  однажды 
ребра в обратном направлении. Каждое ребро в каждом направлении бу-
дет  пройдено  один  раз,  поэтому  общая  трудоемкость  этого  алгоритма 
оценивается  как O(m). Необходимо только оговориться, что этот вывод, 
как и аналогичные заключения об алгоритмах обхода в первых разделах 
этой главы, справедлив лишь при определенных предположениях о том, 
как задан граф. Способ задания должен обеспечить возможность быстрого 
просмотра множества ребер, инцидентных данной вершине. Подходящим 
является,  например,  задание  графа  списками  инцидентности,  в  которых 
для каждой вершины перечисляются инцидентные ей ребра. Необходимо 

 

69

также  иметь  возможность  быстро  пометить  ребро  как  пройденное  или 
проверить, пройдено ли данное ребро. Для этого подходящей структурой 
может служить характеристический массив на множестве ребер. 
 

2.6. Гамильтоновы циклы 

Гамильтоновым  циклом  (путем)  называют  простой  цикл  (путь),  со-
держащий все вершины графа. В графе, изображенном на рис. 2.8 слева, 
гамильтоновым циклом является, например, последовательность 1, 2, 3, 5, 
4, 1. В графе, изображенном в центре, нет гамильтоновых циклов, но есть 
гамильтоновы пути, например, 2, 1, 3, 5, 4. В правом графе нет и гамиль-
тоновых путей. 
 
 
 
 
 
 
 

5 

1 

2 

2 

2

5

1

4

1

4

4 

5 

3 

3

3

 

 

Рис. 2.8 

Внешне определение гамильтонова цикла похоже на определение эй-
лерова цикла. Однако имеется кардинальное различие в сложности реше-
ния соответствующих задач распознавания и построения. Мы видели, что 
имеется  достаточно  простой  критерий  существования  эйлерова  цикла  и 
эффективный алгоритм его построения. Для гамильтоновых же циклов (и 
путей)  не  известно  никаких  просто  проверяемых  необходимых  и  доста-
точных  условий  их  существования,  а  все  известные  алгоритмы  требуют 
для некоторых графов перебора большого числа вариантов.  

Гамильтонов цикл представляет собой, с комбинаторной точки зрения, 
просто перестановку вершин графа. При этом в качестве начальной вер-
шины цикла можно выбрать любую вершину, так что можно рассматри-
вать перестановки с фиксированным первым элементом. Самый бесхитро-
стный план поиска гамильтонова цикла состоит в последовательном рас-
смотрении всех этих перестановок и проверке для каждой из них, пред-
ставляет ли она цикл в данном графе. Такой способ действий уже при не 
очень  большом  числе  вершин  становится  практически  неосуществимым 
ввиду быстрого роста числа перестановок – имеется (n – 1)! перестановок 
из n элементов с фиксированным первым элементом.  

Более  рациональный  подход  состоит  в  рассмотрении  всевозможных 
простых путей, начинающихся в произвольно выбранной стартовой вер-
шине a до тех пор, пока не будет обнаружен гамильтонов цикл или все 

70

 

возможные  пути  не  будут  исследованы.  По  сути  дела,  речь  тоже идет о 
переборе  перестановок,  но  значительно  сокращенном  –  если,  например, 
вершина b не смежна с вершиной a, то все (n – 2)! перестановок, у кото-
рых на первом месте стоит a, а на втором b, не рассматриваются. 

Рассмотрим этот алгоритм подробнее. Будем считать, что граф задан 
окрестностями вершин: для каждой вершины x задано множество вершин, 
смежных с x. На каждом шаге алгоритма имеется уже построенный отре-
зок пути, он хранится в стеке PATH. Для каждой вершины x, входящей в 
PATH, хранится множество N(x) всех вершин, смежных с x, которые еще 
не рассматривались в качестве возможных продолжений пути из вершины 
x. Когда вершина x добавляется к пути, множество N(x) полагается рав-
ным  V(x).  В  дальнейшем  рассмотренные  вершины  удаляются  из  этого 
множества. Очередной шаг состоит в исследовании окрестности послед-
ней вершины x пути PATH. Если N(x) ≠ ∅ и в N(x) имеются вершины, не 
принадлежащие пути, то одна из таких вершин добавляется к пути. В про-
тивном случае вершина x исключается из стека. Когда после добавления к 
пути  очередной  вершины  оказывается,  что  путь  содержит  все  вершины 
графа, остается проверить, смежны ли первая и последняя вершины пути, 
и при утвердительном ответе выдать очередной гамильтонов цикл.  

 

 

 
 
 
 
 

x := top(PATH) 
 if N(x) ≠ ∅  
 
 
 

Алгоритм 7. Поиск гамильтоновых циклов 
1  выбрать произвольно вершину а 
2  a ⇒ PATH 
3  N(a) := V(a) 
4  while PATH ≠ ∅ do 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15   
Этот алгоритм очень похож на алгоритм поиска в глубину и отличает-
ся  от  него  по  существу  только  тем,  что  открытая  вершина,  когда  вся ее 
окрестность  исследована,  не  закрывается,  а  опять  становится  новой  (ис-

then  y ⇒ PATH  
N(y) := N(y) 
if PATH содержит все вершины  

 else удалить вершину x из PATH 

then взять y ∈ N(x) 
 
 

N(x) := N(x) – y 
 if вершина y не находится в PATH 

 

then  if x смежна с a  

then выдать цикл 

 

71

ключается из стека). В начале все вершины новые. Процесс заканчивает-
ся, когда все вершины опять станут новыми. На самом деле это и есть по-
иск в глубину, только не в самом графе, а в дереве путей. Вершинами это-
го дерева являются всевозможные простые пути, начинающиеся в верши-
не а, а ребро дерева соединяет два пути, один из которых получается из 
другого добавлением одной вершины в конце. На рис. 2.9 показаны граф и 
его дерево путей из вершины 1. 
 
 
 
 
 
 
 
 
 

1352 1354 1435

14352

13452

1253

1254

1452 

1453 

12534

12543

1

13

1345

134

135

143

1 

4 

2 

5 

12

14

125

145

3 

 

 

Рис. 2.9 

В худшем случае время работы этого алгоритма тоже растет с факто-
риальной скоростью. Например, для графа Kn–1 + K1 (граф с двумя компо-
нентами  связности,  одна  из  которых  –  полный  граф  с  n  –  1  вершиной, 
другая – изолированная вершина), если в качестве стартовой выбрана не 
изолированная вершина, то будут рассмотрены все (n – 1)! простых путей 
длины n – 2 в большой компоненте. Вместе с тем, если перед поиском га-
мильтонова цикла исходный граф проверить на связность, то ответ будет 
получен быстро. Можно пойти дальше и при обходе дерева путей пове-
рять  на  связность  каждый  встречающийся  «остаточный  граф»,  то  есть 
граф, получающийся из исходного удалением всех вершин рассматривае-
мого пути. Если этот граф не связен, то этот путь не может быть продол-
жен  до  гамильтонова  пути.  Поэтому  можно  не  исследовать  соответст-
вующую ветвь дерева, а вернуться к рассмотрению более короткого пути, 
удалив последнюю вершину (то есть сделать «шаг назад» в поиске в глу-
бину). Можно пойти еще дальше и заметить, что если некоторая вершина 
х DFS-дерева с корнем а является развилкой, то есть имеет не менее двух 
сыновей,  то  в  подграфе  исходного  графа,  полученном  удалением  всех 
предков этой вершины, кроме нее самой, она будет шарниром. Поэтому 
путь от а до х в DFS-дереве не может быть продолжен до гамильтонова 
пути. Эти соображения приводят к такой модификации алгоритма: обхо-
дим граф поиском в глубину с построением DFS-дерева, затем находим в 

72

 

этом  дереве  самую  нижнюю  развилку  (развилку  с  наименьшим  глубин-
ным  номером).  Если  ни  одной  развилки  нет,  то  само  DFS-дерево  пред-
ставляет собой гамильтонов путь и остается проверить наличие ребра, со-
единяющего начало и конец пути. Если же х – развилка, то возвращаемся 
из  х  в  предшествующую  вершину  пути,  помечаем  все  вершины,  кроме 
собственных предков вершины х, как не посещенные и возобновляем по-
иск в глубину с этого места.  

Рассмотрим другой алгоритм, выясняющий существование гамильто-
нова цикла, идейно близкий к поиску в ширину и имеющий не столь бы-
стро (хотя все же быстро) растущую оценку трудоемкости.  

Пусть граф G задан матрицей смежности A = || A(i, j)||. Выберем про-
извольно стартовую вершину а и определим для каждого k = 0, 1, …, n – 2 
функцию Hk(x, X), где значениями переменной x являются вершины, от-
личные от a, а значениями переменной Х – k-элементные подмножества 
множества VG – {a}, причем вершина x не должна принадлежать множе-
ству Х. Эти функции определяются так: полагаем Hk(x, X) = 1, если суще-
ствует простой путь длины k + 1 из вершины a в вершину х, проходящий 
только через вершины из множества Х, и Hk(x, X) = 0, если такого пути не 
существует. Тогда  

а для k > 0 

 

 

xH
,(0

=∅

)

xsA
),(

 для всех х, 

XxH

,(

k

)

=

∨

Xy
∈

H

k

1
−

xyAyXy
,(
),(

−

)

. 

 

 

 Таким образом, зная все значения функции Hk–1, мы можем вычислить все 
значения функции Hk, причем для вычисления одного значения требуется 
выполнить 2k – 1 логических операций. Общее время на вычисление всех 
этих  функций,  как  легко  подсчитать,  составит  O(n22n).  Остается  только 
для всех х, для которых Hn–2(x, X) = 1 (Х в этом случае определяется одно-
значно), выяснить, чему равно A(x, a) – если хотя бы в одном случае это 
равно  1,  то  гамильтонов  цикл  существует.  Очевидный  недостаток  этого 
алгоритма – необходимость хранения большого количества промежуточ-
ной информации. 
 

Задачи и упражнения 

1.  Сколько  различных  DFS-деревьев  можно  построить  для  полного 

графа Kn? 

2. Докажите, что в двусвязном графе для любых трех вершин a, b, c 

существует путь, соединяющий a и b, не проходящий через c. 

 

73

3. Сколько различных квазициклов имеется в графе с n вершинами, m 

ребрами и k компонентами связности? 

4. Докажите, что  в графе Qn при любом n ≥ 2 существует гамильтонов 

5. Разработайте алгоритм с трудоемкостью O(m + n) для нахождения 

цикл. 

ревом. 

всех перешейков графа. 

6. Разработайте алгоритм, проверяющий, является ли данный граф де-

7.  Разработайте  алгоритм  с  трудоемкостью  O(m  +  n),  проверяющий, 
является ли данный граф двудольным, а при отрицательном ответе нахо-
дящий в нем нечетный цикл. 

8.  Задача  об  одностороннем  движении:  требуется  каждому  ребру  за-
данного  неориентированного  графа  присвоить  ориентацию  таким  обра-
зом, чтобы полученный ориентированный граф был сильно связным. До-
кажите, что это возможно тогда и только тогда, когда в графе нет пере-
шейков. Постройте алгоритм для нахождения такой ориентации. 

9. Докажите, что в каждом связном неориентированном графе сущест-
вует замкнутый маршрут, проходящий по каждому ребру точно один раз в 
каждом  направлении.  Разработайте  алгоритм,  который    находит  такой 
маршрут за время O(m). 

10. Разработайте алгоритм с трудоемкостью O(m), находящий в дан-
ном  неориентированном  графе  кратчайший  цикл,  проходящий  через  за-
данную вершину. 

11. Разработайте алгоритм с трудоемкостью O(m), находящий в дан-
ном неориентированном графе все циклы заданной длины k, проходящие 
через заданную вершину. 

74

 

Глава 3. Экстремальные задачи на графах 

Во многих задачах на графах требуется найти какой-нибудь максимум 
или минимум, например, наибольший подграф с заданным свойством, или 
разбиение графа на наименьшее число частей, удовлетворяющих каким-то 
условиям, и т.д. В этой главе рассматриваются несколько задач такого ро-
да, считающихся классическими в теории графов. Некоторые из них из-
вестны  как  NP-трудные,  для  них  рассматриваются  переборные  алгорит-
мы, приемы рационализации, эвристики и приближенные алгоритмы. Для 
других задач излагаются известные эффективные алгоритмы. В последнем 
разделе  затрагиваются  вопросы  теории  т.н.  жадных  (градиентных)  алго-
ритмов.  
 
3.1. Независимые множества, клики, вершинные покрытия 

 
 
 

 

 

 

3.1.1. Три задачи 
Независимым множеством вершин графа называется любое множест-
во попарно не смежных вершин, то есть множество вершин, порождаю-
щее пустой подграф. Независимое множество называется максимальным, 
если оно не является собственным подмножеством другого независимого 
множества,  и  наибольшим,  если  оно  содержит  наибольшее  количество 
вершин.  Число  вершин  в  наибольшем  независимом  множестве  графа  G 
обозначается через α(G) и называется числом независимости графа. Зада-
ча о независимом множестве состоит в нахождении наибольшего незави-
симого множества. 

Кликой  графа  называется  множество  вершин,  порождающее  полный 
подграф,  то  есть  множество  вершин,  каждые  две  из  которых  смежны. 
Число вершин в клике наибольшего размера называется кликовым числом 
графа и обозначается через  ω(G). Очевидно, задача о независимом мно-
жестве преобразуется в задачу о клике и наоборот простым переходом от 
данного графа G к дополнительному графу 

,G  так что 

. 

α

G ω=
G
(
(

)

)

Вершинное покрытие графа – это такое множество вершин, что каж-
дое ребро графа инцидентно хотя бы одной из этих вершин. Наименьшее 
число вершин в вершинном покрытии графа G обозначается через β(G) и 
называется числом вершинного покрытия графа. В графе на рис. 3.1 наи-
большим независимым множеством является множество {1, 3, 4, 7}, наи-

 

75

большей  кликой  –  множество  {2,  3,  5,  6},  наименьшим  вершинным  по-
крытием – множество {2, 5, 6}. 
 
 
 
 
 
 
 

4 

1 

2

3

7

5

6
Рис. 3.1 

 

 

 

76

 

Между задачами о независимом множестве и о вершинном покрытии 

тоже имеется простая связь благодаря следующему факту. 

U =

Теорема 3.1. Подмножество U множества вершин графа G является 
  – 

вершинным  покрытием  тогда  и  только  тогда,  когда 
независимое множество. 

U−VG

Доказательство. Если U – вершинное покрытие, то всякое ребро со-
держит хотя бы одну вершину из множества U и, значит, нет ни одного 
ребра, соединяющего две вершины из множества U . Следовательно, U  – 
независимое множество. Обратно, если  U  – независимое множество, то 
нет ребер, соединяющих вершины из U  и, значит, у каждого ребра одна 
или  обе  вершины  принадлежат  множеству  U.  Следовательно,  U  –  вер-
шинное покрытие (cid:0). 

Из этой теоремы следует, что α(G) + β(G) = n для любого графа G с n 

вершинами. 

Таким образом, все три задачи тесно связаны друг с другом, так что 
достаточно научиться решать одну из них, и мы будем уметь решать ос-
тальные две. Вместе с тем известно, что эти задачи NP-полны. Для таких 
задач не известно эффективных алгоритмов, а накопленный к настоящему 
времени  опыт  делает  правдоподобным  предположение  о  том,  что  таких 
алгоритмов и не существует. Тем не менее, алгоритмы для подобных за-
дач разрабатывались и продолжают разрабатываться и в некоторых случа-
ях  они  могут  быть  полезны.  Все  эти  алгоритмы  в  той  или  иной  форме 
осуществляют перебор вариантов (число которых может быть очень боль-
шим). Далее рассмотрим один из способов такого перебора для задачи о 
независимом множестве. 

 

 

 

 

 

 

Рис. 3.2 

Пусть Х – какое-нибудь независимое множество графа G. Если оно не 
содержит вершину а, то оно является независимым множеством графа G1. 
Если же a ∈ X, то никакая вершина, смежная с a, не принадлежит X. В 
этом  случае  множество  Х  является  независимым  множеством  графа  G2. 
Заметим, что в графе G1 на одну вершину меньше, чем в исходном графе 
G. Если вершина a не является изолированной, то и в графе G2 вершин 
меньше, чем в графе G. Таким образом, задача о независимом множестве 
для графа G свелась к решению той же задачи для двух графов меньшего 
размера. Это приводит к рекуррентному соотношению для числа незави-
симости: 

3.1.2. Стратегия перебора для задачи о независимом множестве 
Пусть G – граф, в котором требуется найти наибольшее независимое 
множество. Выберем в нем произвольную вершину а. Обозначим через G1 
подграф, получающийся удалением из графа G вершины а, то есть G1 =    
= G – a, а через G2 подграф, получающийся удалением из G всех вершин, 
смежных с a. На рис. 3.2 показаны графы G1 и G2, получающиеся из графа 
G, изображенного на рис. 3.1, при a = 1. 
 
 
 
 
 
 
 
4 
                              G1                                                                                 G2

2 

3 

7 

6 

1

3

7

5

4

6

α(G) = max { α(G1), α(G2)} 

и к рекурсивному алгоритму для нахождения наибольшего независимого 
множества графа G: найдем наибольшее независимое множество X1 графа 
G1  затем  наибольшее  независимое  множество  X2  графа  G2  и  выберем 
большее  из  этих  двух  множеств.  В  целом  процесс  решения  задачи  при 
этом  можно  рассматривать  как  исчерпывающий  поиск  в  возникающем 
дереве подзадач. Чтобы не путать вершины дерева и вершины графа, вер-
шины дерева будем называть узлами. Узел, не являющийся листом, назы-
вается  внутренним  узлом.  Каждому  внутреннему  узлу  дерева соответст-
вует  некоторый  граф  H  и  некоторая  вершина  этого  графа  x.  Вершину  x 
можно  выбирать  произвольно,  но  она  не  должна  быть  изолированной 

 

77

вершиной графа H. Внутренний узел имеет двух сыновей – левого и пра-
вого. Левому сыну соответствует подграф графа H, получаемый удалени-
ем вершины x, а правому – подграф, получаемый удалением всех вершин, 
смежных с x. Корню дерева соответствует исходный граф. Листьям соот-
ветствуют подграфы, не имеющие ребер, то есть подграфы, у которых все 
вершины изолированные. Множества вершин этих подграфов – это неза-
висимые множества исходного графа. 

Для нахождения наибольшего независимого множества не обязатель-
но строить все дерево полностью, а достаточно обойти его в том или ином 
порядке, запоминая на каждом шаге только небольшую часть информации 
об устройстве этого дерева. Можно, например, применить поиск в глуби-
ну для обхода дерева: сначала пройти от корня до некоторого листа, затем 
вернуться к предку этого листа и искать следующий лист, и т.д. 

Для одного и того же графа могут получиться разные деревья в зави-
симости от того, как выбирается активная вершина x в каждом узле дере-
ва. Может быть различным и число листьев в этих деревьях, а значит, и 
трудоемкость  алгоритма,  основанного  обходе  дерева.  Однако  в  любом 
случае листьев в дереве будет не меньше, чем число максимальных неза-
висимых множеств у графа, так как каждое из этих множеств будет соот-
ветствовать некоторому листу. Так, для графа pK2, то есть графа, состоя-
щего из p компонент связности, каждая из которых изоморфна графу K2, в 
дереве подзадач будет в лучшем случае 2 

p листьев.  

 

3.1.3. Рационализация 
Известны различные приемы сокращения перебора при использовании 
описанной  стратегии  исчерпывающего  поиска.  Один  из  них  основан  на 
следующем наблюдении. Допустим, в графе G, для которого нужно найти 
наибольшее независимое множество, имеются две вершины a и b такие, 
что каждая вершина, отличная от b и смежная с вершиной a, смежна и с 
вершиной b. Иначе говоря, V(a) – {b} ⊆ V(b). Будем говорить в этом слу-
чае, что вершина b поглощает вершину a. Если при этом вершины a и b 
смежны, то скажем, что вершина b смежно поглощает вершину a. Верши-
ну  b  в  этом  случае  назовем  смежно  поглощающей.  Например,  в  графе, 
изображенном на рис. 3.1, вершина 2 смежно поглощает вершины 1 и 3. 
Вершины 5 и 6 в этом графе тоже являются смежно поглощающими. 

Лемма 3.2. Если вершина b является смежно поглощающей в графе G, 

то α(G – b) = α(G). 

Доказательство. Допустим, вершина b смежно поглощает вершину a 
в графе G. Пусть X – наибольшее независимое множество графа G. Если X 

 

 

 

78

 

не содержит вершину b, то оно является наибольшим независимым мно-
жеством и в графе G – b, так что в этом случае α(G – b) = α(G). Предпо-
ложим, что множество X содержит вершину b. Тогда ни одна вершина из 
множества V(b) не принадлежит X. Значит, X не содержит вершину a и ни 
одну  вершину  из  множества V(a).  Но  тогда  множество (X – {b})  ∪ {a} 
тоже будет независимым, причем оно целиком содержится в графе G – b, 
а число элементов в нем такое же, как в множестве X. Значит, и в этом 
случае α(G – b) = α(G) (cid:0). 

Итак, если мы удалим из графа смежно поглощающую вершину b, то 
получим граф с тем же числом независимости. Так как новый граф явля-
ется порожденным подграфом исходного графа G, то каждое наибольшее 
независимое  множество  нового  графа  будет  наибольшим  независимым 
множеством исходного. Этот прием называется «сжатием по включению». 
Исследование применимости и применение операции сжатия по включе-
нию  к  каждому  встречающемуся  подграфу  требует,  конечно,  дополни-
тельных  расходов  времени,  но  может  привести  к  существенному  сокра-
щению  дерева  подзадач.  Для  некоторых  графов  задача  о  независимом 
множестве может быть решена с помощью одних только сжатий по вклю-
чению. Таков, например, граф pK2, и вообще любой лес. Действительно, 
любая вершина, смежная с листом, поглощает этот лист. Рассмотрим бо-
лее широкий класс графов, для которых этот прием эффективен. 

 

 

3.1.4. Хордальные графы 
Граф  называется  хордальным  (или  триангулированным),  если  в  нем 
нет порожденных простых циклов длины ≥ 4. Иначе говоря, в хордальном 
графе для каждого простого цикла длины 4 или больше имеется хотя бы 
одна хорда – ребро, не принадлежащее циклу, но соединяющее две вер-
шины цикла. 

 Теорема 3.3. В любом непустом хордальном графе имеется смежно 

поглощающая вершина. 

 Доказательство. Пусть G – непустой граф, в котором нет смежно по-
глощающих вершин. Докажем, что G не хордальный. Рассмотрим в нем 
простой путь P = x1, x2, …, xk наибольшей длины, не имеющий хорд, то 
есть  ребер,  соединяющих  две  вершины  пути  и  не  принадлежащих  пути. 
Так как граф непустой, то k ≥ 2. Рассмотрим вершину xk. Так как она не 
поглощает вершину xk–1, то существует вершина y ≠ xk–1, смежная с вер-
шиной xk, но не смежная с xk–1. Вершина y не принадлежит пути P, так как 
иначе ребро (xk, y) было бы хордой этого пути. Следовательно, последова-

 

79

 

 

тельность P ′ = x1, x2, …, xk, y является простым путем. Но длина этого пу-
ти больше, чем длина пути P, поэтому, в силу выбора пути P, у пути P ′ 
должна существовать хорда. Такой хордой может быть только ребро вида 
(y, xi), где i ≤ k – 2. Пусть i – наибольшее, при котором ребро (y, xi) явля-
ется хордой пути P ′. Тогда последовательность y, xi, xi+1, …, xk, y является 
циклом без хорд длины не менее 4 (cid:0). 

Итак,  для  хордального  графа  наибольшее  независимое  множество 
можно  найти  с  помощью  одних  только  сжатий  по  включению.  Нужно 
только находить смежно поглощающие вершины и удалять их из графа до 
тех пор, пока оставшийся граф не станет пустым. Множество оставшихся 
вершин и является наибольшим независимым множеством. 

3.1.5. Эвристики для задачи о независимом множестве 
Поиск  в  дереве  вариантов  неэффективен  в  общем  случае,  а  приемы 
сокращения  перебора,  подобные  описанному  выше  сжатию  по  включе-
нию, применимы далеко не ко всем графам. Одним из выходов из этого 
положения является применение так называемых эвристических алгорит-
мов,  или  эвристик.  Так  называются  алгоритмы,  основанные  на  каких-
нибудь интуитивных соображениях, которые, как кажется, ведут к полу-
чению  хорошего  решения.  Такие  алгоритмы  могут  иногда  не  давать  во-
обще никакого решения или давать решение, далекое от оптимального. Но 
они, как правило, очень быстро работают, и иногда (а может быть, и очень 
часто) дают решение, близкое к оптимальному или приемлемое для прак-
тики. Рассмотрим две простые эвристики для задачи о независимом мно-
жестве. 

Одна из эвристических идей состоит в том, чтобы рассмотреть только 
один путь от корня до листа в дереве вариантов в надежде, что этому лис-
ту соответствует достаточно большое независимое множество. Для выбо-
ра  этого  единственного  пути  могут  применяться  разнообразные  сообра-
жения. В дереве вариантов, описанном выше, у каждого внутреннего узла 
имеются два сына. Одному из них соответствует подграф, получающийся 
удалением  некоторой  произвольно  выбранной  вершины  a,  а  другому  – 
подграф,  получающийся  удалением  окрестности  этой  вершины.  Чтобы 
вместо  дерева  получился  один  путь,  достаточно  каждый  раз  выполнять 
какую-нибудь одну из этих двух операций. Рассмотрим оба варианта. 

Допустим, мы решили каждый раз удалять выбранную вершину. Эти 
удаления производятся до тех пор, пока не останется граф без ребер, то 
есть независимое множество. Оно и принимается в качестве решения за-
дачи. Для полного описания алгоритма необходимо еще сформулировать 

80

 

правило выбора активной вершины a. Мы хотим получить граф без ребер, 
в котором было бы как можно больше вершин. Чем меньше вершин будет 
удалено, тем больше их останется. Значит, цель – как можно быстрее уда-
лить все ребра. Кажется, мы будем двигаться в нужном направлении, если 
на каждом шаге будем удалять наибольшее возможное на этом шаге число 
ребер. Это означает, что в качестве активной вершины всегда нужно вы-
бирать вершину наибольшей степени. Алгоритмы такого типа называются 
жадными  или  градиентными.  К  сожалению,  как  будет  показано  дальше, 
оптимальный выбор на каждом шаге не гарантирует получения оптималь-
ного решения в конечном итоге. 

Другой вариант – каждый раз удалять окрестность активной вершины 
a. Это опять повторяется до тех пор, пока оставшиеся вершины не будут 
образовывать независимого множества. Удаление окрестности вершины a 
равносильно тому, что сама эта вершина включается в независимое мно-
жество, которое будет получено в качестве ответа. Так как мы хотим по-
лучить в итоге как можно большее независимое множество, естественно 
постараться удалять на каждом шаге как можно меньше вершин. Это оз-
начает, что в качестве активной вершины всегда нужно выбирать вершину 
наименьшей степени. Получается еще один вариант жадного алгоритма. 

Имеется  немало  графов,  для  которых  каждая  из  этих  эвристик  дает 
близкое  к  оптимальному,  а  иногда  и  оптимальное  решение.  Но,  как  это 
обычно  бывает  с  эвристическими  алгоритмами,  можно  найти  примеры 
графов,  для  которых  найденные  решения  будут  весьма  далеки  от  опти-
мальных. Рассмотрим граф Gk, у которого множество вершин V состоит из 
трех частей: V = A ∪ B1 ∪ B2, причем A является независимым множест-
вом, каждое из множеств B1, B2 – кликой, и каждая вершина из множества 
A смежна с каждой вершиной из множества B1 ∪ B2. С помощью опера-
ций суммы и соединения графов (раздел 1.3) этот граф можно представить 
формулой Gk = (Kk + Kk) ° Ok. Степень каждой вершины из множества A в 
этом  графе  равна  2k,  а  степень  каждой  вершины  из  множества  B1  ∪  B2 
равна 2k – 1. Первый алгоритм, выбирающий вершину наибольшей степе-
ни, будет удалять вершины из множества A до тех пор, пока не удалит их 
все.  После  этого  останется  граф,  состоящий  из  двух  клик  и  в  конечном 
итоге  будет  получено  независимое  множество  из  двух  вершин.  Второй 
алгоритм  на  первом  шаге  возьмет  в  качестве  активной  одну  из  вершин 
множества B1 ∪ B2 и удалит всю ее окрестность. В результате получится 
граф, состоящих из этой вершины и клики, а после второго шага получит-
ся  независимое  множество,  состоящее  опять  из  двух  вершин.  Итак,  при 
применении к этому графу любой из двух эвристик получается независи-

 

81

мое множество из двух вершин. В то же время в графе имеется независи-
мое множество A мощности k. 

3.1.6.  Приближенный  алгоритм  для  задачи  о  вершинном  покры-

тии 

Иногда для алгоритма, не гарантирующего точного решения, удается 
получить оценку степени приближения, то есть отклонения получаемого 
решения от точного. В таком случае говорят о приближенном алгоритме. 
Рассмотрим один простой приближенный алгоритм для задачи о вершин-
ном покрытии. 

Работа  алгоритма  начинается  с  создания  пустого  множества  X  и  со-
стоит в выполнении однотипных шагов, в результате каждого из которых 
к  множеству  X  добавляются  некоторые  вершины.  Допустим,  перед  оче-
редным шагом имеется некоторое множество вершин X. Если оно покры-
вает все ребра (то есть каждое ребро инцидентно одной из этих вершин), 
то процесс заканчивается, и множество X принимается в качестве искомо-
го  вершинного  покрытия. В противном случае выбирается какое-нибудь 
непокрытое ребро (a, b), и вершины a и b добавляются к множеству X. 

Для полного описания алгоритма нужно бы еще сформулировать пра-
вило выбора ребра (a, b). Однако для оценки степени приближения, кото-
рая  будет  сейчас  получена,  это  не  имеет  значения.  Можно  считать,  что 
какое-то правило выбрано. 

Обозначим через β′(G) мощность вершинного покрытия, которое по-
лучится  при  применении  этого  алгоритма  к  графу  G  и  докажем,  что 
β′(G) ≤ 2β(G). Иначе говоря, полученное с помощью этого алгоритма ре-
шение не более чем в два раза отличается от оптимального. 

Действительно, допустим, что до окончания работы алгоритм выпол-
няет k шагов, добавляя к множеству X вершины ребер (a1, b1), …, (ak, bk). 
Тогда β′(G) = 2k. Никакие два из этих k ребер не имеют общей вершины. 
Значит, чтобы покрыть все эти ребра, нужно не меньше k вершин. Следо-
вательно, β(G) ≥ k и β′(G) ≤ 2β(G). 

 

3.1.7. Перебор максимальных независимых множеств 
Основной  недостаток  изложенного  выше  способа  организации  пере-
бора состоит в том, что при нем часто рассматриваются не только макси-
мальные  независимые  множества.  Это  означает,  что  делается  заведомо 
лишняя  работа,  так  как  наибольшее  независимое  множество  находится, 
конечно,  среди  максимальных.  Кроме  того  в  некоторых  случаях  бывает 
необходимо знать все максимальные независимые множества. Рассмотрим 
алгоритм, который строит все максимальные и только максимальные не-

 

 

 

82

 

зависимые множества графа. 

Предположим, что вершинами заданного графа G являются числа 1, 2, 
..., n. Рассматривая любое подмножество множества вершин, будем выпи-
сывать его элементы в порядке возрастания. Лексикографический порядок 
на множестве получающихся таким образом кортежей порождает линей-
ный  порядок  на  множестве  всех  подмножеств  множества  вершин,  кото-
рый  тоже  будем  называть  лексикографическим.  Например,  множество    
{2, 5, 7, 9} предшествует в этом порядке множеству {2, 5, 8}, а множест-
во {2, 5, 7, 10} занимает промежуточное положение между этими двумя. 
Нетрудно  найти  лексикографически  первое  максимальное  независи-
мое множество: нужно на каждом шаге брать наименьшую из оставшихся 
вершин,  добавлять  ее  к  построенному  независимому  множеству,  а  все 
смежные  с  ней  вершины  удалять  из  графа.  Если  граф  задан  списками 
смежности, то это построение выполняется за время O(m). 

Допустим теперь, что U ⊆ VG, G′ – подграф графа G, порожденный 
множеством  U,  и  пусть  имеется  список  L  всех  максимальных  независи-
мых множеств графа G. Тогда однократным просмотром списка L можно 
получить список L′ всех максимальных независимых множеств графа G′. 
Это основано на следующих очевидных утверждениях: 

1) каждое максимальное независимое множество графа G′ содержится 

в некотором максимальном независимом множестве графа G; 

2)  для  каждого  максимального  независимого  множества  N  графа  G′ 
имеется  точно  одно  максимальное  независимое  множество  М  графа  G  
такое, что N ⊆ M и M – N – лексикографически первое среди максималь-
ных  независимых  множеств  подграфа,  порожденного  множеством  VG  –           
– (U ∪ V(N )) (последнее утверждение верно и в том случае, если VG –     
– (U ∪ V(N )) = ∅, если считать, что пустое множество является макси-
мальным  независимым  множеством  в  графе  с  пустым  множеством  вер-
шин). 

Будем теперь рассматривать множества из L одно за другим и пусть М 
– очередное такое множество. Положим N = M ∩ U. Если N не является 
максимальным  независимым  множеством  графа G′,  то  переходим к сле-
дующему  элементу  списка  L.  Если  же  N  –  максимальное  независимое 
множество в G′, то рассматриваем множество M – N. Если оно является 
лексикографически первым среди максимальных независимых множеств 
подграфа, порожденного множеством VG – (U ∪ V(N )), то включаем N в 
список G′. 

 

83

Выберем в графе G произвольную вершину а и пусть A – множество 
всех вершин графа, смежных с а (окрестность вершины a), В – множество 
всех вершин, не смежных с а и отличных от a. Обозначим через G1 под-
граф, получающийся удалением из графа G вершины а, а через G2 под-
граф,  получающийся  удалением  из  G  всех  вершин  множества  A  ∪  {a}. 
Иначе говоря, G1 – подграф графа G, порожденный множеством A ∪ B, а 
G2 – подграф, порожденный множеством B. 

Допустим,  что  имеется  список  L1  всех  максимальных  независимых 
множеств графа G1. На основании вышеизложенного можно предложить 
следующую процедуру получения списка L всех максимальных независи-
мых множеств графа G. 

1. Взять очередной элемент М списка L1. 
2. Если M ⊆ B, то добавить к списку L множество M ∪ {a} и перейти 

к 1, иначе добавить к списку L множество М. 

3.  Если  множество  M  ∩  B  не  является  максимальным  независимым 

множеством в графе G2, то перейти к 1. 

4.  Если  множество  N  =  M  ∩  A  является  лексикографически  первым 
максимальным  независимым  множеством  подграфа,  порожденного  мно-
жеством A – V(M ∩ B), то добавить к списку L множество M ∪ {a}. 

5. Если список L1 не исчерпан, перейти к 1. 
Начиная  с  одновершинного  графа  (у  которого  список  максимальных 
независимых множеств состоит из одного элемента), добавляя последова-
тельно  по  одной  вершине,  получаем  последовательность  графов  G1,  G2, 
…, Gn = G. Применяя для каждого i = 1, …, n – 1 описанный алгоритм 
для построения списка всех максимальных независимых множеств графа 
Gi+1 по такому списку для графа Gi, в конце концов получим список всех 
максимальных независимых множеств графа G. По сути дела, этот алго-
ритм представляет собой поиск в ширину в дереве вариантов. Для того, 
чтобы не хранить всех получающихся списков, его можно преобразовать в 
поиск в глубину. Заметим, что приведенная процедура для каждого мак-
симального независимого множества графа Gi находит одно или два мак-
симальных независимых множества графа Gi+1. Одно из этих новых мно-
жеств рассматривается на следующем шаге, другое, если оно есть, запо-
минается в стеке. 

Изложенный алгоритм можно применить для отыскания наибольших 
независимых  множеств  в  графах,  про  которые  известно,  что  в  них  мало 
максимальных независимых множеств. Одним из классов графов с таким 
свойством является класс всех графов, не содержащих 2K2 в качестве по-

84

 

рожденного подграфа. Известно, что в графе с т ребрами из этого класса 
число максимальных независимых множеств не превосходит m + 1. 

3.2. Раскраски 

 

 

 

 

 

3.2.1. Раскраска вершин 
Раскраской  вершин  графа  называется  назначение  цветов  его  верши-
нам. Обычно цвета – это числа 1, 2, ..., k. Тогда раскраска является функ-
цией, определенной на множестве вершин графа и принимающей значе-
ния во множестве {1, 2, …, 3}. Раскраску можно также рассматривать как 
разбиение множества вершин V = V1 ∪ V2 ∪ … ∪ Vk, где Vi – множество 
вершин  цвета  i.  Множества  Vi  называют  цветными  классами.  Раскраска 
называется правильной, если каждый цветной класс является независимым 
множеством. Иначе говоря, в правильной раскраске любые две смежные 
вершины должны иметь разные цвета. Задача о раскраске состоит в нахо-
ждении правильной раскраски данного графа G в наименьшее число цве-
тов.  Это  число  называется  хроматическим  числом  графа  и  обозначается 
χ(G). 

χ(G) ≥ ω(G). 

В правильной раскраске полного графа Kn все вершины должны иметь 
разные цвета, поэтому χ(Kn) = n. Если в каком-нибудь графе имеется пол-
ный подграф с k вершинами, то для раскраски этого подграфа необходимо 
k цветов. Отсюда следует, что для любого графа выполняется неравенство 
 
(3.1) 
Однако хроматическое число может быть и строго больше кликового чис-
ла. Например, для цикла длины 5 ω(C5) = 2, а χ(C5) = 3. Другой пример 
показан на рис. 3.3. На нем изображен граф, вершины которого раскраше-
ны в 4 цвета (цвета вершин показаны в скобках). Нетрудно проверить, что 
трех цветов для правильной раскраски этого графа недостаточно. Следо-
вательно, его хроматическое число равно 4. Очевидно также, что кликовое 
число этого графа равно 3. 
 
 
 
 
 
 
 
 

b (2) 

g (4) 

f (1) 

e (3)

a(1)

c (3)

d (2)

Рис. 3.3 

 

85

Очевидно, χ(G) = 1 тогда и только тогда, когда G – пустой граф. Не-
трудно охарактеризовать и графы с хроматическим числом 2 (точнее, не 
больше 2). По определению, это такие графы, у которых множество вер-
шин  можно  разбить  на  два  независимых  множества.  Но  это  совпадает  с 
определением двудольного графа. Поэтому двудольные графы называют 
еще  бихроматическими.  Согласно  теореме  1.14,  граф  является  бихрома-
тическим тогда и только тогда, когда в нем нет циклов нечетной длины. 

Для  графов  с  хроматическим  числом  3  такого  простого  описания  не 
известно.  Не  известно  и  простых  алгоритмов,  проверяющих,  можно  ли 
данный граф раскрасить в 3 цвета. Более того, задача такой проверки (во-
обще, задача проверки возможности раскрасить граф в k цветов при лю-
бом фиксированном k ≥ 3) является NP-полной.  
3.2.2. Переборный алгоритм для раскраски 
Рассмотрим  алгоритм  решения  задачи  о  раскраске,  похожий  на  опи-
санный  выше  алгоритм  для  задачи  о  независимом  множестве.  Сходство 
заключается в том, что задача для данного графа сводится к той же задаче 
для двух других графов. Поэтому снова возникает дерево вариантов, об-
ход которого позволяет найти решение. Но есть и одно существенное раз-
личие, состоящее в том, что теперь два новых графа не будут подграфами 
исходного графа. 

Выберем в данном графе G две не смежные вершины x и y и построим 
два новых графа: G1, получающийся добавлением ребра (x, y) к графу G, и 
G2, получающийся из G слиянием вершин x и y. Операция слияния состо-
ит в удалении вершин x и y и добавлении новой вершины z и ребер, со-
единяющих ее с каждой вершиной, с которой была смежна хотя бы одна 
из  вершин x, y.  На  рис.  3.4  показаны  графы G1, и G2, получающиеся из 
графа G, изображенного на рис. 3.3 с помощью этих операций, если в ка-
честве x и y взять вершины a и f. 
 
 
 
 
 
 
 
 
                                       G1                                                          G2 
 

g 

b

c

d

g

c

f

b

d

z

e

a

 

 

86

 

e

Рис. 3.4 

Если в правильной раскраске графа G вершины a и b имеют разные 
цвета, то она будет правильной и для графа G1. Если же цвета вершин a и 
b в раскраске графа G одинаковы, то граф G2 можно раскрасить в то же 
число цветов: новая вершина с окрашивается в тот цвет, в который окра-
шены вершины a и b, а все остальные вершины сохраняют те цвета, кото-
рые они имели в графе G. Обратно, раскраска каждого из графов G1, G2, 
очевидно, дает раскраску графа G в то же число цветов. Поэтому  

χ(G) = min { χ(G1), χ(G2)}, 

что дает возможность рекурсивного нахождения раскраски графа в мини-
мальное  число  цветов.  Заметим,  что  граф  G1  имеет  столько  же  вершин, 
сколько исходный граф, но у него больше ребер. Поэтому рекурсия в ко-
нечном счете приводит к полным графам, для которых задача о раскраске 
решается тривиально.  

 

3.2.3. Рационализация 
В описанную схему решения задачи о раскраске можно включить тот 
же прием сжатия по включению, что и для задачи о независимом множе-
стве. Небольшое отличие состоит в том, что теперь вершины a и b долж-
ны быть не смежны. Итак, пусть в графе G имеются две несмежные вер-
шины  a  и  b  такие,  что V(a)  ⊆ V(b).  Будем  говорить,  что  вершина b  не-
смежно  поглощает  вершину  a,  а  вершину  a  называть  несмежно  погло-
щаемой. В графе на рис. 3.3 нет несмежно поглощаемых вершин (но вер-
шины b и c смежно поглощают друг друга). В графе G1 на рис. 3.4 верши-
на a несмежно поглощает вершину g. 

Лемма 3.4. Если вершина a является несмежно поглощаемой в графе 

 

 

 

G, то χ(G – a) = χ(G). 

Доказательство.  Допустим,  вершина  a  несмежно  поглощается  вер-
шиной b. Рассмотрим правильную раскраску графа G – a в наименьшее 
число  цветов.  Применим  эту  же  раскраску  к  графу  G,  окрасим  a  в  тот 
цвет, который имеет вершина b. Так как вершина a смежна только с таки-
ми вершинами, с которыми смежна b, то получится правильная раскраска 
графа G в то же самое число цветов. Следовательно, χ(G) = χ(G – a) (cid:0). 

Как  и  для  задачи  о  независимом  множестве,  для  некоторых  графов 
этот прием позволяет находить решение, совсем не прибегая к перебору. 
Допустим,  вершина  b  смежно  поглощает  вершину  a  в  графе  G.  Тогда  в 
,G  очевидно, вершина a будет несмежно погло-
дополнительном  графе 
щать вершину b. Верно и обратное утверждение. Поэтому из теоремы 3.3 
следует 

 

87

Теорема 3.5. В любом графе, дополнительном к хордальному и не яв-

ляющимся полным, имеется несмежно поглощаемая вершина.  

 Таким образом, для графов, дополнительных к хордальным, раскраска 
в минимальное число цветов может быть найдена с помощью одних толь-
ко сжатий по включению. Оказывается, и для хордальных графов сущест-
вует эффективное решение задачи о раскраске. 

 

3.2.4. Хордальные графы 
 Установим сначала некоторые свойства хордальных графов. Подмно-
жество множества вершин графа называется разделяющим множеством, 
если удаление всех этих вершин приводит к увеличению числа компонент 
связности.  Таким  образом,  понятие  разделяющего  множества  является 
обобщением  понятия  шарнира.  Разделяющее  множество  называется  ми-
нимальным, если оно не содержится в большем разделяющем множестве. 
Лемма  3.6.  В  хордальном  графе  всякое  минимальное  разделяющее 

 

множество является кликой. 

Доказательство. Допустим, что в некотором графе G есть минималь-
ное разделяющее множество X, не являющееся кликой. Это означает, что 
в X имеются не смежные вершины a и b. При удалении множества X обра-
зуется не менее двух новых компонент связности. Пусть C1 и C1 – такие 
компоненты. Вершина a смежна по крайней мере с одной вершиной в ка-
ждой из этих компонент. Действительно, если a была бы не смежна, ска-
жем, ни с одной из вершин компоненты C1, то множество X – {a} тоже 
было бы разделяющим, а это противоречит минимальности разделяющего 
множества X. То же относится к вершине b. Выберем в компоненте C1 та-
кие вершины x1 и y1, чтобы x1 была смежна с вершиной a, y1 была смежна 
с вершиной b, и при этом расстояние между x1 и y1 в C1 было минималь-
ным  (возможно  x1  =  y1).  Аналогично  выберем  x2  и  y2  в  компоненте  C2. 
Пусть P1 – кратчайший путь из x1 в y1 в компоненте C1, а P2 – кратчайший 
путь из y2 в x2 в компоненте C2 (каждый из этих путей может состоять из 
одной вершины). Тогда последовательность a, P1, b, P2, a является про-
стым циклом без хорд длины не менее 4. Следовательно, граф G не хор-
дальный (cid:0). 

Вершина  графа  называется  симплициальной,  если  множество  всех 

смежных с ней вершин является кликой или пустым множеством.  

 Лемма 3.7. В любом хордальном графе имеется симплициальная вер-

Доказательство.  В  полном  графе  любая  вершина  является  симпли-
циальной. Докажем индукцией по числу вершин n, что в любом не пол-

шина. 

88

 

ном  хордальном  графе  есть  две  не  смежные  симплициальные  вершины. 
При n = 2 это, очевидно, так. Пусть G – хордальный граф с n вершинами, 
n > 2, не являющийся полным. Если G несвязен, то, по предположению 
индукции, во всех компонентах связности есть симплициальные вершины. 
Допустим, что граф G связен. Так как он не полный, то в нем есть разде-
ляющее множество, а по лемме 3.6, есть разделяющая клика. Пусть C – 
такая клика, A и B – две новые компоненты связности, появляющиеся при 
удалении из графа всех вершин клики C. Рассмотрим подграф GA, порож-
денный  множеством  A  ∪  C.  Если  он  полный,  то  в  нем  любая  вершина 
симплициальна. Если же он не полный, то по предположению индукции в 
нем есть две не смежные симплициальные вершины. Хотя бы одна из этих 
двух вершин принадлежит множеству A. Итак, в любом случае в множе-
стве A имеется вершина a, являющаяся симплициальной в графе GA. Ок-
рестность вершины a во всем графе G совпадает с ее окрестностью в под-
графе GA. Следовательно, a – симплициальная вершина графа G. Анало-
гично, в множестве B имеется симплициальная вершина графа G и она не 
смежна с вершиной a (cid:0). 

Существование  симплициальных  вершин  можно  использовать  для 
создания  эффективного  алгоритма  раскрашивания  хордального  графа  в 
наименьшее  число  цветов.  План  такого  алгоритма  содержится  в  доказа-
тельстве следующей теоремы. 

Теорема 3.8. Для любого хордального графа χ(G) = ω(G). 
Доказательство.  Пусть  G  –  хордальный  граф  с  n  вершинами  и 
ω(G) = k. Покажем, что граф G можно правильно раскрасить в k цветов. 
Найдем в нем симплициальную вершину и обозначим ее через xn, а граф, 
полученный  удалением  этой  вершины,  через  Gn–1.  Этот  граф  тоже  хор-
дальный, значит, в нем тоже есть симплициальная вершина. Пусть xn–1 – 
симплициальная вершина в графе Gn–1, а Gn–2 – граф, получаемый из него 
удалением  этой  вершины.  Продолжая  действовать  таким  образом,  полу-
чим последовательность вершин xn, xn–1, …, x1 и последовательность гра-
фов Gn, Gn–1, …, G1 (здесь Gn = G), причем при каждом i вершина xi явля-
ется симплициальной в графе Gi–1, а граф Gi–1 получается из Gi удалением 
этой вершины. 

Допустим,  что  граф  Gi–1  правильно  раскрашен  в  k  цветов.  Покажем, 
что  вершину  xi  можно  покрасить  в  один  из  этих  цветов,  сохраняя  пра-
вильность раскраски. Действительно, xi – симплициальная вершина графа 
Gi, значит, множество C всех смежных с ней в этом графе вершин являет-
ся кликой. Так как при добавлении к множеству C вершины xi тоже полу-

 

89

чается клика, а мощность наибольшей клики в графе G равна k, то | C | ≤     
≤ k – 1. Значит, для окрашивания вершин множества C использовано не 
более k – 1 цвета. Поэтому для вершины xi можно использовать один из 
оставшихся цветов. 

Итак, каждый из графов Gi, а, значит, и исходный граф G, можно пра-
вильно раскрасит в k цветов. Отсюда следует, что χ(G) ≤ ω(G), а вместе с 
неравенством (3.1) это дает утверждение теоремы (cid:0). 

 

 

3.2.5. Раскраска ребер 
Наряду с задачей о раскраске вершин имеется задача о раскраске ре-
бер графа, когда цвета назначаются ребрам. Раскраска ребер (или ребер-
ная  раскраска) называется правильной, если любые два ребра, имеющие 
общую вершину, окрашены в разные цвета. Минимальное число цветов, 
необходимое  для  правильной  раскраски  ребер  графа  G,  называется  хро-
матическим индексом графа и обозначается через χ′(G). 

Обозначим через ∆(G) максимальную степень вершины в графе. При 
правильной реберной раскраске все ребра, инцидентные одной вершине, 
должны иметь разные цвета. Отсюда следует, что для любого графа вы-
полняется неравенство χ′(G) ≥ ∆(G). Для некоторых графов имеет место 
строгое неравенство, например, ∆(C3) = 2, а χ′( C3) =3. Следующая теоре-
ма, доказанная В.Г. Визингом в 1964 г., показывает, что χ′(G) может от-
личаться от 

 не более чем на 1. 

(G∆

)

Теорема 3.9. Для любого графа G справедливы неравенства 

∆(G) ≤ χ′(G) ≤ ∆(G) + 1. 

 

 

Доказательство. Приводимое ниже доказательство дает и план алго-
ритма  для  раскрашивания  ребер  графа  не  более  чем  в  ∆(G)  +  1  цветов. 
Оно основано на двух операциях перекрашивания, с описания которых и 
начнем. Далее будут рассматриваться частичные реберные раскраски, то 
есть правильные раскраски, при которых некоторые ребра остаются неок-
рашенными. 

Допустим,  ребра  графа G  правильно (может быть, частично) раскра-
шены. Пусть α и β – два из использованных в этой раскраске цветов. Рас-
смотрим  подграф  H,  образованный  всеми  ребрами,  имеющими  цвета  α 
или β. В этом подграфе степень каждой вершины не превосходит 2, сле-
довательно, каждая компонента связности в нем является цепью или цик-
лом.  Такую  компоненту  будем  называть  (α, β)-компонентой.  Если  в  ка-
кой-нибудь (α, β)-компоненте поменять местами цвета α и β (то есть все, 

90

 

окрашенные  в  цвет  α,  перекрасить  в  цвет  β  и  наоборот),  то  полученная 
раскраска  тоже  будет  правильной.  Эту  операцию  назовем  перекраской 
(α, β)-компоненты. 

Другая  операция  применяется  к  частично  раскрашенному  подграфу, 
называемому веером. Будем говорить, что при данной раскраске цвет α, 
отсутствует в вершине x, если ни одно из ребер, инцидентных вершине x, 
не окрашено в этот цвет. Веером называется подграф F (x, y1, …, yk, α1, 
…, αk), состоящий из вершин x, y1, …, yk и ребер (x, y1), …, (x, yk), в кото-
ром 

ребро (x, y1) не окрашено; 
ребро (x, yi) окрашено в цвет αi−1, i = 2, …, k; 
в вершине yi отсутствует цвет αi, i = 1, …, k; 
α1, …, αk−1 все попарно различны. 
Перекраска веера состоит в том, что ребра (x, y1), …, (x, yk–1) окраши-
ваются соответственно в цвета α1, …, αk−1, а ребро (x, yk) становится не-
окрашенным. Очевидно, новая частичная раскраска тоже будет правиль-
ной. На рис. 3.5 слева показан веер, а справа – результат его перекраски. 
Цвета ребер представлены числами, а отсутствующие цвета в вершинах – 
числами со знаком минус. Неокрашенное ребро изображено пунктиром.  

Покажем, что с помощью этих двух процедур перекрашивания можно 
ребра любого графа G окрасить в не более чем ∆(G) + 1 цветов. Допус-
тим,  что  уже  построена  частичная  правильная  раскраска,  использующая 
не более чем ∆(G) + 1 цветов, и имеется неокрашенное ребро (x, y). Так 
как  число  разрешенных  цветов  больше,  чем  максимальная  степень  вер-
шины, то в каждой вершине какой-нибудь цвет отсутствует. Допустим, в 
вершине x отсутствует цвет β.  

Будем строить веер следующим образом. Положим y1 = y и пусть α1 – 
цвет, отсутствующий в вершине y. Получаем веер F(x, y1, α1). Допустим, 

 

91

 
 –1 
y1
 
 
 
 
 
 
 

 

–2 
y2

–3 
y3

–4 
y4

–3
y5

y1

y2

y3

y4

y5

1

2 

3 

4 

1

2

3

4

x 

x

Рис. 3.5 

веер F(x, y1, …, yk, α1, …, αk) уже построен. Если цвет αk отличен от α1, 
…, αk–1 и имеется инцидентное вершине x ребро (x, z) этого цвета, то уве-
личиваем k на 1 и полагаем yk = z, αk – цвет, отсутствующий в вершине z. 
Этот процесс построения веера продолжается до тех пор, пока не насту-
пит одно из следующих событий. 

(А) Нет ребра цвета αk, инцидентного вершине x. Перекрашиваем ве-
ер, в результате ребро (x, y) становится окрашенным, а ребро (x, yk) – не-
окрашенным, причем цвет αk отсутствует и в вершине yk, и в вершине x. 
Но тогда можно это ребро окрасить в цвет αk, получим правильную рас-
краску, в которой на одно окрашенное ребро больше. 

(Б) Цвет αk совпадает с одним из цветов α1, …, αk–1 (именно этот слу-
чай изображен на рисунке 3.5). Пусть αk = αi. Рассмотрим вершины x, yi, 
yk. В каждой из них отсутствует какой-нибудь из цветов β или αk. Значит, 
в подграфе, образованном ребрами этих двух цветов, степень каждой из 
этих вершин не превосходит 1. Следовательно, все три вершины не могут 
принадлежать одной (αk, β)-компоненте. Рассмотрим две возможности. 

(Б1) Вершины x и yi принадлежат разным (αk, β)-компонентам. Пере-
красим веер F(x, y1, …, yi, α1, .., αi). Ребро (x, yi) станет неокрашенным. 
Теперь  перекрасим  (αk,  β)-компоненту,  содержащую  вершину  yi.  После 
этого цвет β будет отсутствовать в вершине yi и ребро (x, yi) можно окра-
сить в этот цвет. 

(Б2) Вершины x и yk принадлежат разным (αk, β)-компонентам. Пере-
красим веер F(x, y1, …, yi, α1, .., αi). Ребро (x, yi) станет неокрашенным. 
Теперь  перекрасим  (αk,  β)-компоненту,  содержащую  вершину  yk.  После 
этого цвет β будет отсутствовать в вершине yk и ребро (x, yi) можно окра-
сить в этот цвет. 

Итак, в любом случае получаем правильную раскраску, в которой до-

бавилось еще одно раскрашенное ребро (x, y) (cid:0). 

На рис. 3.6 иллюстрируются случаи (Б1) и (Б2) на примере веера с рис. 
3.5. Здесь k = 5, i = 3. Левое изображение соответствует случаю (Б1): вер-
шины x и y3 принадлежат разным (3, 5)-компонентам. После перекраски 
веера F(x, y1, y2, y3, 1, 2, 3) и (3, 5)-компоненты, содержащей вершину y3, 
появляется возможность окрасить ребро (x, y3) в цвет 5. Случай (Б2) пока-
зан справа: здесь вершины x и y5 принадлежат разным (3, 5)-компонентам, 
поэтому после перекраски веера F(x, y1, y2, y3, y4, y5, 1, 2, 3, 4, 3) и (3,5)-
компоненты, содержащей вершину y5, появляется возможность окрасить 
ребро (x, y5) в цвет 5. 

92

 

 
 
 
 
 
 
 
 

 

y1

y2

y3

y4

y5

y1

y2

y3

y4

y5

1 

2

5 

3 

4 

1

2

3

4

5 

x 

x

Рис 3.6 

 

 

Итак, все графы делятся на два класса: у одних хроматический индекс 
равен максимальной степени вершины, у других он на единицу больше. 
Оказывается, определение принадлежности графа к тому или иному клас-
су  является  NP-трудной  задачей.  Алгоритм,  который  можно  извлечь  из 
доказательства теоремы 3.9, за полиномиальное время находит раскраску 
в не более чем ∆(G) + 1 цветов. Его можно назвать «идеальным» прибли-
женным алгоритмом – более высокую точность имеет только точный ал-
горитм. 
 

3.3. Паросочетания 
3.3.1. Паросочетания и реберные покрытия 
Паросочетанием  в  графе  называется  множество  ребер,  попарно  не 
имеющих общих вершин. Задача о паросочетании состоит в том, чтобы в 
данном графе найти паросочетание с наибольшим числом ребер. Это чис-
ло для графа G будем обозначать через π(G). Реберным покрытием графа 
называется такое множество ребер, что всякая вершина графа инцидентна 
хотя бы одному из этих ребер. Наименьшее число ребер в реберном по-
крытии графа G обозначим через ρ(G). Заметим, что реберное покрытие 
существует только для графов без изолированных вершин. 

Определение  паросочетания  похоже  на  определение  независимого 
множества вершин, паросочетание иногда так и называют – независимое 
множество ребер. Эта аналогия усиливается еще тесной связью между ре-
берными покрытиями и паросочетаниями, подобно тому, как связаны ме-
жду собой вершинные покрытия и независимые множества. Даже равен-
ство,  количественно  выражающее  эту  связь,  имеет  точно  такой  же  вид 
(напомним, что числа независимости α(G) и вершинного покрытия β(G) 
связаны равенством α(G) + β(G) = n). Приводимое ниже доказательство 
этого факта имеет алгоритмическое значение, так как показывает, каким 
образом каждая из двух задач может быть сведена к другой. 

 

93

Теорема 3.10. Для любого графа G с n вершинами, не имеющего изо-

лированных вершин, справедливо равенство π(G) + ρ(G) = n. 

Доказательство.  Пусть  М  –  наибольшее  паросочетание  в  графе  G. 
Обозначим через W множество всех вершин графа, не покрытых ребрами 
этого паросочетания. Тогда |W| = n – 2π(G). Очевидно, W – независимое 
множество (иначе М не было бы наибольшим). Выберем для каждой вер-
шины  из  М  какое-нибудь  инцидентное  ей  ребро.  Пусть  F  –  множество 
всех выбранных ребер. Тогда M ∪ F – реберное покрытие и |M ∪ F | =       
= n – π(G), следовательно, ρ(G) = n – π(G). 

Обратно, пусть C – наименьшее реберное покрытие графа G. Рассмот-
рим подграф Н графа G, образованный ребрами этого покрытия. В графе 
Н один из концов каждого ребра является вершиной степени 1 (ребро, ка-
ждая вершина которого инцидентна по крайней мере еще одному ребру, 
можно было бы удалить из С, оставшиеся ребра по-прежнему покрывали 
бы все вершины). Отсюда следует, что каждая компонента связности гра-
фа  Н  является  звездой  (звезда  –  это  дерево,  у  которого  не  более  одной 
вершины степени больше 1). Так как в любом лесе сумма количеств ребер 
и компонент связности равна числу вершин, то число компонент связно-
сти в графе Н равно n – ρ(G). Выбрав по одному ребру из каждой компо-
ненты, получим паросочетание. Отсюда следует, что π(G) ≥ n – ρ(G) (cid:0). 

Несмотря на такое сходство между «вершинными» и «реберными» ва-
риантами независимых множеств и покрытий, имеется кардинальное раз-
личие в сложности соответствующих экстремальных задач. «Вершинные» 
задачи, как уже отмечалось, являются NP-полными. Для реберных же из-
вестны  полиномиальные  алгоритмы.  Они  основаны  на  методе  чередую-
щихся  цепей,  к  рассмотрению  которого  мы  теперь  переходим.  Отметим 
только еще, что ситуация похожа на то, что наблюдается для задач об эй-
леровом и гамильтоновом циклах – реберный вариант эффективно реша-
ется, а вершинный является NP-полным. 
3.3.2. Метод увеличивающих цепей 
Пусть G – граф, М – некоторое паросочетание в нем. Ребра паросоче-
тания будем называть сильными, остальные ребра графа – слабыми. Вер-
шину назовем свободной, если она не принадлежит ребру паросочетания. 
На  рис.  3.7  слева  показан  граф  и  в  нем  выделены  ребра  паросочетания 
M = {(2, 3), (4, 5), (7, 8)}. Вершины 1 и 5 – свободные. Заметим, что к 
этому паросочетанию нельзя добавить ни одного ребра, то есть оно мак-
симальное. Однако оно не является наибольшим. В этом легко убедиться, 
если рассмотреть путь 5, 6, 8, 9, 10, 7, 3, 4 (показан пунктиром). Он начи-

 

 

94

 

нается  и  оканчивается  в  свободных  вершинах,  а  вдоль  пути  чередуются 
сильные  и  слабые  ребра.  Если  на  этом  пути  превратить  каждое  сильное 
ребро в слабое, а каждое слабое – в сильное, то получится новое паросо-
четание, показанное на рисунке справа, в котором на одно ребро больше. 
Увеличение  паросочетания  с  помощью  подобных  преобразований  –  в 
этом и состоит суть метода увеличивающих цепей.  
 
 
 
 
 
 

10 

10

7 

2

6

2 

6 

1 

5 

1

5

3

9

8 

7 

4 

4

3 

9 

8

Рис. 3.7 

 

 

Сформулируем необходимые понятия и докажем теорему, лежащую в 
основе этого метода. Чередующейся цепью относительно данного паросо-
четания называется простой путь, в котором чередуются сильные и сла-
бые ребра (то есть за сильным ребром следует слабое, за слабым – силь-
ное). Чередующаяся цепь называется увеличивающей, если она соединяет 
две  свободные  вершины.  Если  М  –  паросочетание,  Р  –  увеличивающая 
цепь относительно М, то легко видеть, что M ⊗ P – тоже паросочетание и 
| M ⊗ P | = | M | + 1. 

Теорема 3.11. Паросочетание является наибольшим тогда и только 

тогда, когда относительно него нет увеличивающих цепей. 

Доказательство.  Если  есть  увеличивающая  цепь,  то,  поступая  так, 
как в рассмотренном примере, то есть, заменяя вдоль этой цепи сильные 
ребра на слабые и наоборот, мы, очевидно, получим большее паросочета-
ние. Для доказательства обратного утверждения рассмотрим паросочета-
ние М в графе G и предположим, что М не наибольшее. Покажем, что то-
гда  имеется  увеличивающая  цепь  относительно  М.  Пусть  М  ′  –  другое 
паросочетание и | М ′ | > | М |. Рассмотрим подграф Н графа G, образован-
ный  теми  ребрами,  которые  входят  в  одно  и  только  в  одно  из  паросо-
четаний M, M ′. Иначе говоря, множеством ребер графа Н является сим-
метрическая разность М ⊗ М ′. В графе Н каждая вершина инцидентна не 
более чем двум ребрам (одному из М и одному из М ′), то есть имеет сте-
пень не более двух. В таком графе каждая компонента связности – путь 
или цикл. В каждом из этих путей и циклов чередуются ребра из М и М ′. 
Так как | М ′ | > | М |, то имеется компонента, в которой ребер из М ′ содер-
жится больше, чем ребер из М. Это может быть только путь, у которого 

 

95

оба концевых ребра принадлежат М ′. Легко видеть, что относительно М 
этот путь будет увеличивающей цепью (cid:0). 

Для  решения  задачи  о  паросочетании  остается  научиться  находить 
увеличивающие цепи или убеждаться, что таких цепей нет. Тогда, начи-
ная с любого паросочетания (можно и с пустого множества ребер), можем 
строить  паросочетания  со  все  увеличивающимся  количеством  ребер  до 
тех пор, пока не получим такое, относительно которого нет увеличиваю-
щих цепей. Оно и будет наибольшим. Известны эффективные алгоритмы, 
которые ищут увеличивающие цепи для произвольных графов. Рассмот-
рим сначала более простой алгоритм, решающий эту задачу для двудоль-
ных графов. 

 

 

3.2.3. Паросочетания в двудольных графах 
Пусть G = (A, B, E) – двудольный граф c долями A и B, М – паросоче-
тание  в  G.  Всякая  увеличивающая  цепь,  если  такая  имеется,  соединяет 
вершину из множества A с вершиной из множества B. 

Зафиксируем некоторую свободную вершину a ∈ A. Мы хотим найти 
увеличивающий путь, начинающийся в a, либо убедиться в том, что таких 
путей нет. Оказывается, нет необходимости рассматривать все чередую-
щиеся пути, начинающиеся в вершине a для того, чтобы установить, ка-
кие вершины достижимы из вершины a чередующимися путями.  

Вершину x назовем четной или нечетной в зависимости от того, четно 
или нечетно расстояние между нею и вершиной a. Так как граф двудоль-
ный, то любой путь, соединяющий вершину a с четной (нечетной) верши-
ной, имеет четную (нечетную) длину. Поэтому в чередующемся пути, ве-
дущем из вершины a в четную (нечетную) вершину, последнее ребро обя-
зательно сильное (слабое). 

Определим дерево достижимости как максимальное дерево с корнем 
a, в котором каждый путь, начинающийся в корне, является чередующим-
ся. Дерево достижимости определено не однозначно, но любое такое де-
рево в двудольном графе обладает следующим свойством. 

Лемма 3.12. Вершина x принадлежит дереву достижимости тогда и 
только тогда, когда существует чередующийся путь, соединяющий вер-
шины a и x. 

Доказательство.  Рассмотрим  некоторое  дерево  достижимости  T  и 
докажем, что всякая вершина x, достижимая из вершины a чередующимся 
путем,  принадлежит  этому  дереву.  Проведем  индукцию  по  длине  крат-
чайшего чередующегося пути из a в x. Пусть y – предпоследняя (то есть 
предшествующая x) вершина такого пути. По предположению индукции, 

96

 

вершина  y  принадлежит  дереву  T.  Если  она  четная,  то  любой  чередую-
щийся  путь  из  вершины  a  в  вершину  y  заканчивается  сильным  ребром. 
Следовательно, в дереве T вершину y c ее отцом соединяет сильное ребро, 
а ребро (x, y) – слабое. Поэтому, если добавить к дереву вершину x и реб-
ро (x, y), то путь в дереве, соединяющий a с x, будет чередующимся. Зна-
чит, если предположить, что дерево T не содержит вершину x, то окажет-
ся, что оно не максимально, а это противоречит определению. Аналогич-
но рассматривается случай, когда вершина y нечетная (cid:0). 

Итак,  для  решения  задачи  остается  научиться  строить  дерево  дости-
жимости.  Для  этого  можно  использовать  слегка  модифицированный  по-
иск в ширину из вершины a. Отличие от стандартного поиска в ширину 
состоит в том, что открываемые вершины классифицируются на четные и 
нечетные. Для четных вершин исследуются инцидентные им слабые реб-
ра, а для нечетных – сильные. Через V(x), как обычно, обозначается мно-
жество  вершин,  смежных  с  вершиной x, Q – очередь, используемая при 
поиске в ширину. Если вершина x не является свободной, то есть инци-
дентна некоторому сильному ребру, то другая вершина этого ребра обо-
значается через p(x). 

then if вершина x не свободная 

x ⇐ Q 
if вершина x нечетная  

Алгоритм 8. Построение дерева достижимости.  
1  объявить все вершины новыми 
2  объявить вершину a четной 
3  a ⇒ Q 
4   создать дерево T из одной вершины a 
5  while  Q ≠ ∅ do 
6 
7  
8  
9  
10  
11  
12  
13  
14   
15  
16 
17 
Если  очередная  рассматриваемая  вершина  x  оказывается  свободной 
(это  выясняется  при  проверке  в  строке  8),  нет  необходимости  доводить 

then y := p(x) 
y ⇒ Q  
объявить вершину y четной 
добавить к дереву T вершину y и ребро (x, y)  

объявить вершину y нечетной 
добавить к T вершину y и ребро (x, y)  

else for y ∈ V(x) do 

if вершина y новая  

 

then y ⇒ Q 

 

 

97

построение дерева до конца. В этом случае путь между вершинами a и x в 
дереве является увеличивающим путем и можно его использовать для по-
строения большего паросочетания. После этого снова выбирается свобод-
ная  вершина  (если  такая  еще  есть)  и  строится  дерево  достижимости.  В 
приведенном  тексте  алгоритма  соответствующий  выход  отсутствует,  но 
его легко предусмотреть, добавив ветвь else к оператору if в строке 8. 

Если дерево построено и в нем нет других свободных вершин, кроме 
корня, то нужно выбрать другую свободную вершину и построить дерево 
достижимости  для  нее  (конечно,  если  в  графе  больше  двух  свободных 
вершин). При этом, как показывает следующая лемма, вершины первого 
дерева можно удалить из графа. 

Лемма  3.13.  Если  дерево  достижимости  содержит  хотя  бы  одну 

вершину увеличивающего пути, то оно содержит увеличивающий путь. 

Доказательство.  Пусть  дерево  достижимости  T  с  корнем  a  имеет 
общие  вершины  с  увеличивающим  путем  P,  соединяющим  свободные 
вершины b и c. Покажем, что в T есть увеличивающий путь (это не обяза-
тельно  путь  P).  Достаточно  доказать,  что  хотя  бы  одна  из  вершин  b,  c 
принадлежит дереву T. Если одна из них совпадает с вершиной a, то из 
леммы 3.12 следует, что и другая принадлежит дереву, так что в этом слу-
чае в дереве имеется увеличивающий путь между вершинами b и c. До-
пустим, обе вершины b и c отличны от a. Пусть R – простой путь, начи-
нающийся в вершине a, заканчивающийся в вершине x, принадлежащей 
пути  P,  и  не  содержащий  других  вершин  пути  P.  Очевидно,  последнее 
ребро пути R слабое. Вершина x делит путь P на два отрезка, Pb и Pc, со-
держащие соответственно вершины b и c. В одном из этих отрезков, ска-
жем,  в  Pb,  ребро,  инцидентное  вершине  x,  сильное.  Тогда  объединение 
путей R и Pb образует чередующийся путь, соединяющий вершины a и b. 
По лемме 3.12, вершина b принадлежит дереву T (cid:0). 

Из этой леммы следует, что если полностью построенное дерево дос-
тижимости  не  содержит  других  свободных  вершин,  кроме  корня,  то  ни 
одна  вершина  этого  дерева  не  принадлежит  никакому  увеличивающему 
пути. Поэтому, приступая к построению следующего дерева достижимо-
сти, вершины первого дерева можно удалить из графа (временно, конеч-
но).  Этот  процесс  –  построение  деревьев  достижимости  и  удаление  их 
вершин из графа – продолжается до тех пор, пока либо будет найден уве-
личивающий путь, либо останется граф с не более чем одной свободной 
вершиной.  В  первом  случае  паросочетание  увеличивается,  граф  восста-
навливается, и вновь начинается поиск увеличивающего пути. Во втором 
случае имеющееся паросочетание является наибольшим.  

98

 

 

Так как при поиске в ширину каждое ребро исследуется не более чем 
дважды, то общее время поиска увеличивающего пути для данного паро-
сочетания есть O(m). Число ребер в паросочетании не может превышать 
n/2, поэтому общая сложность алгоритма будет O(mn). 

 

3.2.4. Паросочетания в произвольных графах (алгоритм Эдмондса) 
Для  графа,  не  являющегося  двудольным,  утверждение  леммы  3.12 
может  быть  неверным.  Пример  этого  показан  на  рис.  3.7.  В  графе,  изо-
браженном слева, с паросочетанием из двух ребер, имеется увеличиваю-
щий путь 5, 3, 1, 2, 4, 6. Справа показано дерево достижимости, построен-
ное для вершины 5. Вершина 6 не вошла в это дерево, хотя имеется чере-
дующийся  путь,  соединяющий  ее  с  вершиной  5.  В  результате  увеличи-
вающий  путь  не  будет  найден.  Причина  этого  –  наличие  в  графе  ребра 
(1,2), соединяющего вершины, находящиеся на одинаковом расстоянии от 
корня дерева. В тот момент, когда исследуется это ребро, обе вершины 1 и 
2 уже присутствуют в дереве, поэтому построение дерева заканчивается. 
Наличие такого ребра означает, что в графе есть нечетный цикл, и это яв-
ляется настоящей причиной неудачи. 

Тем не менее, и для графов с нечетными циклами задачу о наиболь-
шем паросочетании можно решать эффективно. Рассмотрим алгоритм по-
строения наибольшего паросочетания в произвольном графе, предложен-
ный Эдмондсом. 

Сначала, как и в случае двудольного графа, методом поиска в ширину 
строится дерево достижимости для некоторой свободной вершины a. По-
строение  дерева  для  двудольного  графа  прекращалось,  если  к  дереву 
нельзя было добавить ни одной вершины, либо если к нему добавлялась 
свободная  вершина,  то  есть  обнаруживалось  наличие  увеличивающего 
пути. Для произвольного графа будем прекращать построение дерева еще 
в  том  случае,  когда  исследуемое  ребро  соединяет  две  четные  вершины 
дерева. При поиске в ширину это может быть только тогда, когда эти два 

 

99

 
 
 
 
 
 
 
 

 

 

1

3

5

2

4

6

Рис. 3.7 

1

3

2

4

5

вершины  находятся  на  одинаковом  расстоянии  от  корня.  Обнаружение 
такого  ребра  означает,  что  найден  подграф,  называемый  цветком  (рис. 
3.8). Он состоит из чередующегося пути P, соединяющего корень дерева a 
с некоторой вершиной b, и нечетного цикла C, При этом b является един-
ственной  общей  вершиной  пути P и цикла C, а C можно рассматривать 
как замкнутый чередующийся путь, начинающийся и заканчивающийся в 
вершине b. На рисунке показаны также смежные четные вершины x и y, 
находящиеся на одинаковом расстоянии от вершины a.  
 
 
 
 
 
 

C

P

b

a

x

y

 

 

Рис. 3.8 

Выявление цветков не представляет трудности – нужно только доба-
вить  ветвь  else  к  оператору  if  в  строке  14  алгоритма  8.  Первое,  что  мы 
сделаем, обнаружив цветок, – превратим все сильные ребра пути P в сла-
бые, а слабые – в сильные. После этого преобразования множество силь-
ных ребер является паросочетанием той же мощности, но вместо вершины 
a свободной вершиной станет вершина b. Таким образом, на цикле C бу-
дет одна свободная вершина и этот цикл является чередующимся путем, 
начинающимся и заканчивающимся в этой вершине. Покажем, что такой 
цикл можно стянуть в одну вершину, не теряя информации о существова-
нии увеличивающих путей. 

Операция стягивания подграфа H в графе G состоит в следующем. Все 
вершины  этого  подграфа  удаляются  из  графа,  а  вместо  них  добавляется 
новая вершина. Эта новая вершина соединяется ребрами с теми и только 
теми из оставшихся вершин графа, которые были смежны хотя бы с одной 
вершиной  подграфа  H.  Граф,  получаемый  в  результате  такой  операции, 
будем обозначать через G/H. 

Теорема 3.14. Пусть M – паросочетание в графе G, С – цикл длины   
2k + 1  в этом графе, причем на цикле имеется k сильных ребер и одна 
свободная вершина. Пусть M′ – паросочетание в графе G′ = G/C, состав-
ленное из всех ребер паросочетания M, не принадлежащих циклу C. Паро-
сочетание M является наибольшим в графе G тогда и только тогда, ко-
гда M′ – наибольшее паросочетание в графе G′. 

Доказательство.  Докажем,  что  из  существования  увеличивающего 
пути  относительно  паросочетания M  в  графе G следует, что существует 

100

 

увеличивающий путь относительно паросочетания M′ в графе G′ и обрат-
но. 

Пусть b – свободная вершина цикла C. Новую вершину, образованную 
в графе G′ при стягивании цикла C, обозначим через c. Отметим, что она 
является свободной вершиной относительно паросочетания M′.  

Пусть P – увеличивающий путь в графе G. Если он не содержит вер-
шин цикла C, то он будет увеличивающим путем и в графе G′. В против-
ном  случае  рассмотрим  отрезок  P′  пути  P,  начинающийся  в  свободной 
вершине, отличной от b, заканчивающийся в вершине x, лежащей на цик-
ле C, и не содержащий других вершин цикла C. Если в пути P′ заменить 
вершину x  вершиной c,  то,  очевидно,  получится  увеличивающий  путь  в 
графе G′. 

Обратно, пусть P′ – увеличивающий путь в графе G′. Если P′ не про-
ходит через вершину c, то он будет увеличивающим путем и в графе G. В 
противном случае рассмотрим путь P″, получающийся удалением верши-
ны c из пути P′. Можно считать, что вершина c была последней вершиной 
пути  P′,  а  путь  P″  заканчивается  в  предпоследней  вершине  x.  Так  как 
вершина x смежна с вершиной c в графе G′, то в графе G на цикле C име-
ется вершина y, смежная с x. Добавим к пути P″ тот из отрезков цикла C, 
соединяющих  вершину  y  с  вершиной  b,  который  начинается  сильным 
ребром. В результате получится увеличивающий путь в графе G (cid:0). 

Из доказательства видно, что увеличивающий путь в графе G при из-
вестном  увеличивающем  пути  в  графе  G′  находится  за  линейное  время. 
Для получения оценок времени работы алгоритма в целом требуется еще 
проработка ряда деталей, например, подробностей выполнения операции 
стягивания и т.д. Однако ясно, что это время ограничено полиномом. 
 

3.4. Оптимальные каркасы 

 

 

3.4.1. Задача об оптимальном каркасе и алгоритм Прима 
Задача об оптимальном каркасе (стягивающем дереве) состоит в сле-
дующем. Дан обыкновенный граф G = (V, E) и весовая функция на мно-
жестве ребер w: V → R. Вес множества X ⊆ E определяется как сумма ве-
сов  составляющих  его  ребер.  Требуется  в  графе  G  найти  каркас  макси-
мального веса. Обычно рассматривают задачу на минимум, но это не су-
щественно  –  она  преобразуется  в  задачу  на  максимум,  если  заменить 
функцию w на –w. В этом разделе будем предполагать, что граф G связен, 
так что решением задачи всегда будет дерево. Для решения задачи об оп-

 

101

тимальном  каркасе  известно  несколько  алгоритмов.  Рассмотрим  два  из 
них. 

В  алгоритме  Прима  на  каждом  шаге  рассматривается  частичное  ре-
шение задачи, представляющее собой дерево. Вначале это дерево состоит 
из единственной вершины, в качестве этой вершины может быть выбрана 
любая вершина графа. Затем к дереву последовательно добавляются ребра 
и вершины, пока не получится остовное дерево, то есть каркас. Для того, 
чтобы из текущего дерева при добавлении нового ребра опять получилось 
дерево,  это  новое  ребро  должно  соединять  вершину  дерева  с  вершиной, 
еще не принадлежащей дереву. Такие ребра будем называть подходящими 
относительно рассматриваемого дерева. В алгоритме Прима применяется 
следующее  правило  выбора:  на  каждом  шаге  из  всех  подходящих  ребер 
выбирается ребро наименьшего веса. Это ребро вместе с одно новой вер-
шиной  добавляется  к  дереву.  Если  обозначить  через  U  и  F  множества 
вершин и ребер строящегося дерева, а через W множество вершин, еще не 
вошедших в это дерево, то алгоритм Прима можно представить следую-
щим образом. 

Алгоритм 9. Построение оптимального каркаса методом Прима 
1  U := {a}, где a – произвольная вершина графа 
2  F := ∅ 
3  W := V – {a} 
4  while  W ≠ ∅  do 
5 

найти ребро наибольшего веса e = (x, y) среди всех таких  

 

  ребер, у которых x ∈ U, y ∈ W  

 
 
 

F := F ∪ {e} 
U := U ∪ {y} 
W := W – {y} 

6 
7 
8 
Докажем,  что  алгоритм  Прима  действительно  находит  оптимальный 
каркас. Дерево F назовем фрагментом, если существует такой оптималь-
ный каркас T0 графа G, что F является подграфом дерева T0. Иначе гово-
ря,  фрагмент  –  это  дерево,  которое  можно  достроить  до  оптимального 
каркаса. 
Теорема 3.15. Если F – фрагмент, e – подходящее ребро наибольшего 

веса относительно F, то F ∪ {e} – фрагмент. 

Доказательство.  Пусть  T0  –  оптимальный  каркас,  содержащий  F  в 
качестве подграфа. Если ребро е принадлежит T0, то F ∪ {e} – подграф T0 
и, следовательно, фрагмент. Допустим, е не принадлежит T0. Если доба-
вить ребро е к дереву T0, то образуется цикл. В этом цикле есть еще хотя 

 

 

 

102

 

)

e

e

T
0

T
=′
0

Tw
(
0

+′−

. Но T

0 – оптимальный каркас, следовательно, 

бы одно подходящее ребро относительно F (никакой цикл, очевидно, не 
может содержать единственное подходящее ребро). Пусть e′ – такое реб-
, получающийся из T0 удалением ребра e′ 
ро. Тогда подграф 
и  добавлением  ребра  е,  тоже  будет  деревом.  Так  как  w(e′)  ≤  w(e),  то 
Tw
)
(
)
≥′
 
0
0T′
 – тоже оптимальный каркас. Но F ∪ {e} является подграфом графа 
и 
0T′
 и, следовательно, фрагментом (cid:0). 
Дерево,  состоящее  из  единственной  вершины,  очевидно,  является 
фрагментом. Из теоремы 3.12 следует, что если после некоторого количе-
ства шагов алгоритма Прима дерево F является фрагментом, то оно будет 
фрагментом  и  после  следующего  шага.  Следовательно,  и  окончательное 
решение,  полученное  алгоритмом,  будет  фрагментом,  то  есть  оптималь-
ным каркасом. 

Tw
)
(
=′
0

Tw
(
0

Оценим время работы алгоритма Прима. Цикл while в строке 4 повто-
ряется один раз для каждой вершины графа, кроме стартовой. Внутри это-
го цикла есть еще скрытый цикл в строке 5, где ищется ребро наибольше-
го веса среди всех ребер, соединяющих вершины из множества U с вер-
шинами из W. Допустим, что этот поиск производится самым бесхитрост-
ным образом, то есть просматриваются все пары вершин (x, y) с x ∈ U,     
y ∈ W. Если | U | = k, то имеется k(n – k) таких пар. Так как k меняется от    
1 до n – 1, то всего получаем  
1
−

1
−

1
−

n

n

n

3

 

knk
(
−

)

=

∑

k

1
=

n

∑ ∑

−

k

2

n

=

k

1
=

k

1
=

−

)1

(

n

−

−

nn
(
2
2

nn
2()1
6

−

)1

n

=

n

 

−
6

пар, которые нужно рассмотреть. Таким образом, трудоемкость алгоритма 
будет O(n3). 

Небольшое  усовершенствование позволяет на порядок ускорить этот 
алгоритм. Допустим, что для каждой вершины y из множества W известна 
такая вершина b(y) ∈ U, что 
. Тогда при | U | = k 
необходимо будет выбрать ребро наибольшего веса среди n – k ребер, а 
общее число анализируемых ребер будет равно  

yybw
),
((

yxw
,(

max
Ux∈

=

)

)

 

 

n

1
−

∑

k

1
=

(

kn
−

)

=

)1

nn
(
−
2

. 

 

В этом случае, однако, необходимы дополнительные действия для об-
новления таблицы значений функции b при добавлении одной вершины к 
дереву, то есть при переносе одной вершины из множества W во множест-

 

103

во U. Сначала, когда множество U состоит из единственной вершины a, 
полагаем b(x) = a для всех x ∈ W. В дальнейшем эти значения могут ме-
няться. Допустим, на некотором шаге к дереву присоединяется вершина y. 
Тогда для каждой вершины z ∈ W либо сохраняется старое значение b(z), 
либо устанавливается новое b(z) = y, в зависимости от того, какое из ребер 
(b(z),  z)  и  (y,  z)  имеет  больший  вес.  Иначе  говоря,  для  модификации 
функции  b  достаточно  в  алгоритме  9  после  строки  8  (и  внутри  цикла 
while) добавить следующее: 
for  z ∈ W  do 
 

9 
 
10   
 При | U | = k цикл в строке 9 повторяется n – k раз. Таким образом, до-
полнительное  время,  необходимое  для  обслуживания  таблицы  b,  тоже 
оценивается сверху квадратичной функцией от n и общая оценка трудо-
емкости усовершенствованного алгоритма Прима будет O(n2). 

if  w(b(z), z) < w(y, z)  then  b(z) := y  

 

 

Другой  путь  к  усовершенствованию  алгоритма  Прима  подсказывает 
следующее замечание. При выборе подходящего ребра (в строке 5 алго-
ритма 9) можно рассматривать не все пары (x, y) ∈ U × W, а только те, 
которые являются ребрами графа. Если граф разреженный, то есть содер-
жит много меньше ребер, чем полный граф, то это может значительно ус-
корить решение задачи. Дополнительный выигрыш можно получить, если 
использовать приоритетную очередь для хранения множества ребер, под-
лежащих исследованию (упражнение 5). 

 

3.4.2. Алгоритм Краскала 
Другой жадный алгоритм для задачи об оптимальном каркасе известен 
как алгоритм Краскала. В нем тоже на каждом шаге рассматривается час-
тичное решение. Отличие от алгоритма Прима состоит в том, что в алго-
ритме Краскала частичное решение всегда представляет собой остовный 
лес F графа G, то есть лес, состоящий из всех вершин графа G и некото-
рых его ребер. Вначале F не содержит ни одного ребра, то есть состоит из 
изолированных вершин. Затем к нему последовательно добавляются реб-
ра, пока не будет построен каркас графа G. Пусть F – лес, построенный к 
очередному  шагу.  Ребро  графа,  не  принадлежащее  F,  назовем  красным, 
если вершины этого ребра принадлежат одной компоненте связности леса 
F, и зеленым, если они принадлежат разным компонентам. Если к F доба-
вить  красное  ребро,  то  образуется  цикл.  Если  же  к  F  добавить  зеленое 
ребро, то получится новый лес, в котором будет на одну компоненту связ-
ности меньше, чем в F, так как в результате добавления ребра две компо-

104

 

ненты  сольются  в  одну.  Таким  образом,  к  F  нельзя  добавить  никакое 
красное ребро и можно добавить любое зеленое. Для выбора добавляемо-
го ребра применяется тот же жадный принцип, что и в алгоритме Прима – 
из всех зеленых ребер выбирается ребро наибольшего веса. Для того, что-
бы облегчить поиск этого ребра, вначале все ребра графа упорядочивают-
ся по убыванию весов: w(e1) ≥ w(e2) ≥ … ≥  w(em). Теперь последователь-
ность ребер e1, e2, …, em достаточно просмотреть один раз и для очеред-
ного рассматриваемого ребра нужно только уметь определять, является ли 
оно  красным  или  зеленым  относительно  построенного  к  этому  моменту 
леса F. Красные ребра просто пропускаются, а зеленые добавляются к F. 

Для более формального описания алгоритма заметим, что текущий лес 
F  определяет  разбиение  множества  вершин  графа  на  области  связности 
этого леса: V = P1 ∪ P2 ∪ … ∪ Pk, и что красное ребро – это такое, у ко-
торого обе вершины принадлежат одной части разбиения. Пусть Part(x) – 
функция, возвращающая для каждой вершины х имя той части разбиения, 
которой принадлежит х, а Unite(x, y) – процедура, которая по именам х и y 
двух частей разбиения строит новое разбиение, заменяя эти две части их 
объединением. Пусть ei = (ai, bi), i = 1, …, m. Тогда алгоритм Краскала 
(после упомянутого упорядочения ребер) можно записать следующим об-
разом. 

for  i := 1  to  m  do 

Алгоритм 10. Построение оптимального каркаса методом Краскала  
1 
 
2 
3 
Более подробно алгоритм Краскала рассматривается в разделе «Разде-
ленные множества». Корректность этого алгоритма следует из общей тео-
ремы Радо – Эдмондса, которая будет рассмотрена в следующем разделе. 

if  x ≠ y  then {F := F ∪ {ei}, Unite(x, y)} 

x := Part(ai)  
y := Part(bi) 
 

 

 

3.5. Жадные алгоритмы и матроиды 

Жадными  (градиентными)  называют  алгоритмы,  действующие  по 
принципу: максимальный выигрыш на каждом шаге. Такая стратегия не 
всегда  ведет  к  конечному  успеху  –  иногда  выгоднее  сделать  не  наилуч-
ший, казалось бы, выбор на очередном шаге с тем, чтобы в итоге полу-
чить оптимальное решение. Но для некоторых задач применение жадных 
алгоритмов оказывается оправданным. Одной из самых известных задач 
такого рода является задача об оптимальном каркасе. Существует общая 
теория,  обосновывающая  применимость  жадных  алгоритмов  к  задачам 
определенного  типа.  В  этом  разделе  будут  рассмотрены  классические 

 

105

примеры  жадных  алгоритмов  для  задачи  об  оптимальном  каркасе  и  дан 
набросок  общей  теории  жадных  алгоритмов.  Затем  будет  рассмотрено 
применение  жадного  алгоритма  в  сочетании  с  методом  увеличивающих 
цепей для решения задачи о паросочетании наибольшего веса в двудоль-
ном графе со взвешенными вершинами. 

 

 

3.5.1. Матроиды 
Когда возник вопрос о том, каковы обстоятельства, при которых жад-
ный алгоритм приводит к успеху, или иначе – что особенного в тех зада-
чах,  для  которых  он  дает  точное  решение,  –  оказалось,  что  математиче-
ская теория, с помощью которой что-то в этом можно прояснить, уже су-
ществует. Это теория матроидов, основы которой были заложены Уитни в 
работе 1935 г. Целью создания теории матроидов было изучение комби-
наторного аспекта линейной независимости, в дальнейшем обнаружились 
разнообразные  применения  понятия  матроида,  первоначально  совсем  не 
имевшиеся в виду. 

Определение. Матроидом называется пара M = (E, Φ), где Е – конеч-
ное непустое множество, Φ – семейство подмножеств множества Е, удов-
летворяющее условиям: 

(1) если X ∈ Φ и Y ⊆ X, то Y ∈ Φ; 
(2) если X ∈ Φ, Y ∈ Φ и | X | < | Y |, то существует такой элемент a ∈ Y – 

X, что X ∪ (a) ∈ Φ. 

Элементы множества Е называются элементами матроида, а множе-
ства  из  семейства  Φ  –  независимыми  множествами  матроида.  Макси-
мальное по включению независимое множество называют базой матрои-
да. Из аксиомы (2) следует, что все базы матроида состоят из одинакового 
количества элементов. 

Если  Е  –  множество  строк  некоторой  матрицы,  а  Φ  состоит  из  всех 
линейно независимых множеств строк этой матрицы, то пара (E, Φ) обра-
зует матроид, называемый матричным матроидом.  

Другим  важным  типом  матроидов  являются  графовые  матроиды. 
Пусть G = (V, E) – обыкновенный граф. Подмножество множества Е назо-
вем ациклическим, если подграф, образованный ребрами этого подмноже-
ства, не содержит циклов, то есть является лесом. 

Теорема 3.16. Если G = (V, E) – обыкновенный граф, Φ – семейство 
всех ациклических подмножеств множества Е, то пара MG = (E, Φ) яв-
ляется матроидом. 

Доказательство. Аксиома (1) выполняется, так как всякое подмноже-
ство ациклического множества, очевидно, является ациклическим. Дока-

106

 

жем, что выполняется и (2). Пусть Х и Y – два ациклических множества и  
| X | < | Y |. Допустим, что не существует такого ребра e ∈ Y, что множество 
X ∪ {e} является ациклическим. Тогда при добавлении любого ребра из 
множества Y к множеству X образуется цикл. Это означает, что концы ка-
ждого такого ребра принадлежат одной компоненте связности остовного 
подграфа,  образованного  ребрами  множества  Y.  Тогда  каждая  область 
связности подграфа Х содержится в какой-нибудь области связности под-
графа Y. Но компоненты связности каждого из этих подграфов – деревья, 
а  дерево  с  к  вершинами  содержит  ровно  k  –  1  ребер.  Следовательно,  в 
этом случае число ребер в Y не превосходило бы числа ребер в Х, что про-
тиворечит условию | X | < | Y | (cid:0). 

Базами графового матроида являются все каркасы графа. Для связного 

графа это будут все его остовные деревья. 
 

 

3.5.2. Теорема Радо – Эдмондса 
Рассмотрим общий тип оптимизационных задач, формулируемых сле-
дующим образом. Дано произвольное конечное множество Е и некоторое 
семейство Φ его подмножеств. Для каждого элемента x ∈ E задан его вес 
– положительное число w(x). Вес множества x ⊆ E  определяется как сум-
ма  весов  его  элементов.  Требуется  найти  множество  наибольшего  веса, 
принадлежащее Φ. В эту схему укладываются многие известные задачи, 
например, задача о независимом множестве графа (Е – множество вершин 
графа,  вес  каждой  вершины  равен  1,  а  Φ  состоит  из  всех  независимых 
множеств) или задача об оптимальном каркасе (Е – множество ребер гра-
фа, Φ состоит из всех ациклических множеств).  

Сформулируем теперь жадный алгоритм для решения этой общей за-
дачи. Чтобы отличать этот алгоритм от других жадных алгоритмов, назо-
вем его СПО (Сортировка и Последовательный Отбор). 

Алгоритм 11. Алгоритм СПО 
1  Упорядочить элементы множества Е по убыванию весов: E = {e1, 

 

 

e2, …, em}, w(e1) ≥ w(e2) ≥ … ≥ w(em). 

for  i := 1 to  m  do 
if  A ∪ {ei} ∈ Φ  then  A := A ∪ {ei} 

2  A := ∅ 
3 
4 
Алгоритм Краскала является примером алгоритма этого типа. Уместен 
вопрос:  каким  условиям  должно  удовлетворять  семейство  Φ  для  того, 
чтобы при любой весовой функции w алгоритм СПО находил оптималь-

 

 

107

ное решение? Исчерпывающий ответ дает следующая теорема Радо – Эд-
мондса.  

Теорема  3.17.  Если  M  =  (E,  Φ)  –  матроид,  то  для  любой  весовой 
функции w:→ R+ множество А, найденное алгоритмом СПО, будет мно-
жеством  наибольшего  веса  из  Φ.  Если  же  M  =  (E,  Φ)  не  является 
матроидом, то найдется такая функция w:→ R+, что А не будет мно-
жеством наибольшего веса из Φ. 

Доказательство. Предположим, что M = (E, Φ) является матроидом 
и A = {a1, a2, …, an} – множество, построенное алгоритмом СПО, причем 
w(a1) ≥ w(a2) ≥ … ≥ w(an). Очевидно, А является базой матроида. Пусть   
B  =  {b1,  b2,  …,  bk}  –  любое  другое  независимое  множество  и  w(b1)  ≥         
≥ w(b2) ≥ … ≥ w(bk). Так как А – база, то k ≤ n. Покажем, что w(ai) ≥ w(bi) 
для  каждого  i  ∈  {1,  …,  k}.  Действительно,  положим  X  =  {a1,  …,  ai–1},       
Y = {b1, …, bi–1, bi} для некоторого i. Согласно условию (2) определения 
матроида, во множестве Y имеется такой элемент bj, что bj ∉ X и множест-
во X ∪ {bj} – независимое. В соответствии с алгоритмом, элементом наи-
большего веса, который может быть добавлен к X так, чтобы получилось 
независимое множество, является aj. Следовательно, w(ai) ≥ w(bj) ≥ w(bi). 
Теперь предположим, что M = (E, Φ) не является матроидом. Допус-
тим сначала, что нарушается условие (1), то есть существуют такие под-
множества Х  и Y  множества Е,  что X  ∈  Φ, Y  ⊂ X и Y  ∉  Φ. Определим 
функцию w следующим образом: 
  ,1
⎧
⎨
  ,0
⎩

Yx
,
  
если
∈
Yx
  
.
если
∉

xw
)(

=

 

 

Алгоритм СПО сначала будет рассматривать все элементы множества Y. 
Так как Y ∉ Φ, то не все они войдут в построенное алгоритмом множество 
А. Следовательно, w(A) < | Y |. В то же время имеется множество X ∈ Φ 
такое, что w(A) < | Y |. Таким образом, в этом случае алгоритм СПО строит 
не оптимальное множество. Если же условие (1) выполнено, а не выпол-
няется условие (2), то существуют такие подмножества Х и Y множества 
Е, что i = 1, Y ∈ Φ и X ∪ {x} ∉ Φ для каждого X ∈ Y. Выберем такое ε, 
что 0 < ε < | Y | / | X | – 1 и определим функцию w следующим образом: 

xw
)(

=

108

 

1
  ,
ε+
⎧
⎪
        
,1
⎨
⎪
       
,0
⎩

Xx
,
   
если
∈
XYx
   
,
если
−∈
Y
Xx
  
 .
если
∪∉

 

Алгоритм  СПО  сначала  выберет  все  элементы  множества  Х,  а  затем 
отвергнет все элементы из Y – Х. В результате будет построено множество 
А с весом w(A) = (1 + ε)| X | < | Y |, которое не является оптимальным, так 
как W(Y ) = | Y | (cid:0). 

Алгоритм  Краскала  –  это  алгоритм  СПО,  применяемый  к  семейству 
ациклических множеств ребер графа. Из теорем 3.16 и 3.17 следует, что 
он действительно решает задачу об оптимальном каркасе. В то же время 
существует много жадных алгоритмов, не являющихся алгоритмами типа 
СПО. Примером может служить алгоритм Прима. Эти алгоритмы не по-
падают под действие теоремы Радо – Эдмондса, для их обоснования нуж-
на иная аргументация.  

Если для некоторой конкретной задачи удалось установить примени-
мость к ней алгоритма СПО, это не значит, что все проблемы позади. Этот 
алгоритм  внешне  очень  прост,  но  он  включает  операцию  проверки  при-
надлежности множества семейству Φ, эффективное выполнение которой 
может  потребовать  серьезных  дополнительных  усилий.  В  алгоритме 
Краскала, например, для этого применяются специальные структуры дан-
ных. Ниже рассмотрим еще один пример, когда для успешного решения 
задачи  алгоритм  СПО  комбинируется  с  методом  увеличивающих  цепей 
для задачи о паросочетании, рассмотренном в разделе 3.3. 

 

 

3.5.3. Взвешенные паросочетания 
Рассмотрим следующую задачу. Дан двудольный граф G = (A, B, E) и 
для  каждой  вершины  x  ∈  A  задан  положительный  вес  w(x).  Требуется 
найти  такое  паросочетание  в  этом  графе,  чтобы  сумма  весов  вершин  из 
доли А, инцидентных ребрам паросочетания, была максимальной. Эту за-
дачу иногда интерпретируют следующим образом. А – это множество ра-
бот,  а  В  –  множество  работников.  Ребро  в  графе  G  соединяет  вершину       
a ∈ A с вершиной b ∈ B, если квалификация работника b позволяет ему 
выполнить работу а. Каждая работа выполняется одним работником. Вы-
полнение работы а принесет прибыль w(a). Требуется так назначить ра-
ботников на работы, чтобы максимизировать общую прибыль. Покажем, 
что эта задача может быть решена алгоритмом СПО в сочетании с мето-
дом чередующихся цепей. 

Множество X ⊆ A назовем отображаемым, если в графе G существу-
ет  такое  паросочетание  М,  что  каждая  вершина  из  Х  инцидентна  ребру 
этого паросочетания. М в этом случае будем называть отображением для 
Х. Пусть Φ – семейство всех отображаемых множеств. 

 

109

Теорема 3.18. Пара (A, Φ) является матроидом. 
Доказательство.  Условие  (1)  определения  матроида,  очевидно,  вы-
полняется. Докажем, что выполняется и условие (2). Пусть X ∈ Φ, Y ∈ Φ, 
| X | < | Y |. Рассмотрим подграф Н графа G, порожденный всеми вершинами 
из X ∪ Y и всеми смежными с ними вершинами из доли В. Пусть MX – 
отображение для Х, MY  – для Y. Так как MX не является наибольшим па-
росочетанием в графе Н, то по теореме 6 относительно него в этом графе 
существует  увеличивающая  цепь.  Одним  из  концов  этой  цепи  является 
свободная относительно MX вершина a ∈ Y. После увеличения паросоче-
тания MX с использованием этой цепи, как было описано выше, получим 
паросочетание  M′,  отображающее  множество  X  ∪  {a}.  Следовательно,      
X ∪ {a} ∈ Φ (cid:0). 

Даже если бы в задаче требовалось только найти только отображаемое 
множество  наибольшего  веса,  проверка  принадлежности  множества  се-
мейству  Φ  требовала  бы  и  нахождения  соответствующего  отображения, 
то есть паросочетания. На самом же деле построение паросочетания вхо-
дит  в  условие  задачи.  Комбинируя  СПО  с  алгоритмом  поиска  увеличи-
вающих цепей, получаем следующий алгоритм. 

Алгоритм  12.  Построение  паросочетания  наибольшего  веса  в  дву-

дольном графе G = (A, B, E) с заданными весами вершин доли А. 
1  Упорядочить элементы множества А по убыванию весов:  

 

A = {a1, a2, …, ak}, w(a1) ≥ w(a2) ≥ … ≥ w(ak)  

2  X := ∅  
3  M := ∅  
4 
 

for  i =1  to  k  do 

 

 

110

 

if  в G существует увеличивающая цепь Р относительно М,  

 

начинающаяся в вершине ai  

 

then  {X := X ∪ {ai}; M := M ⊗ P}  

 
Если для поиска увеличивающей цепи применить метод поиска в ши-
рину, как описано выше, то время поиска будет пропорционально числу 
ребер. Общая трудоемкость алгоритма будет O(mk), где k – число ребер в 
доле А. 
 

Упражнения 

1.  Реализуйте  описанный  выше  алгоритм  нахождения  наибольшего 
независимого множества на основе поиска в глубину в дереве подзадач и 
модифицированный алгоритм с применением сжатия по включению к ка-

ждой подзадаче. Сравните экспериментально время работы двух алгорит-
мов на случайных графах. 

2. Реализуйте алгоритм нахождения всех максимальных независимых 

множеств на основе поиска в глубину в дереве вариантов. 

3. Разработайте алгоритм поиска поглощающих вершин и нахождения 

наибольшего независимого множества в хордальном графе. 

4. Задан неориентированный граф со взвешенными ребрами и множе-
ство выделенных вершин в нем. Требуется построить лес минимального 
веса, в котором каждая компонента связности содержала бы точно одну из 
выделенных  вершин.  Покажите,  что  эта  задача  сводится  к  построению 
оптимального каркаса. Постройте алгоритм для ее решения (на основе ка-
кого-либо известного алгоритма для задачи об оптимальном каркасе). 

5. Разработайте вариант алгоритма Прима с использованием приори-
тетной очереди, как описано в разделе 3.4. Как оценивается время работы 
этого алгоритма, если для реализации приоритетной очереди используется 
бинарная куча? 

 

111

 

Список литературы к гл. 1-3 
1. А х о ,   А . Построение и анализ вычислительных алгоритмов / А. Ахо, Дж. 

Хопкрофт, Дж. Ульман. – М.: Мир, 1979. –  с. 

2.  А х о ,   А .  Структуры  данных  и  алгоритмы  /  А.  Ахо,  Дж.  Хопкрофт,  Дж. 

Ульман. – М.: Вильямс, 2000. –  с. 

Д. Джонсон. – М.: Мир, 1982. –  с. 

Наука, 1990. –  с. 

3. Г э р и ,   М .  Вычислительные машины и труднорешаемые задачи / М. Гэри, 

4. Е м е л и ч е в   В . А .  Лекции по теории графов / В.А. Емеличев и др. – М.: 

5. К о р м е н ,   Т .  Алгоритмы. Построение и анализ / Т. Кормен, Ч. Лейзер, Р. 

Ривест. МЦНМО, Москва, 1999. –  с. 

стофидес. – М.: Мир, 1978. –  с. 

6. К р и с т о ф и д е с ,   Н .  Теория графов. Алгоритмический подход / Н. Кри-

7. Л о в а с ,   Л .  Прикладные задачи теории графов / Л. Ловас, М. Пламмер. – 

8.  Л и п с к и й ,   В .  Комбинаторика  для  программистов  /  В.  Липский.  –  М.: 

М.: Мир, 1998. –  с. 

Мир, 1988. –  с. 

9. Н о в и к о в ,   Ф . А .  Дискретная математика для программистов / Ф. А. Но-

10. Р е й н г о л ь д   Э .  Комбинаторные алгоритмы / Э. Рейнгольд, Ю. Нивер-

виков. – СПб.: Питер, 2001. –  с. 

гельт, Н. Део. – М.: Мир, 1980. – с. 

 

112

 

 
 
 

 

 

Оглавление 

 

 

 
Предисловие 
Часть 1.  .....................................................................................................................  
Глава 1.  Модели вычислений  ......................................................................................  
 
1.1. Исторические сведения ..........................................................................  
1.2. Тьюрингова модель переработки информации  ...................................  
 
1.2.1. Алгебра программ  ........................................................................  
 
 
 
 
1.2.2. Начальное математическое обеспечение ....................................  
 
1.3. Методика доказательства правильности программ .............................  
1.4. Вычислимость и разрешимость .............................................................  
 
1.5. Вычисление числовых функций ............................................................  
 
1.6. Частично-рекурсивные функции ...........................................................  
 
 
1.7. Универсальная тьюрингова программа ................................................  
1.8. Пример невычислимой функции ...........................................................  
 
1.9. Об измерении алгоритмической сложности задач  ..............................  
 
1.10. Абак ........................................................................................................  
 
1.11. Пример функции не вычислимой на абаке .........................................  
 
 
1.12. Проблема самоприменимости ..............................................................  
1.13. Алгорифмы Маркова  ............................................................................  
 
1.14. Модель вычислений с косвенной адресацией (РАМ – машина) .......  
 
Глава 2.  Теория сложности задач и аогоритмов  ........................................................  
2.1. Проблема P = NP? ...................................................................................  
 
 
2.2. Определения (по Карпу)  ........................................................................  
Глава 3.  Амортизационный анализ  .............................................................................  
3.1. Классы функций, используемые для оценки сложности алгоритмов   
3.2. Амортизационный анализ ......................................................................  
3.3. Примеры получения амортизационных оценок ...................................  
3.3.1. Двоичный счетчик  ........................................................................  
 
 
3.3.2. Стек с тремя операциями .............................................................  
Упражнения к гл. 3 .........................................................................................  
Глава 4.  Структуры данных  .........................................................................................  
4.1. Введение ..................................................................................................  
 
 
4.2. Списки  .....................................................................................................  
4.2.1. Общие сведения о списках  ..........................................................  
 
 
4.2.2. Списки с прямым доступом .........................................................  
 
 
 
 
4.2.3. Списки с последовательным доступом  ......................................  

 
 
 
 
 
 

 

 

113

 

 
 

4.2.4. Некоторые дополнительные операции со связными списками   
 
4.2.5.  Моделирование  списков  с  последовательным  доступом  при 
 
помощи массивов  ...........................................................................................................  
 
4.2.6. Деревья и графы ............................................................................  
Глава 5.  Разделенные множества  ................................................................................  
5.1. Операции над разделенными множествами .........................................  
 
 
5.2. Примеры использования разделенных множеств ................................  
 
5.2.1. Алгоритм выделения компонент связности  
неориентированного графа ............................................................................................  
5.2.2. Алгоритм Краскала .......................................................................  
5.3. Представление разделенных множеств с помощью массива  .............  
5.3.1. Реализация операций с помощью массива .................................  
 

 
 
 

Представление разделенных множеств с помощью  

древовидной структуры ..........................................................................................  
 
5.4.1. Реализация операций с помощью древовидной структуры ......  

 
5.5. Представление разделенных множеств с использованием рангов 

 

вершин    
 

 

 

 

 
 

5.6.1. Реализация операций c использованием рангов вершин и  

 
5.5.1. Реализация операций с использованием рангов вершин  ..........  
 
5.6. Представление  разделенных  множеств  с  использованием  рангов 
вершин и сжатия путей ..................................................................................................  
 
сжатия путей ...................................................................................................................  
Глава 6.  Приоритетные очереди ..................................................................................  
6.1. Основные определения  ..........................................................................  
 
6.2. Представление приоритетной очереди с помощью d-кучи .................  
Часть 2.  .....................................................................................................................  
Глава 1.  Введение в теорию графов  ............................................................................  
1.1. Начальные понятия  ................................................................................  
 
1.1.1. Определение графа .......................................................................  
 
 
1.1.2. Графы и бинарные отношения  ....................................................  
1.1.3. Откуда берутся графы ..................................................................  
 
1.1.4. Число графов .................................................................................  
 
1.1.5. Смежность, инцидентность, степени ..........................................  
 
 
1.1.6. Некоторые специальные графы ...................................................  
1.1.7. Графы и матрицы ..........................................................................  
 
1.1.8. Взвешенные графы .......................................................................  
 
1.2. Изоморфизм  ............................................................................................  
 
 
1.2.1. Определение изоморфизма ..........................................................  
1.2.2. Инварианты ...................................................................................  
 
1.3. Операции над графами ...........................................................................  
1.3.1. Локальные операции  ....................................................................  
1.3.2. Подграфы  ......................................................................................  

 
 
 

114

 

 

 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 

1.3.3. Алгебраические операции  ...........................................................  
1.4. Маршруты, связность, расстояния.........................................................  
1.4.1. Маршруты, пути, циклы  ..............................................................  
1.4.2. Связность и компоненты ..............................................................  
1.4.3. Метрические характеристики графов .........................................  
1.4.4. Маршруты и связность в орграфах  .............................................  
1.5. Деревья  ....................................................................................................  
1.5.1. Определение и элементарные свойства ......................................  
1.5.2. Центр дерева  .................................................................................  
1.5.3. Корневые деревья  .........................................................................  
1.5.4. Каркасы  .........................................................................................  
1.6. Двудольные графы  .................................................................................  
1.7. Планарные графы  ...................................................................................  
 
1.8. Наследственные классы  .........................................................................  
 
Глава 2.  Анализ графов  ................................................................................................  
2.1. Поиск в ширину ......................................................................................  
2.1.1. Метод поиска в ширину ...............................................................  
2.1.2. BFS-дерево и вычисление расстояний ........................................  
2.2. Поиск в глубину ......................................................................................  
2.2.1. Метод поиска в глубину  ..............................................................  
2.2.2. DFS-дерево ....................................................................................  
2.2.3. Другие варианты алгоритма поиска в глубину ..........................  
2.2.4. Шарниры  .......................................................................................  
2.3. Блоки ........................................................................................................  
2.3.1. Двусвязность .................................................................................  
2.3.2. Блоки и BC-деревья ......................................................................  
2.3.3. Выявление блоков  ........................................................................  
2.4. База циклов ..............................................................................................  
2.4.1. Пространство подграфов  .............................................................  
2.4.2. Квазициклы  ...................................................................................  
2.4.3. Фундаментальные циклы .............................................................  
2.4.4. Построение базы циклов ..............................................................  
2.4.5. Рационализация  ............................................................................  
2.5. Эйлеровы циклы  .....................................................................................  
2.6. Гамильтоновы циклы  .............................................................................  
Задачи и упражнения к главе 2  .....................................................................  
Глава 3.  Экстремальные задачи на графах  .................................................................  
3.1. Независимые множества, клики, вершинные покрытия .....................  
 
 
3.1.1. Три задачи  .....................................................................................  
3.1.2. Стратегия перебора для задачи о независимом множестве ......  
 
3.1.3. Рационализация  ............................................................................  
 
 
3.1.4. Хордальные графы  .......................................................................  

 
 
 
 
 
 
 

 

 

 
 
 

 

 

115

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

3.1.5. Эвристики для задачи о независимом множестве  .....................  
3.1.6. Приближенный алгоритм для задачи о вершинном покрытии   
3.1.7. Перебор максимальных независимых множеств .......................  
3.2. Раскраски .................................................................................................  
3.2.1. Раскраска вершин  .........................................................................  
3.2.2. Переборный алгоритм для раскраски  .........................................  
3.2.3. Рационализация  ............................................................................  
3.2.4. Хордальные графы  .......................................................................  
3.2.5. Раскраска ребер .............................................................................  
3.3. Паросочетания  ........................................................................................  
3.2.1. Паросочетания и реберные покрытия .........................................  
3.2.2. Метод увеличивающих цепей  .....................................................  
3.2.3. Паросочетания в двудольных графах  .........................................  
3.2.4. Паросочетания в произвольных графах (алгоритм Эдмондса)   
3.4. Оптимальные каркасы ............................................................................  
3.4.1. Задача об оптимальном каркасе и алгоритм Прима ..................  
3.4.2. Алгоритм Краскала .......................................................................  
3.4. Жадные алгоритмы и матроиды ............................................................  
3.5.1. Матроиды  ......................................................................................  
3.5.2. Теорема Радо – Эдмондса ............................................................  
3.5.3. Взвешенные паросочетания .........................................................  
Упражнения к главе 3 .......................................................................................  
Список используемой литературы  ...............................................................................  

116

 

Часть 2. МОДЕЛИ ВЫЧИСЛЕНИЙ 

Исторические сведения 

К концу XIX-го началу XX-го века в математике накопилось некото-
рое число вычислительных задач, для которых математики, несмотря на 
упорные попытки, не могли предложить методов решения. Одной из та-
ких задач является задача о разрешимости диофантова уравнения. В док-
ладе Д. Гильберта, прочитанном на II Международном конгрессе матема-
тиков в августе 1900 года, она звучит следующим образом: 

«Пусть задано диофантово уравнение с произвольными неизвестными 
и  целыми  рациональными  числовыми  коэффициентами.  Указать  способ, 
при помощи которого возможно после конечного числа операций устано-
вить, разрешимо ли это уравнение в целых рациональных числах». 

Неудачные попытки математиков решить эту и другие подобные зада-
чи привели к мысли о том, что может и не существовать метода для их 
решения. Но, чтобы доказывать подобного рода утверждения, необходи-
мо иметь математическое определение метода, то есть для интуитивных 
понятий  разрешимости  и  вычислимости  необходимо  иметь  их  формаль-
ные эквиваленты. Одним из важнейших достижений математики XX века 
является  формирование  математических  понятий,  которые  раскрывают 
сущность интуитивных представлений о том, что такое метод (алгоритм) 
решения той или иной задачи, что такое вычислимая функция. 

Важность этих понятий вытекает не только из общенаучных проблем 
развития математики, но также из практических задач общества, исполь-
зующего вычислительную технику в производстве, экономике, инженер-
ных расчетах и нуждающегося в адекватном представлении о возможно-
стях  вычислительных  автоматов.  Приведем  краткие исторические сведе-
ния о возникновении теории алгоритмов. 

В 1932-35 годах А. Черч и С. К. Клини ввели понятие λ-определимой 
функции, которое сыграло важную роль в определении объема интуитив-
ного понятия вычислимой функции. 

В 1934 году Гедель, на основе идей Эрбрана, рассмотрел класс функ-
ций, названных общерекурсивными, а в 1936 году Черч и Клини доказали, 
что этот класс совпадает с классом λ-определимых функций. 

В 1936 году А. Тьюринг ввел свое понятие вычислимой функции, а в 

 
 
 

 

 

113 

 

 

1937 году доказал, что оно совпадает с понятием λ-определимой функции. 
В  1943  году  Пост,  основываясь  на  своей  неопубликованной  работе 
1920-22  годов,  опубликовал  еще  один  формальный  эквивалент  понятия 
вычислимой функции. 

Еще одну формулировку дает теория алгоритмов Маркова (1951 г). 
Любое из упомянутых здесь уточнений интуитивного понятия вычис-
лимой  функции  можно  принять  за  математическое  определение  класса 
вычислимых  функций.  Основными  доводами  для  такого  принятия  явля-
ются  эквивалентность  различных  формулировок  и  естественноисториче-
ский опыт, показывающий, что все изучавшиеся до сих пор функции, ко-
торые принято считать вычислимыми, являются таковыми в смысле лю-
бого из упомянутых выше определений. 

Еще один подход к моделированию вычислений развивается в рамках 
так называемого логического программирования. При таком подходе ус-
ловия решаемой задачи и ее цель формулируются с помощью предложе-
ний  формального  логического  языка.  Затем  осуществляется  автоматиче-
ский  поиск  доказательства  цели,  сопровождаемый  вычислением  неиз-
вестных в задаче величин. Библиографию по затронутым выше вопросам 
можно найти в книгах [3, 4]. 

Заметим,  что  разрабатываемые  в  настоящее  время  алгоритмические 
языки,  составляющие  математическое  обеспечение  современных  вычис-
лительных устройств, также можно использовать для определения поня-
тия  вычислимости.  Более  того,  можно  проследить  тесную  связь  между 
упомянутыми  здесь  теоретическими  моделями  вычислений  и  реальным 
программированием. Так λ-исчисление Черча является прообразом функ-
ционального программирования, реализованного в известном программи-
стам  языке  ЛИСП,  разработанном  в  1961  году  Дж.  Маккарти,  а  модель 
Поста  содержит  идеи,  реализованные  в  операторных  языках  типа  Фор-
тран,  Алгол.  Методы  логического  программирования  реализованы  в  на-
стоящее время в нескольких версиях языка Пролог. 

Однако, реальные языки программирования из-за своей громоздкости 
и избыточности выразительных средств мало пригодны для теоретическо-
го анализа понятия вычислимости. Отметим также модели вычислитель-
ных  устройств,  разработанные  Шепердсоном  и  Смерджисом  (1963  г.)  и 
получившие  название  РАМ  (равнодоступная  адресная  машина)  и  РАСП 
(равнодоступная адресная машина с хранимой программой). Эти модели в 
большей  степени  чем,  например,  модель  Тьюринга  отражают  структуру 
современных вычислительных устройств. 

 114

 

 

Глава 1. ТЬЮРИНГОВА МОДЕЛЬ ПЕРЕРАБОТКИ 

ИНФОРМАЦИИ 

Описанная  ниже  модель  несущественно  отличается  от  модели  пред-

 
 
 

 

ложенной Тьюрингом. 

Представление  информации  (модель  памяти).  Считаем,  что  инфор-
мация представляется словами, то есть конечными последовательностями, 
составленными из букв конечного алфавита, и записывается на неограни-
ченной в обе стороны ленте, разделенной на ячейки. Слово записывается 
в идущих подряд ячейках по одной букве в ячейке. 

В ячейку может быть ничего не записано, в этом случае говорим, что 

ячейка содержит пробел. Для обозначения пробела используем символ *.     
Конечную  последовательность,  составленную  из  символов  алфавита  A = 
= {a 1, a 2,  …,  a t}  и  символа  пробела,  называем  псевдословом.  Считаем, 
что слева от первой буквы псевдослова и справа от последней записаны 
пробелы,  кроме  того,  один  из  символов  псевдослова  будем  помечать 
стрелкой.  Множество  всех  конечных  последовательностей  символов  из 
алфавита A обозначается через A*. 

Если  псевдослово  имеет  вид  X*u t*u t−1*...*u 1*

↓  ,  где  u i  ∈  A*,  X  ∈ 
∈ (A∪{*})*, то u1 называем его первым словом, u 2 − вторым и т.д. Слова 
u i могут быть и пустыми. Пустые слова не занимают место на ленте. При 
необходимости будем считать, что между двумя идущими подряд пробе-
лами записано пустое слово. 

Поскольку  на  ленте  в  каждый  момент  времени  будет  находиться  не 
более чем конечное число символов, отличных от пробела, постольку для 
любого n в псевдослове будет определено его n-ое слово, возможно пус-
тое. 

Преобразователь информации. Преобразователь информации можно 
представить как некоторое устройство снабженное головкой, обозреваю-
щей в каждый момент времени одну из ячеек ленты, и которое по заранее 
намеченному плану (программе) может выполнять операции следующего 
вида: 

•  напечатать один из символов алфавита в обозреваемой ячейке; 
•  сдвинуть головку по ленте на одну ячейку влево; 
•  сдвинуть головку по ленте на одну ячейку вправо; 

 

115

 

 

•  ничего не делать до следующего такта времени. 
Определение  программы.  Программу  преобразования  информации 
будем  представлять  в  виде  ориентированного  графа,  вершины  которого 
помечены символами из множества A ∪ {*, r, l, s}, а дуги символами из 
множества A так, что разным дугам, выходящим из одной вершины, при-
писаны разные символы. Одна вершина графа выделена в качестве вход-
ной,  на  рисунках  будем  отмечать  ее  входящей  стрелкой.  Предполагаем, 
что A ∩ {*, r, l, s} = ∅. 

Действие программы осуществляется следующим образом. В началь-
ный момент головка вычислительного устройства обозревает одну из яче-
ек ленты. Просматривается входная вершина программы. Если ей припи-
сан символ r, l или s, то головка вычислителя сдвигается по ленте на одну 
ячейку  соответственно  вправо,  влево  или  остается  на  месте;  если  же  ей 
приписан символ из алфавита A или *, то этот символ печатается в обо-
зреваемой ячейке, старое содержимое ячейки при этом стирается. После 
того, как выполнено действие, соответствующее вершине q, в графе оты-
скивается выходящая из q дуга, помеченная той буквой, которая находит-
ся  в  данный  момент  в  обозреваемой  ячейке.  Следующим  выполняется 
действие,  соответствующее  вершине,  в  которую  ведет  найденная  дуга. 
Процесс продолжается до тех пор, пока не будет достигнута вершина, из 
которой  не  выходит  дуга,  помеченная  буквой,  обозреваемой  в  данный 
момент. Если такой момент никогда не наступает, то программа работает 
бесконечно долго. 

Вершину v, для которой найдется хотя бы одна буква из A, не исполь-
зуемая  в  качестве  метки  на  дугах,  выходящих  из v,  будем  называть  вы-
ходной. 

Согласно данному описанию, программу можно задать как набор: 

P = (Q, A, q0, ϕ, ψ), 

в котором Q – множество вершин графа; A – алфавит символов, печатаю-
щихся  на  ленте;  q0  –  входная  вершина  (q0 ∈ Q);  ϕ  –  отображение  Q  в         
A ∪ {*, r, l, s}; ψ – частичное отображение A×Q в Q. 

Чтобы  не  загромождать  чертежи  большим  количеством  стрелок  и 
надписей при изображении программ, мы используем следующие согла-
шения. Если из вершины q в вершину q' ведет несколько дуг, будем заме-
нять их одной дугой с надписанными над ней буквами, соответствующи-
ми заменяемым дугам; одну из дуг выходящих из данной вершины будем 

 

 

 116

 

 

оставлять неподписанной, считая при этом, что она помечена всеми бук-
вами алфавита A, которые не использованы на других дугах, выходящих 
из вершины q. Такая дуга может оказаться единственной, выходящей из 
вершины q. Ввиду большой близости введенного нами понятия програм-
мы с понятием машины Тьюринга будем называть наши программы тью-
ринговыми. Множество выходных вершин программы P обозначим через 
V. 

↓ 
Пример . Пусть A = {0, 1} и на ленте записано псевдослово *a1a2...ak*
, ,где ai ∈ A, k ≥ 1, а стрелка над символом * показывает положение головки 
в  начальный  момент.  Рассматривая  слово  a1a2...ak  как  двоичную  запись 
натурального  числа  n,  составить  программу,  которая  на  ленте  оставляет 
псевдослово *b1b2...bs*

↓ , являющееся двоичной записью числа n + 1. 

Нетрудно увидеть, что поставленную задачу решает программа, пред-

ставленная на рис. 1 
 
 
 
 
 
 
 
 

 

 

 

l 

 0

1 

1

 

*

r r

Рис. 1 

Здесь входная и выходная вершины помечены соответственно входя-

щей и выходящей стрелками. 
 

1.1. Алгебра тьюринговых программ 

Для записи программ в виде формульных выражений введем обозна-
чения для некоторых элементарных программ и операций, позволяющие 
строить из уже построенных программ более сложные. 

Элементарными  ычисляющими  программами  будем  называть  про-

в

граммы вида 
 
 
 
обозначать их будем соответственно символами r, l, s, a, где a ∈ A. 

  r

a

s

l

 

 

Программы, у которых множество выходов разбито на два непустых 

 

117

 

 

подмножества:  подмножество  да-выходов  и  подмножество  нет-выходов 
назовем бинарными распознающими программами. 

Элементарными  распознающими  программами  будем  считать  про-

граммы вида 
 
 
 
 
 
 
обозначать такую программу будем через < a >. 

нет-

а

да-

s

Правила  композиции.  Введем  несколько  правил,  которые  позволят 

нам из уже построенных программ строить более сложные. 

1. Если T1, T2, ..., Tk – программы, то выражение [T1, T2, ..., Tk] обозна-
чает программу, которая получена следующим образом. Все выходы про-
граммы  Ti  соединены  дугой  с  входом  программы  Ti+1  (i = 1, 2, ..., k – 1). 
Каждая такая дуга помечена буквами из A, которые не использованы на 
других  дугах,  выходящих  из  рассматриваемой  выходной  вершины  (в 
дальнейшем при соединении выходов одной программы с входом другой 
будем  пользоваться  этим  правилом).  Входом  в  полученную  программу 
является вход программы T1, а выходами – выходы программы Tk. Таким 
образом,  программа  [T1, T2, ..., Tk]  предписывает  последовательное  вы-
полнение программ T1, T2, ..., Tk. 

2. Если P – бинарная распознающая программа, а T – произвольная, то 

выражение 

(если P) T 

означает  программу,  полученную  следующим  образом.  Все  да-выходы 
программы P соединяются с входом программы T. Входом в полученную 
программу является вход в программу P, а выходом – выходы программы 
T и нет-выходы программы P. Программы такого вида называются охра-
няемыми  и  говорят  в  таких  случаях,  что  программа  T  охраняется  про-
граммой P. 

3. Если дан набор охраняемых программ вида: (если Pi) Ti (i = 1, 2, ..., 

k), то выражение вида 

(если P1)T1 ∨ (если P2)T2 ∨ ... ∨ (если Pk)Tk

обозначает  программу,  полученную  следующим  образом.  Да-выходы 
программы Pi соединяются с входом Ti (i = 1, 2, ..., k); нет-выходы про-

 

 

 

 

 118

 

 

граммы Pi соединяются с входом Ti+1 (i = 1, 2, ..., k – 1). Входом в полу-
ченную  программу  является  вход  в  программу  P1,  а  выходом  –  выходы 
программ T1, T2, ..., Tk и нет-выходы программы Pk. 

4. Если P − бинарная распознающая программа, а T − любая, то выра-

жение 

жение 

 

 

 

 

 

 

 

 

 

обозначает  программу,  полученную  следующим  образом.  Да-выходы 
программы P соединяются с входом программы T. Все выходы програм-
мы T соединены с входом в P. Входом в полученную программу является 
вход в P, а выходом нет-выходы программы P. 

5. Если P бинарная распознающая программа, а T − любая, то выра-

(пока P)T 

T (до P) 

обозначает  программу,  полученную  соединением  нет-выходов  програм-
мы P с входом в T, а выходов T  − с входом в P. Входом в полученную 
программу является вход в T, а выходами − да-выходы программы P. 

Сокращения. Программы вида  

T1 ∨ T2 ∨ ... ∨ Tk

 

будем сокращенно записывать в виде 
∪k

, 

iT
1=

i

 а программы вида 

[T1, T2,  ..., Tk] 
в случае, когда T1 = T2 = ... = Tk = T – в виде T k. 

 

В контексте со словами «если», «пока», «до» угловые скобки в записи 

элементарного распознающего оператора <a> будем опускать. 

1.2. Начальное математическое обеспечение 

Приведем несколько программ, для которых введем обозначения и ко-
торые  в  дальнейшем  используем  для  построения  более  сложных  про-
грамм. Они будут составлять начальное математическое обеспечение про-
граммирования. 

В таблице приведены их схемы в предположении, что алфавит A со-

стоит из символов a1, a2, ..., at; а символ * обозначен через a0 . 

 

119

 

 

Кроме того, считаем, что X и Y – произвольные псевдослова над алфа-
витом A; u1, u2, ..., un, u – слова в алфавите A; a – произвольный символ из 
A ∪ {*}; u−1 – слово, полученное из слова u изменением порядка симво-
лов на противоположный; n = 1, 2, ... . 

Программы R, L, описанные вначале таблицы, используются в после-

дующих программах. 
 

 

Т а б л и ц а  

Сдвиг головки влево до ближайшего пробела. Обозначение L 

Вход:  
Выход:  
Программа: 

X*ua↓ Y 
↓ ua Y 
X *
l (до *) 

Сдвиг головки вправо до ближайшего пробела. Обозначение R 

Вход:  
Выход:  
Программа:  

Вход:  
Выход:  
Программа:  

X a↓ u*Y 
↓  Y 
Xua *
r (до *) 
Копирование n-го слова. Обозначение Kn
↓
X* un* un-1 ... * u1*
X* un* un-1... * u1* un
Ln , r, [∪i (если ai) [* , Rn+1 ,  ai , Ln+1 ,  ai , r]] (до *), Rn

↓
*

Удаление буквы со сдвигом. Обозначение S 

Вход:  
Выход:  
Программа:  

X a↓ u *Y 
↓ Y 
Xu**
[r, ∪i (если ai) [l ,  ai],  r] (до *) 

Вход:  
Выход:  
Программа:  

Вход:  
Выход:  

Циклический сдвиг n слов. Обозначение Zn

↓  
X * un* un−1* ... * u1 *
↓
 
X * un-1* ...* u1 * un
 
*
R, [Ln+1, r, ∪i (если ai) [Sn ,  a i]] (до *) 
Удаление n-го слова. Обозначение Λn

↓  
X * un* un−1* ... * u1*
X * un-1 * ...* u1*
↓  

 

 

 

 

 

 

 

 

 

 

 

 120

 

 

 

Zn, [*, l] (до *) 

Программа:  
1.3. Методика доказательства правильности программ 
Рассматриваемая  методика  предназначена  для  доказательства  пра-
вильности алгоритмов, представленных в виде графов, вершинам которых 
поставлены в соответствие операторы над памятью, а дугам переходы от 
оператора к оператору. Одну из вершин назовем входной, ей соответству-
ет  оператор,  с  которого  начинается  выполнение  алгоритма,  а  выходных 
вершин может быть несколько. Считаем, что входная и выходная верши-
ны помечены, соответственно, входящей и выходящей стрелками. Такие 
представления  алгоритмов  называют  блок-схемами.  Доказать  правиль-
ность алгоритма это значит доказать утверждение вида: 

 

«Если входные данные удовлетворяют входному условию, то алго-
ритм  через конечное число шагов завершает работу, и выходные дан-
ные удовлетворяют требуемому выходному условию». 

На практике, такое утверждение часто разбивают на два. 
(1) «Если входные данные удовлетворяют входному условию и алго-
ритм через конечное число шагов завершает работу, то выходные данные 
удовлетворяют требуемому выходному условию». 

(2) «Если входные данные удовлетворяют входному условию, то алго-

ритм через конечное число шагов завершает работу». 

Алгоритм, для которого доказано утверждение (1) называется частич-
но правильным или частично корректным. Если же доказаны утверждения 
(1) и (2) то алгоритм называется правильным или корректным. 

Заметим, что когда доказательство утверждения (2) представляет не-
преодолимые  трудности,  то  ограничиваются  доказательством  утвержде-
ния (1). Таковы, например, итерационные алгоритмы, для которых не из-
вестна область сходимости. В таком случае, если алгоритм в приемлемое 
время завершает свою работу, то правильность ответа гарантируется. 

Остановимся на доказательстве частичной корректности. 
Методика заключается в следующем. 
1.  Для контроля над ходом вычислений выбираются, так называемые, 
контрольные  дуги.  К  числу  контрольных  обязательно  относят 
входную и все выходные дуги, а также некоторое количество дру-
гих  дуг  так,  чтобы  в  граф-схеме  алгоритма  оказались  «разрезан-
ными» все циклы. 

2.  Для каждой контрольной дуги формулируется индуктивное усло-
вие, которому предположительно должно удовлетворять содержи-

 

121

 

 

мое  памяти  алгоритма  при  каждом  его  прохождении  через  рас-
сматриваемую  дугу.  Считаем,  что  все  контрольные  дуги,  в  даль-
нейшем  будем  называть  их  контрольными  точками,  и  соответст-
вующие им индуктивные утверждения пронумерованы. 

3.  Для каждой пары i, j контрольных точек, для которых в блок-схеме 
имеется путь из i в j, минующий другие контрольные точки, выби-
раются все такие пути и для каждого выбранного пути доказывает-
ся утверждение (индуктивный шаг): «Если при очередном проходе 
через точку i выполнялось индуктивное предположение Pi и если 
реализуется рассматриваемый путь, то при достижении точки j бу-
дет выполняться условие Pj ». 

 

 

 

 122

Если все индуктивные шаги доказаны, то, используя принцип матема-
тической индукции, можно утверждать частичную корректность алгорит-
ма. Для доказательства полной корректности остается доказать завершае-
мость программы через конечное число шагов.  
 

1.4. Вычислимость и разрешимость 

Упорядоченный набор из n слов в алфавите A называется n-местным 
набором над A. Множество всех n-местных наборов над A обозначим че-
рез (A*)n. 

Любое  подмножество  R  множества  (A*)n  называется  n-местным  сло-

варным отношением. 

Любое, возможно частичное отображение f: (A*)n → A* называется n-
местной словарной функцией. Область определения функции f обознача-
ется через Def (f ). 

Результатом работы программы T на выходном псевдослове X назы-
вается псевдослово T (x), которое появляется на ленте в момент остановки 
программы; если программа работает бесконечно, то результат неопреде-
лен. 

Программа, которая в процессе работы над любым псевдословом X не 
сдвигает головку левее пробела, расположенного слева от n-го слова псев-
дослова X, будем называть n-программой. 

Словарное n-местное отношение R называется полуразрешимым, если 
существует  n-программа  T,  которая  останавливается  в  точности  на  всех 
псевдословах, имеющих вид 

↓
X # un # un–1 # … # u1 #
 , 

 

 

где (u1, u2, …, un) ∈ R. 

Словарное n-местное отношение R называется разрешимым, если R и 

R  полуразрешимы (под R и  R  здесь понимается множество (A*)n \ R). 

Словарная  n-местная  функция  f: (A*)n → A*  называется  вычислимой 

 

по Тьюрингу, если существует программа T такая, что  
↓  ) = *u1*u2*...*un*v*
↓ , 

T(*u1*u2*...*un*

где u1, u2, ..., un ∈ Def (f ) и v = f (u1, u2, ..., un) , в противном случае ре-
зультат не определен. 

Вычислимые  по  Тьюрингу  функции  уместно  было  бы  назвать  полу-
вычислимыми, а полувычислимые с разрешимой областью определения – 
вычислимыми, но это противоречит установившимся традициям. 
 

1.5. Вычисление числовых функций 

Чтобы вычислять значения числовых функций с помощью тьюринго-
вых  программ,  необходимо  выбрать  способ  кодирования  на  ленте  аргу-
ментов и значений функции. Мы рассматриваем функции из N n в N, где    
N – множество натуральных чисел, включая 0, а n ≥ 1. 

Значения  функции  и  ее  аргументов  будем  записывать  в  бинарном, 
унарном или каком-либо ином коде, для этого нам потребуется соответст-
венно алфавит A = {1}, A = {0, 1} и т.д. Значения аргументов перед вычис-
лением должны быть представлены на ленте в виде псевдослова 

 

 
где xi – код i-го аргумента (i = 1, 2, ..., n). 

↓ , 
*x n*xn–1*...*x1*

После вычисления содержимое ленты должно иметь вид: 

 
где y – код значения функции при заданных значениях аргумента. 

↓ , 
*x n*xn–1*...*x1*y*

 

 

 

Упражнения 
1. Составить программу, перерабатывающую псевдослово *u*

↓  в псев-
↓ , где u – бинарный, а v – унарный код некоторого числа из 

 

 

 

 

 

дослово *u*v*
N. 

бинарном кодах. 

кодах. 

2.  Составить  программу  сложения  и  умножения  чисел  в  унарном  и 

3.  Составить  программу  для  удвоения  числа  в  бинарном  и  унарном 

 

123

 

 

4. Составить программу деления нацело натуральных чисел в унарном 

коде. 

1.6. Частично-рекурсивные функции 

Пытаясь  выяснить  содержание  интуитивного  понятия  вычислимой 
функции,  А.  Черч  в  1936  году  рассмотрел  класс  так  называемых  рекур-
сивных функций, а Клини расширил его до класса частично-рекурсивных 
функций. В то же время впервые была высказана естественно научная ги-
потеза о том, что интуитивное понятие вычислимой частичной функции 
совпадает  с  понятием  частично  рекурсивной  функции.  Эту  гипотезу  на-
зывают  тезисом  Черча.  Здесь  мы  напомним  понятие  частично-
рекурсивной функции и покажем, что любая частично-рекурсивная функ-
ция  вычислима  по  Тьюрингу.  Набор  аргументов  x1, x2, ..., xm  обозначим 
через x. 

Функция f(x) называется суперпозицией n-местных функций g1, g2, ..., 

gm и m-местной функции h, если 

F (x) = h (g1(x), g2(x), ..., gm(x)). 

Говорят, что (n + 1)-местная функция f (x, y) получена примитивной 

рекурсией из (n + 2)-местной функции g и n-местной функции h, если 

f

x
,(

y

)

=

x
h
)(
fg
(

x
,(

⎧
⎨
⎩

y

−

),1

x
,

y

−

),1

при
при

y
y

=
>

;0
.0

 

Говорят,  что  n-местная  функция  f (x)  получена  минимизацией  из 
(n + 1)-местной функции g, если f (x) = k, если g(k, x) = 0 и при всех k ′ < k 
определено и не равно 0, f (x) не определена в противном случае. 

Часто обозначают f (x) через µy (g(y, x) = 0). 
Заметим, что суперпозиция и примитивная рекурсия, примененные к 
всюду определенным функциям, дают всюду определенные функции, то-
гда как минимизация, примененная к всюду определенной функции, мо-
жет дать частичную функцию. 

Числовая функция f : N n → N называется частично рекурсивной, если 

она является одной из базисных функций: 

а) O (y) = 0 (при всех y ∈ N ), 
б) S (y) = y + 1 (при всех y ∈ N ), 
в) Im

n (x1, x2, ..., xn) = xm (n = 1, 2,...;  1 ≤ m ≤ n) 

или получена из них с помощью конечного числа применений суперпози-

 

 

 

 

 

 124

 

 

рингу. 

ции, примитивной рекурсии и минимизации. 

Теорема.  Любая  частично-рекурсивная  функция  вычислима  по  Тью-

Доказательство теоремы заключено в следующих четырех леммах, с 

использованием унарного кодирования чисел. 

Лемма 1 (о базисных функциях). Базисные функции O (y), S (y), Im

n (x1, 

x2, ..., xn) вычислимы по Тьюрингу. 

Действительно,  функцию  S (y)  вычисляет  программа  [Km, 1, r],  функ-
n (x1, x2, ..., xn)  вычисляет 

цию  O (y)  вычисляет  программа  [r],  функцию  Im
программа Km. 

Лемма  2  (о  суперпозиции).  Если  функции  g1 (x), g2 (x), ..., gm (x)  и 
h (y1, y2, ..., ym) вычислимы, соответственно, программами G1, G2 ,..., Gm 
и H, то функцию 

f (x)=h (g1 (x), g2 (x),..., gm (x)) 

вычисляет программа: 

[Gm, (Zn + 1)n, Gm −1, (Zn + 1)n, ..., G1, (Zn + 1)n, (Zn + m)n, H, (Λ2)m]. 

Чтобы убедиться в справедливости, достаточно выписать псевдослова, 
которые  появляются  на  ленте  после  выполнения  отдельных  частей 
программы. Сначала на ленте находится псевдослово 

после выполнения Gm на ленте будет 

после [Gm, (Zn + 1)n] –  

 

 

↓  , 
*xn*xn − 1*...*x1*

↓ , 
*x n*xn − 1*...*x1*gm*

↓ , 
*gm*x n*xn − 1*...*x1*

 

 

 

 

 

 

 

 

 

 

 

 

 

после [Gm, (Zn + 1)n, Gm − 1] –  

↓ , 
*gm*x n*xn–1*...*x1 * gm–1*

 

и т.д.  
после [Gm, (Zn + 1)n, Gm − 1, (Zn + 1)n, ..., G1, (Zn + 1)n] –  

↓ , 
*gm *gm − 1 *...*g1 * x n*xn − 1*...*x1*

после [Gm, (Zn + 1)n, Gm–1, (Zn+1)n, ..., G1, (Zn+1)n, (Zn+m)n, H,] –  

 

125

 

 

↓ , 
* x n*xn–1*...*x1*gm*gm–1 *...*g1 *f *
и, наконец, после выполнения всей программы получим 

 

↓ , 
* x n*xn–1*...*x1* f *

Лемма  3  (о  примитивной  рекурсии).  Если  функции  h (x1,  x2  ,...,  xn)  и 
g (y1, y2, ..., yn+2) вычислимы соответственно с помощью программ H и G, 
то функция f (x1, x2 ,..., xn, y), полученная по схеме примитивной рекурсии 
вычислима программой 

[H, Ln+1, l, (пока 1)[*, Rn+2 ,G, Λ2 ,Ln+2 ,1, l], Rn+2]. 

 

 

 

 

l

1

n+2

 R 

n+1

L 

P1

Доказательство.  Представим  программу,  предлагаемую  для  вычис-
ления функции f (x1, x2, …, xn, y), блок-схемой, изображенной на рисунке. 
 
 
 
 
 
 
 
 
 
 
 

   Λ2; L 

n+2;G 

n+2;l 

*; R 

Пунктирными  стрелками  показаны  контрольные  дуги,  для  которых 
будут сформированы соответствующие индуктивные утверждения P1, P2, 
P3. 

Утверждение P1  соответствует  входной  дуге  и  поэтому  должно  опи-
сывать содержимое ленты в начальный момент. Утверждение P3 соответ-
ствует  выходной дуге и должно описывать содержимое ленты в момент 
завершения работы программы. Утверждение P2 относится к дуге, разре-
зающей  единственный  имеющейся  в  блок–схеме  цикл,  поэтому  должно 
быть  сформулировано  так,  чтобы  ему  удовлетворяло  содержимое  ленты 
каждый раз, когда в программе реализуются переход по рассматриваемой 
дуге. 

Напомним, что основное требование, предъявляемое к утверждениям 
P1, P2, P3 заключается в том, чтобы была возможность доказательства ин-
дуктивных шагов: 

P3

P2

P1 → P 2, если реализуется путь [H; Ln+1; l; *; Rn+2; G]; 
P 1 → P 3, если реализуется путь [H; Ln+1; l; Rn+2]; 

 126

 

 

 

P 2 → P 2, если реализуется путь [Λ 2; Ln+2; l; l; *; Rn+2; G]; 
P 2 → P 3, если реализуется путь [Λ 2; Ln+2; l; l; Rn+2]; 
Пусть x1, x2, …, xn, y – исходные значения аргументов из множества N, 
тогда требуемые утверждения можно сформулировать следующим обра-
зом: 

y

x
1*1*1*

P1 − содержимое ленты равно 
P2 − существует y1 ≥ 1, y2, g1, g2 ≥ 0, такие, что содержимое ленты рав-
1 + y2 + 1  =  y, g1  = g(f (x1,  x2, …, xn, y1 – 
x
11*1*1*

но 
1), x1, x2, …xn, y1 – 1), g2 = g(f (x1, x2, …, xn, y1), x1, x2, …, xn, y1), 

↓
*111*...*

 и y

g
1

x
n

x
1

1
−

g

n

1
−

x

n

y

2

y

2

n

2

↓
*1*...*

x
1

,  

P3 − содержимое ленты равно 

1*1*1*
x
n

x
n

y

1
−

↓
*1*1*...*

x
1

z

 и z = f (x

1, x2, 

…, xn, y). 

Доказательство  индуктивных  шагов  легко  получить,  выписывая  со-
держимое ленты после каждого оператора в соответствующем пути. Чи-
тателю  предоставляется  возможность  это  проделать  и  убедится  в  пра-
вильности программы, предлагаемой в формулировке леммы 3.Не забудь-
те доказать завершаемость исследуемой программы. 

Лемма  4  (о  минимизации).  Если  функция  g(x1,  x2,  ...,  xn)  вычислима 
программой G, то функция f (x1, x2, ..., xn), полученная из нее по схеме ми-
нимизации вычисляется программой 
 

[r, G, l, (пока 1)[r, Λ2 ,1, r, G, l]. 

 

Доказательство.  Представим  программу,  предлагаемую  для  вычис-
ления функции f (x1, x2, …, xn) блок-схемой c указанными контрольными 
точками P1, P2, P3. 
 
 
 
 
 
 
 
 
 
 
 
 

R; Λ1;1 

Пусть x1, x2, …, xn исходные значения аргументов, тогда для доказа-

P3

P1

P2

G

r 

l 

1

 

127

 

 

тельства  частичной  корректности  предлагаемой  программы  можно  вос-
пользоваться следующими индуктивными утверждениями:  

P1 – содержимое ленты равно 
P2  –  существует  k,  z  ≥  0,  такие,  что  содержимое  ленты  равно 

x
1*1*

, 

1
−

x

n

n

↓
*1*...*

x
1

*1* nx

 

xn
1*

1
−

↓
*1*1*1*...*

x
1

k

z

, где z = g (k, x

1, x2, …, xn), 

P3 – содержимое ленты равно 

x

x
1*1*
n

n

↓
*1*1*...*

x
1

z

1
−

, где z = f (x

1, x2, 

…, xn). 

*. 

 

 

 128

Требуется доказать следующие индуктивные шаги. 
P1 → P2, если реализуется путь [r, G]; 
P2 → P2, если реализуется путь [l; r; Λ1; l; r; G]; 
P2 → P3, если реализуется путь [l], и головка остановится на символе 

Доказательство индуктивных утверждений и завершаемости програм-

мы предоставляется читателю в качестве упражнений. 

Заметим, что в доказательствах лемм 3 и 4 при рисовании блок-схемы 
мы несущественно отступили от текстов программ, данных в их форму-
лировках, а при доказательстве леммы 2 не выписывали индуктивные ут-
верждения,  так  как  в  представлении  программы  блок-схем  нет  циклов. 
Обращаем внимание на то, что правильность блоков, из которых состав-
лены программы, мы не подвергаем сомнению. 

1.7. Универсальная тьюрингова программа 

В  этом  параграфе  мы  объявляем  о  существовании  универсальной 
тьюринговой программы U, которая может имитировать любую програм-
му,  работающую  над  фиксированным  алфавитом  A = {a1, a2 ,..., an}.  Эта 
программа U, получив на входе псевдослово, содержащее в определенном 
виде код произвольной программы T и псевдослово X, должна оставить на 
ленте код программы T и псевдослово T (X) – результат работы програм-
мы T на псевдослове X. 

Читатель, построивший универсальную программу, может считать се-

бя изобретателем компьютера. 

Пусть  Ψn  –  множество  всех  функций  из N  в N  таких,  что  каждая  из 
них определена в точке 0 и вычислима программой, состоящей не более 
чем из n тьюринговых команд. Рассмотрим функцию s (n) = max f (0), где 
максимум берется по всем функциям из Ψn. 

ва  

 

 

Теорема.  Для  любой  всюду  определенной  вычислимой  функции               

f : N  → N существует k  ∈ N такое, что при любом m ≥ k выполняется 
неравенство f (m) < s (m). 

Действительно, пусть f (n) – произвольная всюду определенная функ-

ция из N в N, тогда, очевидно, функция  

F(n) = max(f (3n), f (3n + 1), f (3n + 2)) + 1 

 

 

Очевидно, s(n) всюду определена и монотонна. Более того справедли-

будет также всюду определенной и вычислимой. Пусть в унарном коде ее 
вычисляет программа TF, состоящая из k команд. Рассмотрим программу  
T = [[1,r]n, TF], которая сначала записывает на ленте число n, а затем ра-
ботает как TF. Очевидно, она состоит из 2n + k команд и вычисляет неко-
торую функцию F ′ ∈ Ψ2n+k. 

По определению F ′ и s имеем F(n) = F′(0) ≤ s (2n + k). Используя мо-
нотонность функции s, получим F (n) ≤ s (3n) при всех n ≥ k, следователь-
но, f (3n + i) < s (3n + i), (i = 0, 1, 2). Отсюда следует, что при m ≥ 3k вы-
полняется неравенство f (m) < s (m), что и требовалось доказать. 

Следствие.  Функция  s (n)  невычислима,  так  как  она  растет  быстрее, 

чем любая вычислимая функция. 

Заметим,  что  при  любом  фиксированном n  значение s (n) можно по-
пытаться вычислить путем перебора всех программ длины ≤ n и вычисле-
ния для каждой из них времени работы до момента остановки или доказа-
тельства  ее  незавершаемости.  Но  вопрос  о  завершаемости  программ  в 
общем  виде  алгоритмически  неразрешим.  Уточним  основные  моменты 
этого утверждения. 

Пусть T – тьюрингова программа, работающая в алфавите A, и пусть 
kod (T)  –  слово  в  алфавите  A,  кодирующее  программу  T  (на  деталях 
кодирования не останавливаемся). 

Программа T называется самоприменимой, если при подаче ей на вход 
ее собственного кода, она через конечное число шагов остановится, в про-
тивном  случае  программа  называется  несамоприменимой.  Пусть  M  – 
множество кодов самоприменимых программ. 

Теорема. Множество M алгоритмически неразрешимо. 
Доказательство. Пусть M – алгоритмически разрешимо. Тогда суще-
ствуют  две  программы  T1  и  T2  такие,  что  T1  останавливается  только  на 
словах из M, а T2 – только на словах из A* \ M. 

Тогда, если T2 на своем собственном коде остановится, то kod (T2) ∈ 

 

129

 

 

∈ M по определению M, но kod (T2) ∉ M по определению T2. 

Если же T2 на своем собственном коде не остановится, то по опреде-
лению M kod(T2) ∉ M, а по определению T2 kod(T2) ∈ M. Итак, в любом 
случае имеем противоречие. 

Еще одним примером алгоритмически неразрешимого множества яв-
ляется множество M1 кодов программ, которые останавливаются при пус-
том входе. Легко показать, что если бы M1 было разрешимым, то множе-
ство M тоже было бы разрешимым. 

 

1.8. Об измерении алгоритмической сложности задач 
При практическом решении многих интересных задач с помощью вы-
числительных автоматов существенную роль играет время работы и объ-
ем памяти, которые требуются для их решения соответствующими алго-
ритмами.  Упомянутые  характеристики  называются,  соответственно,  вре-
менной и пространственной сложностью алгоритма. 

Временной и пространственной сложностью задачи в классе алгорит-
мов  (или  автоматов)  называется  время  и  объем  памяти,  требующиеся 
«лучшему» в данном классе алгоритму (автомату), для решения рассмат-
риваемой задачи. 

Вопрос о нахождении сложностных характеристик задач весьма тру-
ден.  Трудности  как  правило  связаны  с  логической  сложностью  рассмат-
риваемых задач и обилием алгоритмов в любом универсальном классе. 

Рассмотрим  некоторые  подробности  на  примере  тьюринговых  про-
грамм. Считаем, что задача представлена двухместным словарным преди-
катом R (u, v) над некоторым алфавитом A и заключается в нахождении по 
заданному слову u ∈ A* слова v ∈ A* такого, что R (u, v) истинно. 

Слово v будем считать решением задачи R при входном слове u. Что-
бы пустоту слова v трактовать как отсутствие решения, наложим на R сле-
дующие ограничения 
 

R (λ, λ), 

∀u ∃v R (u,  v), 

∀u [R (u,  λ) → ∀v [v ≠ λ → ¬R (u,  v)]]. 

 

 

 

 

 130

Результат работы тьюринговой программы T на входном слове u обо-

значим T (u), считая T (u) равным выходному слову. 

Будем говорить, что тьюрингова программа T решает задачу R, если 
на любом входном слове u она останавливается через конечное число ша-

 

 

гов и ∀u R (u, T (u)). 

Через  time (T, u)  обозначим  число  элементарных  тьюринговых  ко-
манд, которые будут выполнены программой T от начального момента до 
момента  остановки  при  работе  на  входном  слове  u.  Если  при  входном 
слове    u  программа  T  выполняет  бесконечное  число  шагов,  то  считаем 
time (T, u) = ∞. 

Величину  time (T, u)  будем  называть  временем  работы  программы  T 
на слове u. В большинстве случаев эта величина существенно зависит от 
длины  слова  u,  поэтому  представляет  интерес  функция  t (T, n)  = 
= max time (T, u), где максимум вычисляется по всем словам длины n. 

Заметим,  что  эта  ситуация  не  является  общей;  в  некоторых  случаях 
величина time (T, u) не зависит от длины слова u. Например, пусть требу-
ется  определить  четность  числа,  представленного  в  двоичном  коде.  Для 
этого достаточно посмотреть на его младший разряд. 

Временной сложностью задачи R можно было бы попытаться назвать 
функцию  f (n) = min t (T, n),  где  минимум  вычисляется  по  всем  програм-
мам  Т,  решающим  задачу  R.  Однако,  существование  такой  функции  не 
гарантировано.  Можно  надеяться  на  существование  таких  функций  при 
ограничениях на класс вычислительных алгоритмов. На практике ограни-
чиваются  нахождением  верхней  и  нижней  оценочных  функций  для  вре-
мени работы конкретных алгоритмов. 

Заметим,  что  получение  нижних  нетривиальных  оценок  каждый  раз 
представляет  собой  сложную  математическую  задачу.  Известно,  напри-
мер,  что  временная  сложность  задачи  распознавания  симметрии  слова 
тьюринговыми  программами  оценивается  снизу  функцией  cn2,  где  n  − 
длина слова, а c − некоторая константа. 

Для многих интересных с практической точки зрения задач известные 
верхние  оценки  носят  экспоненциальный характер, что часто свидетель-
ствует  о  больших  затратах  времени  при  выполнении  соответствующих 
алгоритмов на вычислительных установках. 

Если  для  задачи  R  имеется  полиномиальная  от  n  верхняя  оценочная 

функция, то говорят, что R разрешима в полиномиальное время.  

Для  многих  задач  не  удается установить существование верхних по-
линомиальных оценочных функций. Однако, распознавание на паре слов 
u, v, является ли слово v решением задачи R на входе u, решается за поли-
номиальное от длины слова u время и, кроме того, для каждого u сущест-
вует ответ v, длина которого ограничена некоторым полиномом от длины 
u.  Это  так  называемые  задачи  с  проверяемым  за  полиномиальное  время 

 

131

 

 

ответом. 

Такой  задачей  является,  например,  задача  о  выполнимости  булевых 
формул, которая заключается в следующем. По заданной булевой форму-
ле  найти  набор  значений  переменных,  при  которых  соответствующая 
формуле булева функция принимает значение 1. Имея минимальный про-
граммистский  опыт,  легко  убедиться  в  возможности  проверки  ответа  к 
этой задаче за полиномиальное время. 

Задачи с проверяемым за полиномиальное время ответом называются 
переборными  с  гарантированным  экспоненциальным  перебором.  Дейст-
вительно,  пусть  R (u, v)  такая  задача  и  длина  возможного  ответа  v 
ограничена  полиномом p  от  длины  входа u,  то  есть | v | ≤ p (| u |). Пусть, 
далее  q  –  полином,  являющийся  верхней  оценкой  времени  работы 
программы,  проверяющей  ответ,  тогда,  перебирая  всевозможные  2 p
|) 
слов  длины  p (|  u  |)  и  затрачивая  на  проверку  каждого  не  более  q (|  u  |) 
тактов времени, получим алгоритм с верхней 

оценкой q (u)·2  

Задача R полиномиально сводится к задаче R', если существуют рабо-
тающие полиномиальное время тьюринговы программы Т1 и Т2 такие, что  

(|

 p(|u|)
  . 

 

 

u

 

 

 

∀u ∀v' [R' (T1 (u), v' ) → R (u, T2 (v' ))]. 

Из этого определения следует, что для решения задачи R на входе u 

достаточно 

 

 

 

 

 132

•  вычислить u' = T1 (u), 
•  затем найти ответ v' задачи R' на входе u', 
•  и, наконец, применить к v' программу T2, получив ответ v = T2 (v' ) 

задачи R на входе u. 

Таким образом, имеем следующую схему получения ответа v: 

u → u' → v' → v. 

Оказывается, что среди задач с полиномиально проверяемым ответом 
существует задача, к которой полиномиально сводится любая другая за-
дача с полиномиально проверяемым ответом. Такие задачи получили на-
звание универсальных переборных задач. 

Исторически  существование  универсальных  переборных  задач  обна-
ружено в 1971 году американским математиком Куком, когда он доказал, 
что  задача  выполнимости  булевой  формулы является универсальной пе-
реборной задачей. 

Тогда же было доказано, что и многие другие широко известные зада-

чи являются универсальными переборными задачами. 

 

 

ному вопросу имеется обширная литература. 
 
 
 

 

 

Глава 2. АБАК 

2.1. Основные определения 

Круг таких задач в настоящее время постоянно расширяется. По дан-

Абак  наряду  с  машинами  Тьюринга  является  одной  из  простейших 
универсальных  моделей  вычислений.  Это  числовая  модель;  элементами 
информации являются целые неотрицательные числа. 

Память представляет собой потенциально бесконечный набор ячеек, 
каждая  ячейка  может  содержать  любое  целое  неотрицательное  число. 
Считается, что ячейки пронумерованы числами 1, 2, ... . 

Исполняющее  устройство  способно  выполнять  всего  две  операции 
(элементарные команды) над числами, это прибавление (increment) и вы-
читание  (decrement)  единицы  из  указанного  в  команде  числа.  Команды 
имеют  вид  inc (x)  и  dec (x),  где  x  –  номер  ячейки.  Поскольку  в  каждом 
конкретном  алгоритме  может  быть  использовано  лишь  конечное  число 
ячеек, и с номерами ячеек никаких операций производиться не будет, мы 
будем  обозначать  их  в  примерах  для  наглядности  отдельными  буквами, 
возможно с использованием индексов. 

Программа (алгоритм) это ориентированный граф, вершинам которо-
го приписаны элементарные команды указанного выше вида. Из каждой 
вершины помеченной командой вида inc(x) выходит одна дуга в вершину, 
со следующей командой. Из каждой вершины помеченной командой вида 
dec(x)  выходят  две  дуги.  Одна  из  них  помечается  знаком  «+»  и  ведет  в 
вершину,  помеченную  командой,  которая  должна  выполняться  следую-
щей  в  случае,  если  перед  ее  выполнением  в  ячейке  x  находилось  число 
отличное от нуля. Вторая дуга помечается знаком «–» и ведет в вершину, 
помеченную командой которая должна выполняться следующей в случае, 
если  перед  ее  выполнением  в  ячейке  x  находилось  число  нуль.  Одна  из 
вершин графа помечается как входная, в нее ведет дуга из ниоткуда, вы-
ходных вершин может быть несколько. 

Несмотря на простоту этой модели вычислений, она «эквивалентна по 
силе»  любой  из  изучавшихся  универсальных  моделей  вычислений  и 
относительно  нее  можно  сформулировать  тезис,  аналогичный  тезису 
Черча, который может выглядеть следующим образом. Любая интуитивно 
вычислимая функция может быть вычислена на абаке. При этом, конечно, 

 

133

 

 

надо условиться о том, где располагаются входные аргументы и куда сле-
дует поместить результат (значение вычисляемой функции). 

Примеры программ. В рассмотренных ниже примерах операция inc(x) 
–. Основ-
обозначается для краткости через x 
ные  операции  изображены  кружками.  Прямоугольниками  изображены 
операции,  для  которых  в  предыдущих  примерах  построены  алгоритмы. 
Знак «–» на соответствующих дугах опущен. Сформулируйте инварианты 
циклов во всех рассмотренных ниже примерах. 

+, а операция dec(x) – через x 

1.  Программа  x: = 0  
В  языках  программирования  эта  операция  обычно  является  элемен-
тарной. На абаке это действие можно выполнить следующей программой 
 
 
 
 
 
 

x−

y: 0 

z: = 0

+

x −

z

y 

−z

+

x +

3.  Программа  x := x + y 

z :

 y=

+

z−

x+

+

− 

2.  Программа  y := x  

 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 

 134

 

 

4.  Программа  z := x + y  

z:= 0  

z:= z + x 

z:= z + y 

5.  Программа  x: = x * y  

z: = y 

u0

6.  Программа  z := x * y  

u  = + x

:

z −

x 

 u:=

  

z:= 0

 
 
 
 
7.  Программа  z := x 
 
 
 
 
 
 
 

z := 0

z +

z  :=  z * 

z  :=  z  * 

y 

z +

u 

 y:=

+

u −

z  :=  z  * 

 
 
 
 

 

 
 
 
 
 
 
 
 
 

 

 

2.2. Примеры неразрешимости 

Функцию  p: N → N  назовем  вычислимой  на  абаке,  если  существует 
программа P, которая, получив в некоторой, заранее обусловленной ячей-
ке  x  значение  аргумента  n,  а  в  остальных  ячейках  нули,  через  конечное 
число шагов остановится, и в ячейке y будет находиться p (n). 

Проблема построения невычислимой функции известна как проблема 
усердного бобра. Пусть A – абак-программа и y – номер некоторой ячей-
ки. Определим величину f (A, y), следующим образом. Если в начальный 
момент все ячейки содержат число 0 и программа A через конечное число 

 

135

 

 

шагов останавливается, то f (A, y) равно числу [y] в момент остановки. Ес-
ли же программа работает бесконечно, то считаем f (A, y) = 0. Величину 
f (A, y) назовем y-продуктивностью программы A. 

Обозначим через Ã (n) множество всех абак-программ, состоящих из 
n команд.  Определим  функцию  p (n)  как  максимум  f (A, y)  по  всем  про-
граммам A из Ã (n) и ячейкам y. Очевидно, эта функция определена при 
всех натуральных значениях аргумента и строго монотонна. 

Лемма. Для любого натурального числа n выполняется неравенство  

p (n + 17) ≥ 2n. 

Для  доказательства  достаточно  рассмотреть  программу,  которая  сна-
чала запишет 0 в ячейку x, затем прибавит к ней n раз 1, скопирует со-
держимое ячейки x в ячейку y и добавит к ней содержимое ячейки x. Оче-
видно, после выполнения такой программы в ячейке y будет число 2n, а 
подсчет  числа  команд  показывает,  что  их  будет  n + 17.  Наличие  такой 
программы (рис. 1) доказывает требуемое неравенство. 
 
 
 
 
 
 
 

[y] := [y]+[x]

[y] := [x] 

[x]:=0 

x+

x+

 

x+

x+

Рис. 1 

Предположим теперь, что p (n) вычислима некоторой программой P, 
состоящей из k команд и которая, получив n в ячейке x, поместит ответ в 
ячейку y. 

Тогда для каждого натурального n можно построить программу, вы-
числяющую p (p (n + 17)), состоящую из n + 2k + 25 команд. Эта програм-
ма сначала запишет 0 в ячейку x, затем прибавит к ней n + 17 раз единицу, 
затем с помощью программы P в ячейке y вычислит p (n + 17), скопирует 
y в x и, наконец, опять с помощью программы P вычислит p (p (n + 17)). 

Наличие такой программы (рис. 2) означало бы, что при любом нату-

ральном n выполняется неравенство  

p (n + 2k +25) ≥ p (p (n + 17)). 

Поскольку функция p (n) монотонна, то получаем отсюда  

n + 2k + 25 ≥ p (n + 17). 

 

 

 

 

 

 

 136

 

 

Сопоставляя  это  неравенство  с  неравенством  в  утверждении  леммы, 

n + 2k + 25 ≥ p (n + 17) ≥ 2n, 

что приводит к противоречию, например, при n = 2k + 26. 

Итак,  предположение  о  вычислимости  функции  p (n)  привело  к 

  

x +

+x

+x

x + 

[y] := p[x]

[x] := [y]

[y]:=p[x] 

Рис. 2 

На рис. 2 команда x+ повторяется n + 17 раз, общее количество команд 

в программе n + 2k + 25 раз, в ячейке y вычисляется p(p(n + 17)) 

Рассмотрим  произвольную  инъективную  нумерацию  g  программ,  то 
есть нумерацию, ставящую в соответствие каждой программе P ее номер 
g (P),  причем  разным  программам  ставятся  разные  номера.  Программу 
назовем  самоприменимой  относительно  ячейки  x,  если  она,  получив  в 
ячейке x свой номер, а в остальных ячейках нули, через конечное число 
шагов завершает вычисления. 

Рассмотрим функцию p: N → N, определяемую следующим образом: 
p (n) = 1, если n является номером некоторой самоприменимой отно-

сительно ячейки x программы, 

p (n) = 0, в противном случае. 
Докажем, что функция p не вычислима никакой программой. Предпо-
ложим,  что  p  вычисляется  программой  P,  которая,  получив  в  ячейке  x 
число  n,  остановится  через  конечное  число  шагов  и  в  ячейке  y  оставит 
p (n). 

Рассмотрим программу P ′, изображенную на рис. 3 

P

y −

+

y +

137

получим  

[x]:=0 

противоречию. 
 
 
 
 
 
 
 
 

 

 

 

 

 
 
 
 
 

 

 

 

Рис. 3 

Если P ′ самоприменима относительно ячейки x, то p (g (P ′)) = 1, по-
этому, когда проработает программа, P в ячейке y будет записана 1 и ос-
тальная часть программы P ′, будет работать без остановки. Следователь-
но, P ′ не самоприменима относительно x. 

Если же P ′ не самоприменима относительно ячейки x, то p (g (P ′)) = 0, 
следовательно, когда проработает программа P, в ячейке y будет записан 
0 и тогда остальная часть программы P ′, сразу же завершит работу. Сле-
довательно, P ′ самоприменима относительно x. 

Итак, предположение о вычислимости функции p (n) в любом случае 

приводит к противоречию. 

 138

 

Глава 3. АЛГОРИФМЫ МАРКОВА 

Термин алгорифм является устаревшим вариантом современного тер-
мина  алгоритм,  однако,  по  отношению  к  алгоритмам  Маркова  принято 
использовать авторский вариант. 

Информация,  обрабатываемая  алгорифмом  Маркова,  представляется 

словом в некотором фиксированном алфавите A. 

Алгорифм  (программа)  представляется  последовательностью  пар 
слов  в  алфавите  A.  Пары,  составляющие  алгорифм,  называются  также 
подстановками и записываются в виде 

где α, β  –  слова  в  алфавите A,  причем β может быть пустым (обознача-      
ем λ). 

Программа имеет вид 

 

 
 
 

 

 

 

 

 

 

 

 

 

 

α → β 

α 1 → β1
α 2 → β2

...................
α i → βi! 

……………
α n → βn. 

Некоторые  подстановки  помечаются  восклицательным  знаком  и  называ-
ются заключительными. 

Функционирвание. Во входном слове ищется фрагмент, совпадающий 
с левой частью первой подстановки. Если такой фрагмент находится, то 
он во входном слове заменяется на ее правую часть, в противном случае 
рассматривается вторая подстановка из алгорифма и так далее. Вычисле-
ния заканчиваются когда ни одна из левых частей подстановок не являет-
ся  фрагментом  обработанного  к  данному  моменту  слова  или  когда  вы-
полнена заключительная подстановка. Заметим, что описанный таким об-
разом процесс может оказаться и бесконечным. 

Замечание.  Алгорифмы  Маркова  составляют  теоретическую  основу 

системы программирования, использующую язык РЕФАЛ. 

 

139

 

 

Пример   1. Алфавит A = {1, +}. Здесь запятая не является символом 

алфавита. 

 

 

 

 

 

Рассмотрим программу 
1.  1+ → +1, 
2.  ++ → +, 
3.  + → λ! 
Убедитесь в том, что она входное слово вида 11...1+11...11 перерабо-
тает в слово 11...1 в котором число символов «1» такое же как во входном 
слове. Можно считать, что программа выполняет сложение натуральных 
чисел, представленных в унарной системе счисления. 

 

 

 

 

Пример  2. Алфавит A = {1, *, v, z}. 
Программа 
1.  *11 → v*1 
2.  *1 → v 
3.  1v → v1z 
4.  zv →vz 
5.  z1 →1z 
6.  v1 → v 
7.  vz → z 
8.  z → 1 
9.  1 → 1!  
Рассмотрим  протокол  вычислений  на  входном  слове 11*111.  Справа 

 

 

 

 

 

 

 

 

 

указаны применяемые подстановки. 
 
 
 
 
 
 
 
 
 

11*111 
11v*11 
11vv*1 
11vvv 
1v1zvv 
v1z1zvv 
v1z1vzv 
v1zv1zzv 
v1vz1zzv 

 

 

 

 

 

* 11→ v*1 
* 11→ v*1 
* 1 →  v 
1v → v1z 
1v→  v1z 
zv → vz 
1v → v1z 
zv → vz 
1v → v1z 

 140

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

zv → vz 
vv1zz1zzv 
zv → vz 
vv1zz1zvz 
1v → v1z 
vv1zz1vzz 
zv → vz 
vv1zzv1zzz 
vv1zvz1zzz 
zv → vz 
vv1vzz1zzz  1v → v1z 
vvv1zzz1zzz  z1 → 1z 
vvv1zz1zzzz  z1 → 1z 
vvv1z1zzzzz  z1 → 1z 
vvv11zzzzzz  v1 → v 
v1 → v 
vvv1zzzzzz 
vz → z 
vvvzzzzzz 
vvzzzzzz 
vz → z 
vz → z 
vzzzzzz 
z →  1 
zzzzzz 
1zzzzz 
z →  1 
z →  1 
11zzzz 
z →  1 
111zzz 
1111zz 
z →  1 
z →  1 
11111z 
111111 
1 →  1! 

Если считать, что во входном слове закодирована задача умножения 

2*3 в унарной системе счисления, то в выходном слове получен ответ 6. 

Докажите,  что  программа  дает  верный  ответ  при  любом  корректном 

входном слове. 

 

 

 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

141

 

 

 

Глава 3. РАВНОДОСТУПНАЯ АДРЕСНАЯ МАШИНА 
Равнодоступная адресная машина (РАМ) – машина это числовая мо-
дель вычислительного устройства. Эта модель является наиболее близкой 
из  рассмотренных  к  реальным  вычислительным  машинам  и  позволяет 
наиболее реалистично применять теоретические оценки сложности алго-
ритмов к реальным вычислениям. 

Память машины состоит из регистров (ячеек). Каждый регистр имеет 
адрес и может содержать произвольное число. Регистр с номером 0 назы-
вается сумматором. 

Программа – последовательность пронумерованных команд. Команда 

имеет вид 

<код операции> <операнд> 

Коды операций: 
Load, Store, Add, Sub, Mult, Div, Read, Write, Jump, JgtZ, Jzero, Halt. 
Операнд может быть одного из трех видов  

= i, i, *i, 

где i – натуральное число.  

Содержимое регистра с номером i обозначим через c (i). Значение v(a) 

операнда a определяется в зависимости от его вида следующим образом 

 
 
 

 

 

 

 

 

 

 

 

 

 

 142

v(a) – число i, если a имеет вид 
v(a) – число c(i), если a имеет вид 
v(a) – число c(c(i)), если a имеет вид 

=i, 
i, 
*i. 

При оценке сложности алгоритмов используют в зависимости от об-
стоятельств разные веса команд. При работе с малыми числами и малым 
числом регистров реалистичным оказывается так называемый равномер-
ный вес при котором каждая команда требует единицу времени. При ра-
боте с большими числами и большим количеством регистров использует-
ся так называемый логарифмический вес команды при котором время вы-
полнения  команды  зависит  как  от  значения  операнда,  так  и от значения 
его адреса. 

 

 

При  определении  веса  команды  используется  функция  L: Z → Z,  вы-

ражающая длину записи числа  
 

iL
)(

=

i
log(
⎧
⎨
1
⎩

1)
+

при
при

i
i

≠
=

,0
.0

 

Основание  логарифма  при  получении  асимптотических  оценок  не 

имеет существенного значения. 

Вес t(a) операнда a определяется в зависимости от его вида следую-

щим образом 
 

 

 

 

 

 

 

t(a) = L(i), если a имеет вид 
t(a) = L(i) + c(i), если a имеет вид 
t(a) = L(i) + L(c(i)) + L(c(c(i))), если a имеет вид  

 

=i, 
i, 
*i. 

Действие 
 

с(0) := c(0) + v(a)  
с(0) := c(0) − v(a)  
с(0) := c(0)·v(a)  
с(0) := c(0) div v(a)  
c(i) := очередное число 

Команда 
 
с(0) := v(a)  
Load(a)  
Store(i)  
c(i) := c(0)  
Store(*i)   c(c(i)):=c(0)  
Add(a)  
Sub(a)  
Mult(a)  
Div(a)  
Read(i)  
Read(*i)   c(c(i)):= очередное число 
 
Write(a)   печать v(a)  
Jump(a)   переход на команду с номером a 
JgtZ(a)  
переход на команду с номером a, если c(0)>0  L(c(0)) 
Jzero(a)   переход на команду с номером a, если c(0)=0  L(c(0)) 
Halt(a)  

Логарифмический  
вес 
t(a) 
L(c(0)) + L(i)  
L(c(0)) + L(i) + L(c(i)) 
L(c(0)) + t(a) 
L(c(0)) + t(a) 
L(c(0)) + t(a) 
L(c(0)) + t(a) 
L(i) + L(c(i)) 
L(i) + L(c(i)) +  
L(c(c(i)) 
t(a) 
1 

конец вычислений 

1 

 

Например, команда Add *i имеет логарифмический вес 

L(c(0)) + L(i) + + L(c(i)) + L(c(c(i))). 

Временная  сложность  программы  определяется  как  сумма  весов 

143

 

 

всех выполненных команд с учетом их многократного выполнения. 

Емкостная сложность программы определяется как сумма по всем 

регистрам длин максимальных чисел побывавших в этих регистрах. 

Пример . Рассмотрим вычисление n 

n. На псевдокоде оно может вы-

глядеть следующим образом. 
 

Read(r1); 
if r1 < 0 then write (0) else 

 

 

 

 

{r2:= r1; r3:= r1−1; while r3<0 do {r2:= r2*r1; r3:= r3-1}; write (r2)}. 

Этот  псевдокод  легко  может  быть  представлен  в  виде  следующей 

РАМ-программы. 
 

1. Read 1
2. Load 1
3.  JgtZ 6 
4. Write = 0
5.
Jump 22
6. Load 1
7. Store 2
8. Load 1
9. Sub =1
10. Store 3
11. Load 3
12. JgtZ 
13. Jump 21
14. Load 2
15. MuLt 1
16. Store 2
17. Load 3
18. Sub 1
19. Store 3
20. Jump 11
21. Write 2
22. Halt

Когда команда 15 выполняется i-й раз, сумматор содержит n i, а r2 со-

держит n. Эта команда выполняется (n − 1) раз. 

При равномерном весовом критерии суммарное время – O(n). 
При  логарифмическом  весовом  критерии  суммарное  время  равно 

 

 144

 

 

i

 ) + L(n)), где суммирование ведется по i = 1, 2, …, n. Поскольку 

Σ (L(n 
(L(ni) + L(n)) ~ (i + 1) Log (n), получаем 

Емкостная  сложность  программы  при  равномерном  критерии  равна 

O(1), при логарифмическом – O (n Log n). 

 

 

Σ (L(n 

i)+L(n))= O (n2 log n). 

 

145

 

 

Глава 5. ФОРМАЛЬНЫЕ ЯЗЫКИ 

5.1. Основные понятия и обозначения 

Сверхслово (в алфавите А) – бесконечная последовательность симво-

лов (алфавита А). 

Формальный язык (в алфавите А) – множество слов (в алфавите А). 
Конкатенация  слов  –  двухместная  операция  над  словами,  заклю-
чающаяся  в  приписывании  второго  слова  к  первому.  Результат  конкате-
нации слов u и v обозначается uv. 

Начальный  фрагмент  слова  u,  имеющий  длину  k  ≤  |u|  называется 

вита А). 

Алфавит – конечное множество абстрактных символов, как правило, 

упорядочено, в так называемом алфавитном порядке. 

Слово (в алфавите А) – конечная последовательность символов (алфа-

Длина слова – количество вхождений символов в слово. Длина слова 

u, обычно обозначается |u|. 

Пустое  слово  –  пустая  последовательность,  то  есть  последователь-
ность, не содержащая ни одного символа. Пустое слово, соблюдая тради-
ции, часто обозначают греческой буквой λ, полагая при этом, что она не 
является символом рассматриваемого алфавита. 

Слово  длины  k  (k  >  0)  можно  отождествить  с  элементом  декартова 
произведения, (А × А × … × А) в котором k сомножителей и обозначаемо-
го Аk. При k = 0 имеем А0, состоящее из одного пустого слова, не путать с 
пустым множеством, обозначаемым знаком ∅.  

Замечание. При отождествлении элемента декартова произведения со 
словом,  полагаем,  что  слово  составлено  из  входящих  в  него  символов  в 
соответствующем порядке. 

Множество всех слов в алфавите А обозначают 
∪∞

=∪∪∪=

A
*

A
1

...

A

A

0

2

.
iA

 

i

=

0

  Множество всех непустых слов в алфавите А обозначают  

 

+

A

=∪∪=

A
1

...

A

2

∪∞

i

0
=

.
iA

 

 
 
 

 

 

 

 

 146

 

 

префиксом длины k слова u, обозначается prefk u. 

Конечный фрагмент слова u, имеющий длину k ≤ |u| называется суф-

фиксом длины k слова u, обозначается suffk u. 

Если k < |u|, то префикс и суффикс называются собственными. Заме-
тим,  что  при  нашем  определении  пустое  слово  λ  будет  и  собственным 
префиксом и собственным суффиксом любого слова u. 

Операции над формальными языками. Поскольку формальные языки 
являются  множествами,  то  к ним применяются обычные теоретико-мно-
жественные операции: объединение, пересечение, дополнение (до множе-
ства всех слов в рассматриваемом алфавите). Кроме перечисленных опе-
раций применяются специфические операции это конкатенация двух язы-
ков и итерация языка. 

Результатом конкатенации языков L1 и L2 является язык L = {uv | u ∈ 
L1,  v  ∈  L2},  обозначаемый  также  L1⋅L2.  Результат  конкатенации  к 
экземпляров языка L обозначим чер

Результатом итерации языка L является язык L* = {u | (∃ k ≥ 0) u ∈ Lk}. 

k
ез L . 

Заметим, что L0 = {λ} и поэтому λ ∈ L* при любом L. 

Замечание. При работе с формальными языками операцию объедине-
ния часто обозначают знаком “+”. В следующих тождествах используется 
именно это соглашение. 

Основные  тождества.  Пусть  α,  β,  γ  –  произвольные  формальные 
языки над некоторым фиксированным алфавитом, тогда справедливы сле-
дующие тождества. 
 

 

 

 

 

 

 

 

 

 

 

(α + β) + γ  = α + (β + γ), 
(α⋅β)⋅γ = α⋅(β⋅γ), 
α + β = β + α, 
α⋅(β + γ) = α⋅β + α⋅γ, 
(α + β)⋅γ = α⋅γ + β⋅γ, 
α⋅∅* = α, 
α⋅∅ = ∅, 
α* = α⋅α* + ∅*, 
α* = (α + ∅*)*. 

5.2. Способы задания формальных языков 

147

 

 

Прежде всего, для задания формального языка может подойти любое 
математически корректное определение множества слов в заданном алфа-
вите. Однако, если иметь в виду задание, при котором возможно алгорит-
мическое  решение  вопроса  о  принадлежности  слова  языку,  то  нужны 
средства более ограниченные. 

Наиболее общим из конструктивных способов задания языков являет-

ся способ, использующий так называемые формальные грамматики. 

Формальной грамматикой для порождения формального языка в ал-

фавите A называется  набор 
 

G = (A, B, S, P), 

где A – алфавит терминальных (основных) символов; B – алфавит нетер-
минальных (вспомогательных) символов, A ∩ B = ∅; S – стартовый сим-
вол, S ∈ B; P – конечный набор правил вывода. Каждое правило вывода 
имеет вид ϕ → ψ, где ϕ, ψ – слова в объединенном алфавите A ∪ B, при-
чем ϕ содержит хотя бы один символ из алфавита B. 

Правило  ϕ  →  ψ  применимо  к  слову  u,  если  ϕ  является  фрагментом 
слова u. Результатом применения этого правила к слову u называется сло-
во v, полученное заменой любого фрагмента ϕ в слове u на слово ψ. 

Если  v  –  результатом  применения  некоторого  правила  к  слову  u,  то 

Если u ⇒ v1⇒ v2⇒ …⇒ vn ⇒ v, то пишем u ⇒⇒ v. 
Язык  L(G),  порождаемый  грамматикой  G,  определяется  следующим 

пишем u ⇒ v. 

образом 

 

 

 

 148

L(G) = {v | v ∈ A*, S ⇒⇒ v}. 

Другими словами L(G) – множество слов в основном алфавите, кото-
рые могут быть получены из стартового символа S путем конечного числа 
применений правил грамматики. 

Классификация Хомского 
•  грамматики типа 0 это грамматики, не имеющие ограничений на вид 

правил; 

•  грамматики типа 1 это грамматики, в которых правила имеют вид: 
ϕ 1X ϕ 2 → ϕ 1v ϕ 2, где X – нетерминальный символ, а ϕ 1, ϕ 2, v – слова 
в  объединенном  алфавите.  Слова  ϕ 1,  ϕ 2  –  называются  контекстом 
правила. Эти грамматики (и языки, порождаемые ими) называются 
также контекстными, так как в описанном правиле символ X заме-
няется словом v, если находится в контексте ϕ 1, ϕ 2; 

 

 

•  грамматики типа 2 это грамматики, в которых правила имеют вид:  
X → v, где X – нетерминальный символ, а v – непустое слово в объе-
диненном  алфавите.  Эти  грамматики  (и  языки,  порождаемые  ими) 
называются также контекстно-свободными; 

•  грамматики типа 3 это грамматики, в которых правила имеют вид:  
X → v, где X – нетерминальный символ, а v – может иметь вид либо 
a, либо aY, где a – символ основного алфавита, а Y – вспомогатель-
ного. Языки, порождаемые грамматиками типа 3, называются регу-
лярными. 

ния; 

5.  (P⋅S) – регулярное выражение, если P и S – регулярное выражение; 
6.  P* – регулярное выражение, если P – регулярное выражение. 

 

149

 

 

Известно, что класс языков, задаваемых грамматиками типа 0, являет-
ся классом рекурсивно перечислимых языков, не совпадающим с классом 
рекурсивных  языков.  На  языке  теории  алгоритмов  это  означает,  что  не 
существует алгоритма, который по любой грамматике G типа 0 и любому 
слову  u  отвечает  на  вопрос  «u  ∈  L(G)?».  С  другой  стороны  существует 
алгоритм,  который,  получив  на  входе  грамматику  G  и  слово  u,  ответит 
«да», если, u ∈ L(G), в противном случае он либо ответит «нет», либо бу-
дет работать бесконечно. 

Классы языков, задаваемых грамматиками типа 1, 2, 3 является клас-

сами рекурсивных языков. 

Альтернативным  способом  задания  формальных  языков  является  их 

описание с помощью различных видов автоматов. 

Одним из простейших классов языков, имеющих большое прикладное 
значение, является класс регулярных языков, допускающих описание и с 
помощью конечных автоматов и с помощью аналитических выражений. 
 

5.3. Регулярные выражения 

Регулярные  выражения  это  аналитический  (формульный)  способ  за-

дания регулярных языков. 

Определение. Регулярным выражением над алфавитом A называется 

выражение, построенное по следующим правилам 

1.  ∅ – регулярное выражение; 
2.  λ– регулярное выражение; 
3.  a – регулярное выражение, если a ∈ A; 
4.  (P ∨ S) – регулярное выражение, если P и S – регулярные выраже-

 

 

Регулярное выражение R задает язык L(R) в соответствии со следую-

щими правилами: 

•  L(∅) – пустой язык, 
•  L(λ) – язык, состоящий из одного пустого слова, 
•  L(a) – язык, состоящий из одного однобуквенного слова a, 
•  L((P ∨ S)) = L(P) ∪ L(S), 
•  L((P⋅S)) = L(P)L(S), 
•  L(P*) = (L(P))*. 
Пример   1. Рассмотрим регулярное выражение R = (ab ∨ ac)*(a ∨ λ) 
над  алфавитом  A = {a, b, c}.  Язык  L(R)  состоит  из  слов,  в  которых  на 
нечетных местах стоит символ a, а на четных b или c. 

Замечание 1.  В  регулярных  выражениях  вместо  знака  «∨»  часто  ис-

пользуют знак «+». 

жений еще двумя правилами. 

ния; 

Замечание 2.  Если  дополнить  правила  построения  регулярных  выра-

7.  (P ∩ S) – регулярное выражение, если P и S – регулярные выраже-

8.  P –  регулярное  выражение,  если  P  –  регулярные  выражения,  и 
считать L((P ∩ S)) = L(P) ∩ L(S), а L( P ) = 
, где дополнение 
берется до множества всех слов в алфавите A, то получим, так 
называемые расширенные регулярные выражения. Если не исполь-
зовать  дополнение,  то  получим  полурасширенное  регулярное  вы-
ражение. 

(PL

Как  увидим  в  дальнейшем,  использование  расширенных  регулярных 

)

выражений не расширяет класса регулярных языков. 

Замечание 3.  Используя  описанную  интерпретацию  регулярных  вы-

ражений, мы вместо соотношения u ∈ L(R), писать u ∈ R. 
 
5.4. Решение уравнений в словах 

 

Рассмотрим уравнение вида X = α⋅X + β, где α и β – формальные язы-

ки над некоторым алфавитом A. 

Теорема. Если λ ∉ α, то уравнение X = αX + β имеет единственное 
решение X = α*β. Если λ ∈ α, то X = α*(β + γ) будет решением уравне-
ния X = αX + β при любом γ ∈ A*. 

Доказательство. Пусть λ ∉ α и X0 – решение, тогда, подставляя его в 

уравнение, получим 
 

 150

 

 

 

X0 = αX0 + β = α(αX0 + β) + β = α(α(αX0 + β) + β) + β = α3X0 + α2β + αβ + β. 
Продолжая выполнять подстановки, видим, что при любом k = 0, 1, 2, … 
выполняется равенство  
 
(1) 
 
 
Покажем сначала, что  α*⋅β  ⊆ X0. Действительно, пусть u ∈ α*⋅β, тогда 
при некотором значении k получим u ∈ (αkβ +αk−1β + … + αβ + β) и из 
(1) при таком значении k получаем u ∈ X0.

X0 = αk+1X0 + (αkβ + αk–1⋅β + … + αβ + β). 

Осталось показать, что X0 ⊆ α*β. Действительно, пусть u ∈ X0, тогда 

при любом k  

 

 

u ∈ αk+1⋅X0 + (αkβ +αk−1β + … + αβ + β). 

Но  так  как  λ  ∉  α,  то  при  достаточно  больших  значениях  k  каждое      

слово  во  множестве  αk+1⋅X0  будет  длиннее  слова  u  и,  следовательно,            
u ∉ αk+1⋅X0, но тогда при таких k  

 

 

 

 

 

u ∈ (αkβ +αk−1β + … + αβ + β) ⊆ α*β. 

Следовательно, u ∈ α*β. Итак, мы показали, что если X0 – решение, то 
оно  задается  формулой  X0  =  α*β,  то  есть  является  единственным.  Тот 
факт, что α*β на самом деле решение проверяется простой подстановкой. 

Второе утверждение теоремы предоставляем доказать читателю. 
Замечание.  Если  в  уравнении  X = αX + β  под  α  и  β  понимать  регу-
лярные  выражения,  то  в  случае  λ ∉ L (α),  его  единственным  решением 
будет регулярное выражение α*β. 

В случае, когда L(α) содержит λ, уравнение имеет бесконечно много 
решений  вида  X = α*(β + γ),  но  здесь  под  γ  можно  понимать  не  только 
регулярные  выражения,  но  и  выражения  в  каком  либо  формализме,  за-
дающие  произвольный  язык.  Часто  в  таком  случае  интересуются  наи-
меньшим по включению решением, так называемой «наименьшей непод-
вижной точкой». 

Системы  линейных  уравнений  с  регулярными  коэффициентами. 

Под стандартной системой понимают систему вида 
 

X1 = α11X1 + α12X2 + … + α1n Xn + β1, 
X2 = α21X1 + α22X2 + … + α2n Xn + β2, 
Xn = αn1X1 + αn2X2 + … + αnn Xn + βn, 

151

 

 

где αij, βi – регулярные выражения, Xi – переменные (i, j = 1, 2, …, n). 

Решением  системы,  называется  набор  (L(X1),  L(X2),  …,  L(Xn))  фор-
мальных  языков,  которые  при  подстановке  вместо  соответствующих  пе-
ременных  в  уравнения  обращают  их  в  равенства.  Удобно  на  решение 
смотреть как на отображение L, которое каждой переменной Xi ставит в 
соответствие  язык  L(Xi).  Решение  L1  называется  наименьшей  неподвиж-
ной  точкой  системы,  если  для  любого  другого  решения  L  выполняются 
соотношения L1(Xi) ⊆ L(Xi) при i = 1, 2, …, n. 

Теорема.  Каждая  стандартная  система  уравнений  имеет  единст-

венную неподвижную точку. 

)

i

L

)

i

=

∩

XL
(

XL
(1

Доказательство.  Действительно,  нетрудно  видеть,  что  отображение 
, где пересечение берет-

L1, определяемое по формулам
ся по всем решениям L, (i = 1, 2, …, n) является искомой неподвижной 
точкой системы. 

Решаются  такие  системы  уравнений  методом  исключения  неизвест-
ных. Если, например, α11 ≠ ∅, то первое уравнение можно представить в 
виде X1 = α11X1 + β, где β = α12 X2 + … +α1n Xn + β1, записать его реше-
ние описанным выше способом в виде (α11)*β и подставить в остальные 
уравнения. Получим систему с меньшим числом неизвестных и так далее. 
 

5.5. Автоматное задание языков 

Недетерминированные конечные автоматы с ε-переходами. Неде-
терминированным конечным автоматом  с ε-переходами над алфавитом A 
называется набор 

 

 

 

 152

ℜ = (Q, A, q0, F, ϕ), 

где Q – множество состояний, A – алфавит, Q0 – начальное состояние (q0 
∈ ∈ Q), F – множество финальных состояний (F ⊆ Q), ϕ: Q × (A ∪ {ε}) → 
2Q – переходная функция.  

Такой  автомат  можно  представить  нагруженным  ориентированным 
мультиграфом (диаграммой) следующим образом. Вершинами графа объ-
явить состояния, то есть элементы множества Q, и если q′∈ ϕ(q, x), то из 
состояния  q  в  состояние  q′  провести  дугу,  помеченную  символом  x  ∈ 
∈ (A ∪ {ε}). 

Язык L(ℜ), порождаемый автоматом ℜ, состоит из всех слов, которые 
можно прочитать, двигаясь, начиная со стартового состояния q0, по реб-
рам и читая приписанные им символы. Чтение заканчивается в любом из 

 

 

финальных состояний множества F не обязательно при первом туда попа-
дании. При чтении символов воспринимать ε как пустое слово. 

Пример   2. Пусть алфавит A = {a, b, c}, Q = {q0, q1, q2}, F = {q1} и 

переходная функция ϕ задана таблицей 
 

 

q0
q1
q2

ε 
{q1} 
∅ 
{q1} 

{q1, q2} 

a 

∅ 
∅ 

b 
∅ 
{q0} 
∅ 

c 
∅ 
{q0} 
∅ 

 

 

 

Диаграмма автомата изображена на рис. 1. Заметим, что язык, порож-
даемый  этим  автоматом,  совпадает  с  языком,  задаваемым  регулярным 
выражением из примера 1.  
 
 
 
 
 
 
 
 
 
 
 

q0

q1

b

c

ε 

ε 

a

a

q2
Рис. 1 

Недетерминированные конечные автоматы без ε-переходов.  Неде-
терминированным конечным автоматом без ε-переходов над алфавитом A 
называется набор 
 

ℜ = (Q, A, q0, F, ϕ), 

где  Q  –  множество  состояний,  A  –  алфавит,  q0  –  начальное  состояние 
(q0 ∈ Q), F – множество финальных состояний (F ⊆ Q) и ϕ: Q × A → 2Q – 
переходная функция. Такой автомат также можно представить нагружен-
ным  ориентированным мультиграфом (диаграммой). Отличие в том, что 
дуги могут быть помечены только символами алфавита A.  

Язык  L(ℜ),  порождаемый  таким  автоматом  ℜ,  состоит  из  всех  слов, 
которые можно прочитать, двигаясь, начиная со стартового состояния q0, 
по ребрам и читая приписанные им символы. Чтение заканчивается в лю-
бом из финальных состояний множества F не обязательно при первом ту-

 

153

 

 

 

 

ℜ = (Q, A, q0, F, ϕ), 

да попадании. 

Детерминированные конечные автоматы. Детерминированным ко-

нечным автоматом над алфавитом A называется набор 

где  Q  –  множество  состояний,  A  –  алфавит,  q0  –  начальное  состояние 
(q0 ∈ Q), F – множество финальных состояний (F ⊆ Q) и ϕ: Q × A → Q – 
переходная функция. Такой автомат также можно представить нагружен-
ным ориентированным мультиграфом (диаграммой). Отличие от недетер-
минированного автомата в том, что из каждого состояния выходит ровно 
одна дуга, помеченная  конкретной буквой алфавита A причем для каждой 
буквы алфавита такая дуга существует.  

Язык  L(ℜ),  порождаемый  таким  автоматом  ℜ,  определяется  анало-

гично тому, как это было для недетерминированных автоматов. 

Теорема. Классы языков, задаваемые регулярными выражениями, не-
детерминированными конечными автоматами с ε-переходами, недетер-
минированными  конечными  автоматами  без  ε-переходов,  детерминиро-
ванными конечными автоматами совпадают. 

Доказательство.  Для  доказательства  достаточно  по  каждому  регу-
лярному  выражению,  научиться  строить  равносильный  недетерминиро-
ванный конечный автомат с ε-переходами (синтез), затем избавляться от 
ε-переходов,  затем  детерминизировать,  и,  наконец,  по  детерминирован-
ному автомату строить регулярное выражение (анализ). 

Синтез.  Регулярное  выражение  ∅  представляется  автоматом  ℜ  = 
= (Q, A, q0, F, ϕ), где Q ={q0, q1}, алфавит A – произволен, q0 – начальное 
состояние,  F  ={q1}  –  множество  финальных  состояний  и  переходная 
функция ϕ задается соотношениями (∀x ∈ A ∪ {ε}) ϕ(q0, x) = ∅, ϕ(q1, x) 
= ∅. 

Регулярное  выражение  λ  представляется  автоматом  ℜ = (Q, A, q0, F, 
ϕ),  где  Q = {q0, q1},  алфавит  A  –  произволен,  q0  –  начальное  состояние, 
F = {q1} – множество финальных состояний и переходная функция ϕ за-
дается  соотношениями ϕ (q0, ε) = {q1}, ϕ(q1, ε) = ∅ и (∀x ∈ A)ϕ (q0, x) = 
∅, ϕ (q1, x) = ∅. 

Регулярное выражение a (a ∈ A) представляется автоматом ℜ = (Q, A, 
q0, F, ϕ), где Q = {q0, q1}, q0 – начальное состояние, F = {q1} – множество 
финальных состояний и переходная функция ϕ задается соотношениями 
ϕ (q0, a) = {q1}, (∀x ∈ (A ∪ {ε}) \ {a}) ϕ (q0, x) = ∅, и (∀x ∈ (A ∪ {ε})) 

 154

 

 

ϕ (q1, x) = ∅. 

Для регулярного выражения (P ∨ S), где P и S – регулярные выраже-
ния, можно построить задающий автомат ℜ = (Q, A, q0, F, ϕ) следующим 
образом.  Пусть  автомат  ℜ1 = (Q1, A, q1, F1, ϕ1)  задает  L (P),  а  автомат 
ℜ2 = (Q2, A, q2, F2, ϕ2)  задает  L(S).  Не  уменьшая  общности  можно  счи-
тать, что F1 = {f1} и F2 = {f2} – одноэлементные и что q1 ≠ f1 а q2 ≠ f2. По-
ложим Q = Q1 ∪ Q2 ∪ {q0, f }, где q0, f – новые состояния и поясним по-
строение автомата ℜ на языке диаграмм. Состояние q0 соединим дугами 
со стартовыми состояниями q1, q2 автоматов ℜ1, ℜ2 и пометим их симво-
лом ε. Состояния f1 и f2 автоматов ℜ1, ℜ2 соединим дугами с новым со-
стоянием f и пометим их также символом ε. Начальным состоянием по-
строенного автомата объявим q0, а финальным – f. 

Для регулярного выражения P⋅S, где P и S – регулярные выражения, 
можно построить задающий автомат ℜ = (Q, A, q0, F, ϕ) следующим об-
разом.  Пусть  автомат  ℜ1 = (Q1, A, q1, F1, ϕ1)  задает  L(P),  а  автомат 
ℜ2 = (Q2, A, q2, F2, ϕ2) задает L(S). Не уменьшая общности, опять счита-
ем, что F1 = {f1} и F2 = {f2} – одноэлементные и что q1 ≠ f1 а q2 ≠ f2. Поло-
жим Q = Q1 ∪ Q2 и поясним построение автомата ℜ на языке диаграмм. 
Финальное состояние автомата ℜ1 соединим дугой со стартовым состоя-
нием автомата ℜ2 и пометим ее символом ε. В качестве q0 возьмем стар-
товое состояние автомата ℜ1, а в качестве финального состояния f возь-
мем финальное состояние f2 автомата ℜ2. 

Для регулярного выражения P*, где P – регулярное выражение, мож-
но построить задающий автомат ℜnew = (Q, A, q0, {f0}, ϕ) следующим об-
разом.  Пусть  автомат  ℜ1 = (Q1, A, q1, {f1}, ϕ1)  задает  L(P).  Опять  не 
уменьшая общности, считаем, что F1 = {f1} – одноэлементное и что q1 ≠ f1. 
Добавляем  к  множеству  Q1  два  новых  состояния  q0,  и  f0.  Соединяем  ε-
переходами пары состояний (q0, q1), (f1, f0), (q0, f0) и (f1, q1). 

В завершение заметим, что изложенные приемы очевидно позволяют 
по  любому регулярному выражению R построить недетерминированный 
автомат  ℜ  с  ε-переходами,  с  одним  стартовым  и  одним  финальным  со-
стоянием, причем стартовое состояние отлично от финального и при этом 
такой, что L(R) = L(ℜ). 

Таким образом, задача синтеза решена. 
Избавление от ε-переходов. Покажем как по недетерминированному 
автомату  ℜ  =  (Q, A, q0, F, ϕ)  с  ε-переходами  построить  недетерминиро-

 

155

 

 

ванный  автомат  ℜ1  =  (Q, A, q0, F1, ϕ1),  без  ε-переходов  такой,  что 
L(ℜ1) = L(ℜ). Назовем  ε-путем путь в диаграмме автомата ℜ, возможно 
пустой, порождающий пустое слово. Обозначим через λ(q) – множество 
состояний, достижимых из q с помощью некоторого ε-пути. 

Положим F1 = {q| существует ε-путь из q в F}. Переходную функцию 

 

ϕ1 построим следующим образом 
aq
),(1
ϕ

=

∪

1
q
λ∈

(

aq
),
1

, 

(
ϕ
q
)

Заметим,  что  в  полученном  автомате  множество  финальных  состояний 
может быть не одноэлементным. 

Детерминизация. Покажем, как по недетерминированному автомату 
ℜ = (Q, A, q0, F, ϕ) без ε-переходов построить детерминированный авто-
мат  ℜ1 = (Q1, A, q1, F1, ϕ1),  такой,  что  L(ℜ1) = L(ℜ).  Положим  Q1 = 2Q, 
q1 = {q0}, F1= {q| (q ⊆ Q) & (q ∩ F ≠ ∅)}, а ϕ1: Q1 × A → Q1 определим 
следующим образом 
(
∈∀

as
,(
ϕ

aq
,(

Aa
)
)(
ϕ∈∀
1

Qq
1

=

)

)

. 

∪

qs
∈

Нетрудно видеть, что построенный таким образом автомат ℜ1 удовле-

творяет условию L(ℜ1) = L(ℜ). 

Анализ. Для завершения доказательства теоремы покажем, как по за-
данному детерминированному конечному автомату ℜ построить регуляр-
ное выражения R такое, что L(R) = L(ℜ). Именно это и называем задачей 
анализа.  Правда,  метод,  который  мы  используем,  можно  применить  и  к 
недетерминированным автоматам. Метод заключается в том, что мы сво-
дим  задачу  к  решению  стандартной  системы  уравнений.  Итак,  рассмот-
рим автомат ℜ = (Q, A, q0, F, ϕ). 

Пусть Q = {q0, q1, …, qn}, A = {a1, a2, …, am}. Введем переменные 
X(q0), X(q1), …, X(qn). Переменную X(qi) для каждого i = 0, 1, …, n, будем 
интерпретировать  как  множество  слов, которые можно прочитать, начи-
ная с состояния qi и заканчивая в финальном состоянии, тогда X(qi) долж-
на удовлетворять уравнению 

X(qi) = a1⋅X(ϕ(qi, a1)) + a2⋅X(ϕ(qi, a2)) + …+ am⋅X(ϕ(qi, am)) + βi , 

где βi = λ, если qi ∈ F, βi = ∅, если qi ∉ F. Решив систему, берем в каче-
стве ответа значение переменной X(q0). 

Задача .  Построить  регулярное  выражение,  задающее  язык,  порож-

 

 

 

 

 156

 

 

даемый автоматом ℜ = (Q, A, q0, F, ϕ), где Q = {q0, q1, q2, q3}, A = {a, b}, 
F = {q3} и функция ϕ задана таблицей 
 

 
q0
q1
q2
q3

a 
q3
q3
q2
q1

b 
q1
q2
q3
q3

Q0

a 

Q3

b 

a

b

a

a

Q1

b

Q4

a

a
Рис. 2 
Решение. Запишем систему уравнений 
X0 = a X3 + b X1, 
X1 = a⋅X3 + b X2, 
X2 = a X2 + b X3, 
X3 = a X1 + b X3 + λ. 

 
 
 
 
 
 
 
 
 
 
 
 

 

 

 

 

 

 

 

 

 

 

 

Заметим,  что  при  записи  системы  мы  упростили  обозначения  пере-

менных используя индексы. 

Из четвертого уравнения получаем X3 = b*(a⋅X1+λ). Подставляя полу-
ченное выражение во все остальные уравнения, получим систему из трех 
уравнений 

X0 = a ⋅b*(a⋅X1 + λ) + b⋅X1, 
X1 = a⋅b*(a⋅X1 + λ) + b⋅X2, 
X2 = a⋅X2 + b⋅b*(a⋅X1 + λ). 

Перепишем ее в стандартном виде 

157

 

 

X0 = (a⋅b*⋅a + b) X1+ a⋅b*, 
X1 = a⋅b*⋅a⋅X1 + b⋅X2 + a⋅b*, 
X2 = b⋅b*⋅a⋅X1 + a⋅X2 + b⋅b*. 

Из третьего уравнения получаем X2 = a*(b⋅b*⋅a⋅X1 + b⋅b*), и подстав-

ляем в остальные уравнения 

X0 = (a⋅b*⋅a + b) ⋅X1 + a⋅b*, 
X1 = a⋅b*⋅a⋅X1 + b⋅a*⋅(b⋅b*⋅a⋅X1 + b⋅b*) + a⋅b*. 

Преобразуем второе уравнение к стандартному виду 

X1= (a⋅b*⋅a + b⋅a*⋅b⋅b*⋅a) ⋅X1 + b⋅a*⋅b⋅b* + a⋅b* 

и получаем из него 

Наконец, получаем ответ 

X1 = (a⋅b*⋅a + b⋅a*⋅b⋅b*⋅a)* (b⋅a*⋅b⋅b* + a⋅b*). 

 

 

 

 

 

 

 

 

 

 

 

 

 

X0 = (a⋅b*⋅a + b) (a⋅b*⋅a + b⋅a*⋅b⋅b*⋅a)* (b⋅a*⋅b⋅b* + a⋅b*) + a⋅b*. 

 

5.6. Применение конечных автоматов в программировании 
Задача .  По  заданному  регулярному  выражению  α  над  алфавитом 
A = {a1,  a2,  …,  an}  найти  в  тексте  x  наименьший  префикс,  содержащий 
слово из L(α). 

Решение. Строится регулярное выражение β = (a1 ∨ a2 ∨ …∨ an)*⋅α 
и  для  него  недетерминированный  конечный  автомат  с  ε-переходами. 
Пусть это будет автомат ℜ = (Q, A, q0, F, ϕ). Если при чтении текста x 
построенным автоматом мы приходим в финальное состояние, то это оз-
начает, что мы прочитали префикс текста x, содержащий слово из языка 
L(α). 

Алгоритм,  моделирующий  работу  недетерминированного  конечного 

автомата ℜ с ε-переходами на входном слове x = x1x2…xn ∈ A* 
 
 
 
 

Q0:= {q0};  
for i := 1 to n do Qi:=  ∪

ixq
,(
ϕ
iQq
−∈
1

)

; 

 158

 

 

Пометить все состояния из Qi как рассмотренные; 
Пометить все состояния из Q \ Qi как нерассмотренные; 
Все состояния из Qi поместить в Очередь; 
While Очередь не пуста do 
 
 
 
 

{t := головной элемент из очереди (с удалением); 
For u ∈ ϕ(t, ε) & u – не рассмотрен do 

{Пометить u как рассмотренное; 
Поместить u в хвост Очереди и в Qi}} 

 
Оценим трудоемкость приведенного алгоритма. Пусть |Q| = m, |ϕ(q, a)| ≤ 
e, тогда тело цикла «while» оценивается как O(e), а тело цикла «for i := 1 
to n do» как O(e⋅m) и весь алгоритм имеет трудоемкость O(e⋅m⋅n). 

Анализируя  алгоритм  построения  автомата  ℜ  =  (Q, A, q0, {f  }, ϕ)  с        

ε-переходами по регулярному выражению β, легко установить следующие 
свойства: 

• 

|Q|<2⋅|β|, где |β| – длина выражения β с учетом скобок и символов 
операций; 

•  q0 ≠ f ; 
•  (∀x ∈ (A ∪ {ε})) ϕ(f, x) = ∅; 
•  (∀q ∈ Q)
. 

xq
),(

≤|

2

ϕ|∑

ε∪∈ Aa

}){

(

Учитывая  приведенные  свойства,  можем  теперь  алгоритм,  модели-

рующий работу автомата ℜ оценить величиной O(n⋅|β|). 

Рассмотрим  теперь  более  частную  по  отношению  к  задаче  2  задачу, 

когда вместо регулярного выражения α задано одно слово-образец y. 

Задача   3. Требуется найти вхождение заданного слова-образца y = 
= y1 y2 … yn в слово-текст x = x1 x2 … xm или установить, что такого вхож-
дения нет. 

Определение. По данному образцу y определим функцию Sy: A*→ A*, 
следующим образом: (∀x ∈ A*) Sy(x) – наибольший префикс слова y, яв-
ляющийся суффиксом слова x. 

Очевидно, (∀x ∈ A*) ⎪Sy(x)⎪ = max{k⎪prefk y = suffk x}. 
Утверждение 1. Для любой строки x и любого символа a ⎪Sy(xa)⎪ ≤ 

≤ ⎪Sy (x)⎪ + 1. 

Действительно,  пусть  ⎪Sy(xa)⎪ > ⎪Sy(x)⎪ + 1  и  Sy(xa) = ua,  тогда 
⎪ua⎪ > ⎪Sy(x)⎪ + 1,  а  u  будет  префиксом  и  суффиксом  строки  x,  причем 
⎪u⎪ > ⎪Sy(x)⎪, что противоречит определению ⎪Sy(x)⎪. 

 

159

 

 

Утверждение 2.  Пусть  q = ⎪Sy(x)⎪,  тогда  для  любого  символа  a 

⎪Sy(xa)⎪ = ⎪Sy(y1 y2 … yqa)⎪. 

Действительно,  по  предыдущему  утверждению,  ⎪Sy (xa)⎪ ≤ q + 1,  по-
этому  значение  ⎪Sy (xa)⎪  не  изменится,  если  от  строки  xa  оставить  по-
следние q + 1 символов, а именно y1 y2 … yq a. 

Построим  по  слову-образцу  y = y1 y2  …  yn  конечный  автомат  ℜ  = 
= (Q, A, q0, {f }, ϕ), где Q = {0, 1, …, n}, q0 = 0, f = n, а переходную функ-
цию  ϕ  определим  следующим  образом  (∀q ∈ Q)(∀a ∈ A)  ϕ (q,  a)  = 
= ⎜Sy(y1 y2 … yqa)⎜.  Для  построенного  автомата,  очевидно  будет  справед-
ливо следующее утверждение. 

Утверждение 3. Прочитав текст x, автомат ℜ = (Q, A, q0, {f }, ϕ) 

будет находиться в состоянии ⎜Sy(x)⎜. 

Алгоритм вычисления функции переходов: 
n := length(y); 
for q:= 0 to n do for a ∈ A do k := min{n + 1, q + 2}; 
repeat k := k – 1 until y1y2…yq = suff (y1 y2 … yq a); 
ϕ (q, a) := k 

 

 

Время работы этого алгоритма O(n3 ⎜A ⎜). 

Пример . Пусть алфавит A = {a, b} и Y = aabbaab. Допустим, что, 
читая  текст  x,  мы  обнаружили,  некоторый  префикс  x1x2…xi  слова  x,  за-
канчивающийся  фрагментом aabbaa,  являющимся  префиксом  слова Y, а 
следующий символ xi+1 в тексте x не равен b, то есть не совпадает с оче-
редным символом слова Y. Считаем, что потерпели неудачу, но при этом 
заметим,  что  суффикс  aa  этого  фрагмента  является  его  префиксом  и 
возможно  он  является  префиксом  некоторого  вхождения  слова  Y  в  x. 
Делая такое предположение, продолжаем читать x, сравнивая очередные 
символы  слова  x  с  соответствующими  начиная  с  третьего  символами 
слова Y в надежде на этот раз обнаружить его вхождение в x. 

Таким образом, читая x, будем считать, что мы в каждый момент на-
ходимся в некотором состоянии j, если только что прочитан префикс Y ′ 
слова Y длины j. Если при чтении следующего символа терпим неудачу, 
то переходим в новое состояние j ′, такое что j ′ – максимальный префикс 
слова  Y ′,  являющийся  его  суффиксом.  Функцию,  которая  состоянию  j 
ставит в соответствие j ′, называют функцией откатов. В нашем примере 
ее можно изобразить следующей диаграммой. 
 

a 

a 

b

b

a

a

b 

 160

 

a 

1
1

0 
0 

a 

b 

2 
2 

b 

4
4

3
3

a 

5
5

a 

6
6

b 

7 
7 

Рис. 3 

 

 

Введем необходимые обозначения. Пусть Y – непустое слово в неко-
тором алфавите, а L(Y) – наибольший собственный префикс слова Y, яв-
ляющийся его суффиксом, тогда справедливы следующие утверждения 

1. Слова L2(Y), L3(Y), … являются собственными префиксами и суф-

2.  Последовательность  L(Y),  L2(Y),  L3(Y),  …  обрывается  на  пустом 

фиксами слова Y. 

слове. 

3.  Любое  префикс  слова  Y,  являющийся  его  суффиксом  находится  в 

последовательности L(Y), L2 (Y), L3 (Y), … 

Пример . Пусть Y = abbabbabbacabbab. Тогда 

 

 

 

 

 

 

 

 

 

 

 

L (Y) = abbab, 
L2 (Y) = ab, 
L3 (Y) = λ. 

Определение.  Функцией  откатов  для  слова  Y = Y1Y2…Yn  называют 
функцию f : {1, 2, …, n}→{0, 1, 2, …, n – 1}, определяемую соотношени-
ем f (i) = | L(pref iY ) |, где pref iY − префикс длины i слова Y. 

В нашем примере функция f (i) задается следующей таблицей 

i 
f (i) 

1 
0 

2 
0 

3 
0 

4 
1 

5 
2 

6 
3 

7 
4 

8 
5 

9  10  11  12  13  14  15  16 
6 
5 

7 

0 

3 

4 

2 

1 

Алгоритм Кнута − Морриса − Пратта построения функции откатов для 

слова Y = Y1 Y2 … Yn : 

 
 
f (1) := 0; 
for i :=1 to n – 1 do 

begin 

j := f (i); 

161

 

 

while (Y [j + 1] ≠ Y [i + 1]) &(j > 0) do j := f [j]; 
if Y [j + 1] = Y [i + 1] then f [i + 1] := j + 1 else f [i +1] := 0; 

end 

Для разъяснения работы алгоритма рассмотрим ситуацию, возникшую 
при обработке слова Y на шаге i = 9. К этому моменту вычислены значе-
ния f (i) при i = 1, 2, …, 9 

 

i 

1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16 
a  b 

Y =  a  b  b  a  b  b  a  b  b  a 

a 

b 

b 

c 

f (i) =  0  0  0  1  2  3  4  5  6 

Выполняем j := f [i] (= 6). Видим, что условие во внутреннем цикле не 
выполняется  из-за  первого  сомножителя,  так  как  Y [i + 1] = Y [j + 1],  по 
этому тело внутреннего цикла не выполняется и, далее, в соответствии с 
алгоритмом вычисляем f [i + 1] := j + 1 (= 7) и i := i + 1 (= 10). 

Пришли к следующей ситуации i = 10 

 
 
 
 

i 

1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16 
a  b 

a 

b 

b 

c 

Y =  a  b  b  a  b  b  a  b  b  a 
f (i) = 0  0  0  1  2  3  4  5  6  7 

Вычисляем j := f [i] (= 7). 
Видим, что условие (Y [i + 1] ≠ Y [j + 1] & j > 0) во внутреннем цикле 
выполняется.  Следовательно,  вычисляется  новое  значение  j := f [j] (= 4); 
условие опять выполнено, вычисляем новое j := f [j] = 1 и на этот раз ус-
ловие  выполняется,  снова  вычисляем j := f [j] (= 0).  Наконец  внутренний 
цикл завершается, причиной завершения является невыполнение условия 
(j > 0) и поэтому f [i + 1] := 0. Итак, вычислено f [11] = 0. 

Оценим  трудоемкость  алгоритма.  Обработка  очередной  буквы 
Y [i + 1] может потребовать многих итераций во внутреннем цикле. Обо-
значим  их  число  через  Ni.    Заметим,  что  каждая  итерация  внутреннего 
цикла уменьшает j по крайней мере на 1. С другой стороны переход к сле-
дующему  значению  i  увеличивает  j  не  более  чем  на  1.  Таким  образом, 
имеем неравенства 

 

 

 

 
 
 

 

 

 

 или 

 

 162

F [i + 1] ≤ f [i] – Ni + 1 

Ni ≤ f [i] – f [i + 1] + 1. 

 

 

Суммируя последнее неравенство по i от 1 до n – 1, получим 

n

1
−

=∑

N

i

i

1
=

f

]1[

−

nf
][

≤−+

1

n

n

. 

 Отсюда трудоемкость оценивается сверху величиной O(n). 

Построение детерминированного конечного автомата по функции 
откатов. Задача заключается в том, чтобы построить конечный      авто-
мат,  который,  читая  произвольный  текст,  приходил  бы  в  финальное  со-
стояние, обнаружив фрагмент, совпадающий с заданным словом             Y 
= Y1 Y2 … Yn. 

Изложенный ниже алгоритм строит переходную функцию ϕ автомата  

ℜ = (Q, A, q0, {f }, ϕ), 

где Q = {0, 1, 2, …, n}, q0 = 0, f = n.  

Предполагаем, что функция откатов f  уже построена. 
for j := 1 to n do ϕ [j – 1, Yj]:= j; 
for a ∈ A, a ≠ Y1 do  ϕ [0, a]:= 0; 
for j :=1 to n do for a ∈ A, a ≠ Yj+1 do  ϕ [j, a] := ϕ [f [j], a]; 
Для слова Y = aabbaab получим автомат, заданный диаграммой, изо-

 

 

 

 

 

 

 

 
 
 

 

 

 

b 

браженной на рис. 4. 
 
 
 
 
 
 
 
 
 
 
 

b 

a 

1 

0

a 

2

a
b

a

b

a
b

3

b

a

a

4

5

b

6

7

a

b
Рис. 4 

Глава 6. ЛОГИЧЕСКОЕ ПРОГРАММИРОВАНИЕ 

Теоретические исследования математических моделей вычислений иг-

163

 

 

рают  важную  роль  в  формировании  технологии  использования  компью-
терной  техники.  Каждая  такая  модель  вносит  свой  вклад  в  реальную 
технологию.  Развитие  технологии  в  обход  теоретических  исследований 
часто  приводит  к  неуклюжим  трудно  понимаемым  и,  в  конечном  счете, 
малопроизводительным видам деятельности. 

Исследования универсальных методов доказательства в рамках логики 
предикатов  дают повод для разработки на их основе новых языков про-
граммирования.  Опыты  по  использованию  этих  методов  проведенные  в 
70-е  годы  прошлого  века  показали  перспективность  их  использования  в 
реальных технологиях автоматической переработки информации. 

В настоящее время в рамках так называемого логического программи-
рования  ведутся  исследования  по  использованию  различных  стратегий 
поиска доказательств утверждений, сформулированных в языке предика-
тов,  и  в  частности  известного  в  математической  логике  метода  резолю-
ций. Эти стратегии реализованы в настоящее время в нескольких версиях 
языка Пролог (Эрити пролог, Турбо пролог и др.). 
 
6.1. Язык предикатов 

Формулы языка предикатов строятся из предикатных и функциональ-
ных  символов  с  помощью  логических  связок  кванторов  и  некоторых 
вспомогательных символов. Набор предикатных и функциональных сим-
волов  заранее  не  фиксируется,  а  выбирается  из  содержательных  сообра-
жений, связанных с желанием строить высказывания о тех или иных объ-
ектах или их свойствах и отношениях между ними. С каждым предикат-
ным  символом  связывается  натуральное  число,  его арность (число аргу-
ментов). 

«Строительные материалы», из которых конструируются формулы и 

2.  Символы  для  конструирования  переменных:  (по  традиции)  латин-
ская буква x и ′ (штрих). Отдельную букву x или x с несколькими штри-
хами будем считать переменной. Делая такой выбор, мы подчеркиваем то 
обстоятельство, что используем всего два символа, для образования лю-
бого  конечного  множества  переменных.  На  практике,  конечно,  это  не 
удобно, поэтому используются и другие символы, возможно с индексами. 
Контекст не позволит нам «заблудиться». 

3. Вспомогательные символы: прямые и круглые скобки и запятая. 

предложения языка предикатов. 

1. Логические связки и кванторы:  

& ∨ ¬  → ∀ ∃. 

 

 

 

 164

 

 

4. Предикатные и функциональные символы. 
 Замечания  
•  Предикатные  символы  используются  для  обозначения  предложе-
ний, в которых некоторые слова заменены переменными, так что 
при замене переменных именами конкретных объектов получают-
ся  высказывания  об  этих  объектах,  которые  можно  оценить  при 
определенных обстоятельствах как истинные или ложные. Каждое 
такое предложение называется высказывательной формой, а коли-
чество k различных переменных, входящих в такое предложение – 
ее арностью или местностью. Например, предложение: «Река x яв-
ляется притоком реки y» – двухместная форма, которая при замене 
переменной y на собственное имя Волга, превращается в одноме-
стную форму. «Река x является притоком реки Волга». А если еще 
и  переменную x  заменить  именем  Ока,  то  получим  истинное  вы-
сказывание. Если же переменную x заменить именем Енисей, то – 
ложное.  

•  При k = 0 имеем дело с конкретным высказыванием. 
•  Функциональные с мволы используются для о озна ения отобра-

и

б

ч

жений (функций). 

мулы. 

 

•  Нульместные функции называются также константами. 
Основными конструкциями языка предикатов являются термы и фор-

Правила образования термов 
1.  Любая переменная или константа является термом. 
2.  Если f – функциональный k-местный символ, а t1, t2, …, tk – термы, 

то выражение f (t1, t2, …, tk) является термом. 

Замечания 
•  Многоточие, используемое в определении терма, не следует пони-
мать буквально, поскольку таких символов в нашем распоряжении 
нет. При любом конкретном значении k мы обходимся без много-
точий. 

•  Если в терме нет переменных, то он интерпретируется как имя не-
которого  объекта,  если  же  переменные  есть,  то  терм  удобно  рас-
сматривать как схему для образования имени. Например, Sin (x) – 
терм, который при замене переменной x константой 1 превращает-
ся в терм Sin (1), являющийся именем вполне конкретного числа, 
хотя и не традиционным. Под выражением Sin мы понимаем здесь, 

 

165

 

 

функциональный  символ,  хотя  и  состоящий  из  трех  латинских 
букв. 

•  В термах, построенных с помощью функциональных двухместных 
символов,  традиционно  используется  инфиксная  форма  записи, 
при  которой  знак  функции  помещается  между  аргументами,  на-
пример,  пишется  x + y  вместо  + (x, y).  Аналогичное  замечание 
справедливо также и для двухместных предикатов. 

 

Правила образования формул 
1.  Если p – k-местный предикатный символ, а t1, t2, …, tk – термы, то 

выражение p(t1, t2, … tk) является формулой (атомарной). 

2.  Если A и B – формулы, то выражения [A & B], [A ∨ B], [A → B] и 

3.  Если A – формула, а y – переменная, то выражения ∀y A, ∃y A яв-

¬A являются формулами. 

ляются формулами. 

Замечания 
•  В правиле 3. формула A называется областью действия соответст-
вующего  квантора,  а  все  вхождения  переменной  y  в  атомарные 
подформулы формулы A называются связанными. 

•  Переменная,  имеющая  вхождение  в  атомарную подформулу фор-
мулы  A  не  находящуюся  в  области  действия  соответствующего 
квантора, называется свободной переменной формулы A. Конечно, 
одна  и  та  же  переменная  может  иметь  как  связанные,  так  и  сво-
бодные вхождения в формулу. 

•  Формула, не имеющая переменных со свободными вхождениями, 

называется предложением. 

•  Формулы  со  свободными  переменными  трактуются  как  высказы-
вательные формы, а предложения – как высказывания, истинност-
ная  оценка  которых  зависит  от  интерпретации,  входящих  в  них 
предикатных  и  функциональных  символов  в  соответствии  со 
смыслом логических связок и кванторов. 

Пример .  Пусть  нелогическая  сигнатура  состоит  из  трех  символов 

{E, M, S},  где  E  –  двухместный  предикат,  S  –  одноместная  функция,      
M – двухместная функция, тогда выражение 

∀z ∀y E (M (S (z), S (y)), S (M (z, y))), 

очевидно, будет формулой. Поскольку в этой формуле нет свободных пе-
ременных, то она является предложением. 

Рассмотрим  следующую  интерпретацию  нашей  сигнатуры.  Пусть 

 

 

 166

 

 

универсом рассуждения будет множество точек плоскости, это означает, 
что значениями переменных являются точки. Далее, пусть 
M (z, y) – точка, являющаяся серединой отрезка (z, y),  
S (z) – точка, симметричная точке z относительно некоторой заранее 

выбранной точки, 

E (z, y) – предикат, означающий равенство точек z и y. 
При такой интерпретации нелогических символов E, M, S приведен-
ная  выше  формула  есть  утверждение  о  том,  что  середина  отрезка  (z, y) 
симметрична середине отрезка с концами симметричными точкам z, y. 

Очевидно, это утверждение истинно. 
M(z, y)

z 

y

 
 
 
 
 
 
 
 
 

 

S(y) 

S(z)

M(S(z), S(y))
Рис. 1 

Рассмотрим  еще  одну  интерпретацию  нашей  сигнатуры.  Пусть  на 
этот раз универсом рассуждения будет множество действительных чисел, 
исключая число 0, 

M (z, y) – произведение чисел z, y,  
S (z) – число обратное числу z,  
E (z, y) – «z = y». 
Рассматриваемая нами формула является теперь утверждением о том, 
что  для  любых  двух  чисел  из  нашего  универса  выполняется  равенство 
(z y) –1 = z –1 y –1. 

Очевидно,  это  утверждение  истинно.  Не  трудно  привести  примеры 
интерпретаций, при которых наша формула ложна. Следующие примеры 
показывают,  что  существуют  формулы  тождественно  истинные,  то  есть 
истинные при любой интерпретации, а также тождественно ложные. 
Примеры . Пусть P и Q – одноместные предикатные символы. 
1.  ∀x [¬P (x) ∨ P (x)] – тождественно истинная формула. 
2.  ∀x [¬P (x) & P (x)] – тождественно ложная формула. 
3.  ∀x [P (x) ∨ Q (x)] – истинность этой формулы зависит от интерпре-

тации предикатных символов P и Q. 

 

167

 

 

Если  в  формуле  есть  свободные  переменные,  то  она  получает  кон-

кретное истинностное значение при означивании этих переменных. 

Формула называется выполнимой, если она истинна хотя бы при од-

ной интерпретации. 

Две формулы называются логически равносильными, если при любой 
интерпретации  предикатных  и  функциональных  символов  и  при  любом 
означивании свободных переменных они имеют одно и то же истинност-
ное значение. 

Например, формулы 

логически равносильны. 

пример, 

Логическую  равносильность  формул  будем  обозначать  знаком  ≡, на-

∀x [P (x) & Q (x)] ≡ [∀x P (x) & ∀x Q (x)] 

Заметим, что в этом выражении фигурирует не одна формула, а две, со-
единенные знаком логической равносильности. 

6.2. Некоторые сведения из математической логики 
Напомним кратко основную цепочку построений математической ло-

гики используемых в логическом программировании. 

 

Известно,  что  любое  предложение  в  логике  предикатов  логически 
равносильно предложению в предваренной нормальной форме, то есть в 
такой форме, когда в начале расположены все ее кванторы, за которыми 
расположена бескванторная ее часть. Рассмотрим пример такой формулы 
  ∀x ∃z ∀y ∃u ∀v [P (x, y) & R (y, z) → S (x, u, v) & [S (y, u, v) ∨ S (z, y, v)]] 
(1) 
где P, R, S – предикатные символы соответствующей арности; x, y, z, u, v 
– индивидные переменные. 

Известно,  что  по  любому  предложению  A  в  предваренной  нормаль-
ной форме можно построить так называемое сколемовское предложение 
B. Для этого избавляются от кванторов существования следующим обра-
зом.  Пусть  ∃z  –  самое  левое  вхождение  квантора  существования  в  рас-

не являются логически равносильными, а формулы 

∀x [P (x) ∨ Q (x)], 
∀x P (x) ∨ ∀x Q (x)] 

∀x [P (x) & Q (x)], 
∀x P (x) & ∀x Q (x)] 

 

 

 

 

 

 

 

 

 

 

 168

 

 

сматриваемую формулу и перед ним расположены k кванторов общности 
с переменными x1, x2, ..., xk. Выбираем новый k-местный функциональный 
символ f, вхождение ∃z удаляем из формулы, а каждое вхождение пере-
менной z заменяем термом f (x1, x2, ..., xk). Аналогичным образом избавля-
емся и от других кванторов существования. В результате получим сколе-
мовскую формулу B для исходной формулы A. 

Так для формулы (1) соответствующая сколемовская формула будет 

иметь вид 

 

 

∀x ∀y ∀v [[P(x, y) & R(y, f (x)) → 

 

→ S(x, g(x, y), v)] & [S(y, g(x, y), v) ∨ S(g(x, y), y, v)]], 

 
(2) 
полученный из (1) заменой z на f (x), а u на g(x, y). Заметим, что если бы 
было k = 0, то переменная z заменялась бы на новую константу. Процесс 
получения  сколемовской  формулы  по  заданной  формуле  A  называется 
сколемизацией. 

Известно, что сколемовская формула B, соответствующая формуле A, 
может  быть  логически  неравносильна  формуле  A,  однако,  они  либо  обе 
выполнимы, либо обе невыполнимы (равносильность по выполнимости). 

Для иллюстрации этого факта рассмотрим простую формулу 

Равносильность по выполнимости формулы A и соответствующей ей 
сколемовской формулы B может быть использована следующим образом. 
Предположим,  мы  хотим  доказать,  что  формула  C  является  логическим 
следствием формул A и B. Это сводится к доказательству невыполнимо-
сти формулы 

[A & B & ¬C] 

или соответствующей ей сколемовской формулы, что осуществить техни-
чески оказывается проще. 

Поскольку  в  сколемовской  формуле  используются  только  кванторы 
общности, и все они расположены в начале формулы, то их обычно опус-
кают,  подразумевая  по  умолчанию  их  наличие,  а  бескванторную  часть 

 

169

которая  интуитивно  выражает  существование  функции  f  такой,  что  для 
любого элемента x выполняется R(x, f (x)). При сколемизации она превра-
щается в формулу 

∀x ∃y R(x, y), 

∀x R(x, f (x)). 

 

 

 

 

 

 

 

 

представляют  в  нормальной  конъюнктивной  форме.  Полученная  таким 
образом  формула  называется  клаузальной.  В  нашем  случае  формула  (2) 
превращается в клаузальную формулу 
[¬P (x, y) ∨ ¬R(y, f (x)) ∨ S (x, g(x, y), v)] & [S (y, g(x, y), v) ∨ S(g(x, y), y, v)]]  (3) 
Упомянутый  выше  метод  резолюций  основывается  на  единственном 
правиле вывода, называемом правилом резолюции, которое заключается в 
следующем. 

 

Из двух формул вида 

[¬A ∨ B1 ∨ B2 ∨ ... ∨ Bk] 

[A ∨ D1 ∨ D2 ∨ … ∨ Ds] 

 

и 

 

 

 

 

 

 

 170

в соответствии с правилом резолюции выводится формула 

[B1 ∨ B2 ∨ ... ∨ Bk ∨ D1 ∨ D2 ∨ ... ∨ Ds]. 

Видно, что клаузальная форма хорошо приспособлена для применения 
правила резолюции. Детали этого применения в логике предикатов будут 
рассмотрены ниже. 

Из  математической  логики  известно,  что  не  существует  алгоритма, 
который  по  любому  множеству  H  формул-гипотез  логики  предикатов  и 
еще  одной  формуле  A  отвечал  бы  на  вопрос,  является  ли  A  логическим 
следствием  множества H.  Однако,  существует  алгоритм,  который  в слу-
чае, когда A логически следует из H строит доказательство этого факта с 
использованием правила резолюции, в противном случае алгоритм может 
работать бесконечно. 

Различные версии языка Пролог базируются на использовании так на-
зываемых  хорновских  клаузальных  формул.  Хорновскими  называются 
формулы являющиеся дизъюнкциями атомарных формул и/или их отри-
цаний, причем атомарная часть без отрицания может быть в такой форму-
ле не более чем одна. Рассмотрим пример такой формулы 
 
Ее можно представить в виде 
 
(5) 
Эта формула воспринимается Прологом так, как если бы все ее переменные 
были связаны квантором общности. Восстанавливая кванторы, имеем 
 

∀x ∀y ∀z [P(x) & Q(x, z) & S(f (y)) → R(x, y)]. 

R(x, y) ∨ ¬P (x) ∨ ¬Q(x, z) ∨ ¬S(f (y)). 

P(x) & Q(x, z) & S(f (y)) → R(x, y). 

(4) 

(6) 

 

 

 

 

Учитывая,  что  z  не  входит  в  правую  часть  импликации,  формулу  (6) 
можно переписать в виде 

∀x ∀y [∃z [P(x) & Q(x, z) & S(f (y))] → R(x, y)], 

изменив область действия квантора ∃z. 

 

 

В Прологе принято формулы, аналогичные формуле (5), записывать в 

виде 
 
(7) 
меняя местами левую и правую части импликации и вместо знака конъюнк-
ции ставя запятую. 

R(x, y):– P(x), Q(x, z), S(f (y)), 

Формулу  (7)  Пролог  воспримет  как  указание  о  том,  что  для  доказа-
тельства истинности R(x, y) надо найти некоторое значение z и доказать, 
что истинны P(x), Q(x, z), S (f (y)). Такие формулы принято называть пра-
вилами. 

Если в хорновской клаузальной формуле отсутствуют атомарные час-
ти с отрицанием, то такая формула называется фактом. Если в хорновской 
клаузальной формуле отсутствует атомарная часть без отрицания, то та-
кая формула называется запросом. Программой в Прологе называется на-
бор фактов и правил. 

По заданной программе и запросу система Пролог определяет, являет-
ся  ли  запрос  логическим  следствием  фактов  и  правил  программы.  При 
этом, если в запросе имеются свободные переменные, то в процессе поис-
ка доказательства эти переменные конкретизируются, то есть принимают 
конкретные значения и при успешном его завершении эти конкретизиро-
ванные значения являются ответом к поставленной задаче. Если же дока-
зательство не будет найдено, то система ответит «no». 
 

6.3. Примеры формальных доказательств 

 

 

 

 

 

 

 

 

 

 

Пример  1. Вывести из гипотез H1, H2, H3 заключение C, где 

H1: ∀x [E(x) & ¬P(x) →∃y [R(x, y) & D(y)]], 
H2: ∃x [E(x) & M(x) & ∀y [R(x, y) → M(y)]], 

H3: ∀x [M(x) → ¬P(x)], 

C: ∃x [M(x) & D(x)]. 

Префиксная форма: 

Pref (H1): ∀x ∃y [E(x) & ¬P(x) → [R(x, y) & D(y)]], 

171

 

Pref (H2): ∃x ∀y [E(x) & M(x) & [R(x, y) → M(y)]], 

Pref (H3): ∀x [M(x) → ¬P(x)], 

Pref (C): ∃x [M(x) & D(x)]. 

Клаузальная форма (опускаем кванторы общности, а бескванторные части 
приводим к КНФ и из каждого сомножителя получаем клаузу): 

Cla (H1): [¬E(x) ∨ P(x) ∨ R(x, f (x)] & [¬E(x) ∨ P(x) ∨ D(f (x)) ], 

Cla (H2): M(a) & E(a) & [¬R(a, y) ∨ M(y)], 

Cla (H3): ¬P(x) ∨ ¬M(x), 
Cla (C): ¬M(x) ∨ ¬D(x). 

Доказательство с использованием правила резолюции 

1.  ¬E(x) ∨ P(x) ∨ R(x, f (x)  – из гипотезы H1,  
2.  ¬E (x) ∨ P (x) ∨ D (f (x)) – из гипотезы H1,  
– из гипотезы H2,  
3.  M(a), 
4.  E(a), 
– из гипотезы H2,  
– из гипотезы H2,  
5.  ¬R(a, y) ∨ M(y), 
– из гипотезы H3,  
6.  ¬P(x) ∨ ¬M(x), 
7.  ¬M(x) ∨ ¬D(x), 
– из заключения C, 
8.  P(a) ∨ R(a, f (a), 
9.  P(a) ∨ D(f (a)), 
10.  ¬P(a), 
11.  D(f (a)), 
12.  ¬M(f (a)) 
13.  R(a, f (a), 

– из 1, 4 с помощью подстановки (x/a), 
– из 2, 4 с помощью подстановки (x/a), 
– из 3, 6 с помощью подстановки (x/a), 
– из 9, 10, 
– из 7, 11 с помощью подстановки (x/f (a)), 
– из 8, 10, 

Сколемовская форма: 

Sk (H1): ∀x [E(x) & ¬P(x) → [R(x, f (x)) & D(f (x))]], 

Sk (H2): ∀y [E(a) & M(a) & [R(a, y) → M(y)]], 

Sk (H3): ∀x [M(x) → ¬P(x)], 
Sk (¬C): ∀x [¬M(x) ∨ ¬D(x)]. 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 172

 

 

14.  M(f (a)), 
15.  (cid:0) 

– из 6, 13 с помощью подстановки (y/f (a)),  
– из 12, 14 

Пример  2. Рассмотрим предикаты с интерпретацией: 

F(x, y) ⇔ x является отцом для y,  
S(x, y) ⇔ x, y – дети одного отца,  
M(x) ⇔ x – мужчина,  
B(x, y) ⇔ x брат для y, 

В качестве аксиом рассмотрим формулы 

A1: ∀x ∀y [F(x, y) → M(x)], 
A2: ∀x ∀y ∀w [F(x, y) & F(x, w) → S(y, w)], 
A3: ∀x ∀y [S(x, y) & M(x) → B(x, y)]. 
Пусть из интерпретации известны факты 

A4: F(‘Иван’, ‘Харитон’),  
A5: F(‘Иван’, ‘Василий’),  
A6: F(‘Василий’, ‘Елена’). 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Вопрос: «Есть ли брат у Харитона?». На языке предикатов записыва-

ется как 

A7: ∃z B(z, ‘Харитон’)? 

Доказательство 

1.  ¬F(x, y) ∨ M(x) 
2.  ¬F(x, y) ∨ ¬F(x, w) ∨ S(y, w) 
3.  ¬S(x, y) ∨ ¬M(x) ∨ B(x, y) 
4.  F(‘Иван’, ‘Харитон’) 
5.  F(‘Иван’, ‘Василий’) 
6.  F(‘Василий’, ‘Елена’) 
7.  ¬B(z, ‘Харитон’) 
8.  F(‘Иван’, w) ∨ F(‘Василий’, w) 
 
9.  S(‘Василий’, ‘Харитон’) 
 
10.  M(‘Василий’) 
 
11.  ¬S(‘Василий’, y) ∨ B(‘Василий’,y)  – из 10, 3, подстановка  

– из формулы A1, 
– из формулы A2, 
– из формулы A3, 
– формула A4, 
– формула A5, 
– формула A6, 
– отрицание запроса A7, 
– из 2, 5, подстановка  
(x/‘Иван’, y/‘Василий’), 
– из 4, 8, подстановка  
(w/‘Харитон’), 
– из 6, 1, подстановка  
(x/‘Василий’, y/‘Елена’), 

173

 

 

 

 

 
12.  B(‘Василий’, ‘Харитон’) 
 
13.  (cid:0) 
 

(x/‘Василий’), 

– из 9, 11, подстановка  
(y/‘Харитон’), 
– из 12, 7, подстановка  
(z/‘Василий’) 

Фактически  мы  не  только  получили  ответ  на  наш  запрос,  но  и  под-
твердили  его  конкретным  значением  переменной z.  Приведенный вывод 
можно  модифицировать,  если  ввести  предикат  answer(z)  и  вместо  цели   
«7. ¬B(z, ‘Харитон’)» поставить новую цель  

7′. ¬B(z, ‘Харитон’) ∨ answer(z). Тогда шаг 13 превратится в 13′. 
13′. answer(‘Василий’) – из 12, 7′, подстановка (z/‘Василий’). 

Упражнение 
Рассмотрите вывод, в котором первые 7 формул являются посылками. 
Для остальных формул выпишите пояснения к применению правила резо-
люции. 

 

 

 

 174

1.  ¬A(z),  
2.  A(x) ∨ ¬P(x) ∨ ¬Q(x, y), 
3.  A(x) ∨ ¬R(y) ∨ ¬Q(y, x), 
4.  P(a), 
5.  Q(b, c), 
6.  R(a), 
7.  R(b), 
8.  ¬P(z) ∨ ¬Q(z, y), 
9.  ¬Q(a, y), 
10.  ¬R(y) ∨ ¬Q(y, z), 
11.  ¬Q(a, z), 
12.  ¬Q(b, z), 
13.  (cid:0) 

6.4. Элементы языка ПРОЛОГ 

Основным элементом языка пролог является терм. Термы строятся из 
переменных, атомов, чисел и функторов с использованием круглых ско-
бок. 

Переменная это цепочка (слово), составленная из букв, цифр и сим-
вола  подчеркивания,  начинающаяся  с  большой  буквы  или  символа  под-
черкивания. Если переменная используется однажды, то вместо нее мож-
но использовать так называемую анонимную переменную, состоящую из 

 

 

одного символа подчеркивания. 

Атом это цепочка, составленная из букв, цифр и символа подчерки-
вания, начинающаяся с маленькой буквы или с большой буквы, но тогда в 
одинарных кавычках. Последний способ удобен, если атом является соб-
ственным  именем.  Иногда  атомы  строятся  и  из  специальных  знаков,  но 
мы их использовать при первоначальном знакомстве не будем. 

Числа записываются традиционным образом. Числа с плавающей за-
пятой в обычных применениях ПРОЛОГА используются редко из-за оши-
бок округления. 

Функтор синтаксически совпадает с атомом. 
Терм  это  либо  переменная,  либо  атом,  либо  число,  либо  выражение 

вида 

f (t1, t2, …, tk), 

где f – функтор, а t1, t2, …, tk – термы. 

Для некоторых специальных функторов, например, знаков арифмети-
ческих операций, отношений сравнения и других в Прологе, как в тради-
ционной  математике  используется  инфиксная  форма  записи.  Например, 
выражение X + 1 рассматривается как терм с функтором + и двумя аргу-
ментами X и 1. 

Среди  термов,  ввиду  особой  важности  выделяются  термы  для  пред-
ставления  списков.  Канонически  список  представляется  двухместным 
термом, первым аргументом которого является головной элемент списка, 
а вторым – его хвост, то есть список, полученный из исходного удалением 
головного элемента. Функтором в такой записи часто используется сим-
вол  точка.  Альтернативным  представлением  списка  является  выражение 
вида [t1, t2, …, tk] или [t | L], где t – головной элемент, а L – хвост списка. 
Допустимо также выражение вида [t1, t2, …, tk | L]. 

Важным инструментом в языке Пролог является унификация термов с 
помощью  подстановок.  Такую  унификацию  мы  применяли  выше  в  при-
мерах на доказательство методом резолюций. Сейчас более подробно рас-
смотрим понятие унификации. 

Подстановкой называется набор пар θ = (x1/t1, x2/t2, …, xn/tn), где x1, 

x2, …, xn – переменные, а t1, t2, …, tn – термы. 

Через Eθ обозначим результат подстановки термов t1, t2, …, tn в вы-

ражение E вместо переменных x1, x2, …, xn . 

Пусть π = (y1/u1, y2/u2, …, ym/um) еще одна подстановка. Композиция 

θπ двух подстановок θ и π определяется следующим образом 

 

 

 

 

175

 

 

E(θπ) = (Eθ)π. 

Подстановка  θπ  может  быть  вычислена  следующим  образом.  Соста-

вим из подстановок θ и π последовательность 

(x/t1π, x2/t2π, …, xn/tnπ, y1/u1, y2/u2, …, ym/um) 

и проведем следующие две операции. 

1.  Если некоторое yi совпадает с некоторым xj, то вычеркиваем пару 

2.  Если tiπ = xi, то вычеркиваем пару xi/tiπ.. 
Пример .  Пусть  θ = (x/f  (y), y/z),  π = (x/a, y/b, z/y).  Составим  после-

yi/ui.. 

довательность  

(x/f (y)π, y/zπ, x/a, y/b, z/y) = (x/f (b), y/y, x/a, y/b, z/y) 

и по первому правилу вычеркиваем пары x/a и y/b, затем по второму пра-
вилу – пару y/y. В результате получим 

θπ = (x/f (b), z/y). 

Подстановка θ называется унификатором термов E1, E2, если E1θ = 
= E2θ.  Наиболее  общим  унификатором  термов  E1,  E2,  называется  под-
становка  σ,  такая,  что  любой  другой  их  унификатор  θ  представляется  в 
виде θ = σπ. 

Пример. Для термов P(a, y), P(x, f (b)) унификатором будет подста-

новка 

(x/a, y/f (b)). 

Будет ли она наиболее общим унификатором? 
Пример . Для термов P(a, x, f (g(y))) и P(z, f (z), f (u)) наиболее об-
щим  унификатором  будет  подстановка  (z/a, x/f (a), u/g(y)).  Результатом 
унификации будет терм P(a, f (a), f (g(y))). 

 

 

 

 

 

 

 

 

 

 176

 

 
 
 

 

 

Часть 3. СТРУКТУРА ДАННЫХ 

При разработке алгоритма для компьютерного решения той или иной 
задачи необходимая информация формализуется в виде набора элементов 
различных  типов.  В  каждой  системе  программирования  предусмотрено 
использование некоторых примитивных типов данных и средств, с помо-
щью которых можно группировать их в более сложные структуры. Будем 
считать  примитивными  следующие  типы:  булевский,  целый,  веществен-
ный и символьный. Многие системы программирования позволяют груп-
пировать данные примитивных типов в массивы однотипных элементов, 
записи из фиксированного числа элементов разных типов и в некоторые 
другие  структуры.  Вообще,  под  типом  данных  понимают  произвольное 
множество, называемое множеством значений, и набор операций над зна-
чениями. Так, значениями целого типа являются целые числа из некото-
рого диапазона, зависящего от системы программирования, а операциями 
– обычные арифметические операции. 

При алгоритмизации задач, решение которых опирается на использо-
вание  математических  знаний  и  требует  математических  доказательств, 
разработка  алгоритма  часто  проводится  также  в  математических  или 
формализованных прикладных терминах. При этом в достаточно большой 
степени  происходит  отвлечение  от  технических  возможностей  исполни-
теля  алгоритмов  (человека  или  технического  устройства).  Так,  если  при 
описании  алгоритма  используется  понятие  множества,  то  достаточно 
уметь выполнять некоторый набор операций с множествами и отвечать на 
некоторые  вопросы  относительно  множеств.  Перечень  таких  операций 
может быть следующим: 

•  ввести в рассмотрение пустое множество, 
•  включить элемент в множество, 
•  исключить элемент из множества, 
•  проверить, пусто ли рассматриваемое множество, 
•  узнать, сколько элементов в рассматриваемом множестве. 
Эти операции с некоторой точки зрения можно считать элементарны-
ми  и  до  известной  поры  не  думать о способе их реализации исполните-
лем.  В таких случаях говорят, что мы имеем дело с абстрактным типом 
данных. 

Широко используемыми абстрактными типами данных наряду с мно-

 

177

 

 

жествами  являются  мультимножества,  взвешенные  множества,  кортежи, 
отображения, приоритетные очереди, графы и так далее. Когда дело дохо-
дит  до  разработки  программ  в  конкретной  системе  программирования, 
приходится принимать решения о представлении таких данных в памяти 
и о реализации операций над ними доступными средствами. 

В  настоящее  время  большинство  алгоритмов  проектируется  для  ис-
пользования  в  устройствах,  обладающих  адресуемой  памятью.  Каждый 
элемент информации, размещенный в такой памяти, занимает определен-
ную  позицию.  По  известной  позиции  элемента  в  такой  памяти  доступ  к 
нему  осуществляется  за  некоторую  условную  единицу  времени,  завися-
щую только от типа получаемой информации, фактически, от физическо-
го размера ячейки памяти или от количества таких ячеек, предназначен-
ных для ее хранения, но не от ее конкретного содержания. Более того, по-
зиции элементов сами могут быть элементами информации, с которыми 
могут  производиться  некоторые  операции,  что  позволяет  использовать 
так  называемую  косвенную  адресацию.  Наличие  косвенной  адресации 
позволяет поручить программной системе или разрабатываемой приклад-
ной программе поиск свободных участков памяти для размещения новых 
элементов информации и запоминание их адресов с последующим их ис-
пользованием для доступа к информации. 

Информация,  размещенная  в  адресуемой  памяти,  приобретает  новые 
свойства.  Элемент  информации  характеризуется  не  только  своим  содер-
жанием,  но и адресом, то есть местом расположения в памяти. Два эле-
мента  данных,  соседних  в  некотором  содержательном  смысле,  не  обяза-
тельно  будут  располагаться  в  соседних  ячейках  памяти.  Они  могут  ока-
заться  в  непредвиденных  местах.  Проектируя  программную  реализацию 
алгоритма,  необходимо  проектировать  и  способ  расположения  в  памяти 
обрабатываемой информации. 

Существуют типы данных, которые естественным образом вкладыва-
ются в адресуемую структуру технической памяти, причем легко выпол-
няются все операции, предусмотренные для такого типа данных. Приме-
ром может служить вектор фиксированной размерности, задаваемый упо-
рядоченным набором своих компонент. Наиболее естественным является 
его хранение в виде массива, при котором соседние компоненты распола-
гаются  в  ячейках  с,  подряд  идущими  номерами.  Этот  способ  позволяет 
легко  выполнять  покомпонентные  операции  (сложение векторов, вычис-
ление скалярного произведения и другие). Однако если размерность век-
тора в процессе работы изменяется, например, путем удаления компонент 
или вставки новых, то представление в виде массива оказывается неудоб-

 178

 

 

ным,  так  как  операции  удаления  и  вставки  при  условии  сохранения  по-
рядка  следования  элементов  требуют  перезаписи,  возможно,  достаточно 
большого  числа  компонент,  что  может  неблагоприятно  сказаться  на  эф-
фективности  алгоритма.  Чтобы  избежать  неэффективности  такого  рода, 
одновременно с алгоритмом проектируется структура представления дан-
ных, позволяющая реализовать выполнение всех необходимых операций 
в приемлемое время. 

В практике программирования накоплен большой опыт структуриро-
вания информации. К счастью, способы структурирования, изобретенные 
при решении одной задачи, часто находят применение и во многих дру-
гих. Так, для представления, как кортежей, так и множеств в памяти ком-
пьютера могут использоваться такие структуры данных, как линейные и 
циклические списки. 

Во  многих  задачах  исходные  данные  представляют  собой  так  назы-
ваемые  взвешенные  множества.  Взвешенным  называется  множество,  ка-
ждому элементу которого поставлено в соответствие в качестве веса не-
которое число. Часто используемыми операциями с такими множествами 
являются поиск элемента с минимальным весом, вставка нового элемента 
со  своим  весом,  удаление  элемента  и  некоторые  другие.  Для  быстрого 
выполнения  таких  операций  разработаны  так  называемые  кучеобразные 
структуры данных. 
 

Глава 1. СПИСКИ 

1.1. Общие сведения о списках 

 

 

Остановимся на наиболее часто используемых структурах данных, на-
зываемых  списками.  Списки  лежат  в  основе  многих  более  сложных 
структур  данных.  В  простейшем  случае  списки  используются  для  пред-
ставления кортежей. 

Кортеж – это конечная последовательность, возможно с повторения-
ми, элементов некоторого множества E. Элементами кортежа могут быть 
числа,  символы  некоторого  алфавита,  точки  плоскости  и  т.  д.  В  более 
сложных случаях элементами кортежа в свою очередь могут быть также 
кортежи.  Элементы,  не  являющиеся  кортежами,  называются  атомами. 
Кортеж  характеризуется  своей  длиной.  Удобно  рассматривать  кортежи, 
не содержащие ни одного элемента. Такие кортежи называются пустыми. 
Длина пустого кортежа считается равной 0. 

Элемент кортежа характеризуется своим номером в последовательно-
сти (кортежным номером) и своим содержанием, то есть элементом мно-

 

179

 

 

жества E. Если длина кортежа равна n, n > 0, то кортеж S удобно рассмат-
ривать как отображение s множества N = {1, 2, ..., n} в множество E. Та-
ким образом, s(i) это i-й элемент кортежа S. 

Термин  список  используется  как  обобщающее  название  различных 
структур  данных,  используемых  для  представления  кортежей  в  памяти 
компьютера.  При  представлении  кортежа  в  памяти  появляется  еще  одна 
характеристика  элемента  кортежа  –  его  позиция  в  памяти.  В  некоторых 
случаях номер элемента в кортеже и его позиция в памяти связаны друг с 
другом арифметическими соотношениями таким образом, что по номеру 
легко вычисляется позиция и, наоборот, по позиции вычисляется номер. В 
других случаях связь между номерами и позициями задается «таблично» 
или  осуществляется  с  помощью  алгоритмических  процедур.  Множество 
позиций обозначим через P. Иногда удобно считать, что во множестве P 
имеется специальный элемент nil, указывающий на несуществующую об-
ласть  памяти.  Таким  образом,  при  рассмотрении  того  или  иного  списка 
имеем дело с тремя множествами E, N, P и с отображениями на этих мно-
жествах. 

Типичными при работе со списками являются следующие операции. 
•  Нахождение позиции элемента в памяти по его номеру в кортеже. 
•  Нахождение позиции элемента, следующего в кортеже за элементом 

•  Нахождение  позиции  элемента,  предшествующего  в  кортеже  эле-

из заданной позиции. 

менту из заданной позиции. 

•  Удаление элемента, находящегося в заданной позиции. 
•  Вставка  в  кортеж  нового  элемента  перед  элементом,  расположен-

ным в заданной позиции. 

 

•  Определение длины кортежа. 
При описании этих и других операций со списками будем использо-
вать следующие отображения и константы заданные на множествах E, N, 
P. 

•  Info: P → E, где Info (pos) − элемент списка находящийся, в пози-

 

 

 180

•  Next: P → P, где Next (pos) − позиция элемента, следующего за эле-

ции pos памяти. 

ментом из позиции pos. 

•  Precede: P → P, где Precede (pos) −позиция элемента, находящегося 

перед элементом из позиции pos. 

•  Number:  P  →  N,  где  Number  (pos)  −  кортежный  номер  элемента, 

 

 

находящегося в позиции pos. 

•  Position: N → P, где Position (k) − позиция элемента имеющего кор-

тежный номер k. 

•  Length − длина списка. 
•  First − позиция первого элемента списка. 
•  Last − позиция последнего элемента списка. 
Иногда  для  распознавания  концевых  элементов  списка  пользуются 
следующим  соглашением:  eсли  pos  является  позицией  последнего  эле-
мента  списка,  то  полагают  Next (pos)  =  pos,  а  если  началом,  то  – 
Preced (pos) = pos.  В  случаях,  когда  позицией  элемента,  следующего  за 
последним  или  предшествующего  первому,  является  несуществующая 
позиция nil, будем считать, что nil принадлежит множеству P. При изме-
нении содержимого списка все введенные множества, отображения и кон-
станты могут изменяться. 

Различные  представления  кортежей  с  помощью  списковых  структур 
характеризуются степенью эффективности выполнения тех или иных опе-
раций. Так, при одном представлении эффективно вычисляется порядко-
вый номер элемента по его позиции, но менее эффективно осуществляет-
ся вставка нового элемента. При другом представлении легко осуществ-
ляется вставка, а определение порядкового номера элемента по его пози-
ции  требует  заметного  времени,  например,  пропорционального  длине 
списка. К сожалению, не всегда удается найти способ представления кор-
тежей, для которого все используемые в конкретном алгоритме операции 
одинаково  эффективны.  Поэтому  выбор  структуры  для  представления 
кортежа  сопряжен  с  анализом  алгоритма,  а  именно,  с  выяснением  того, 
какие операции, в конечном счете, определяют его суммарную трудоем-
кость.  В  зависимости  от  набора  операций,  которые  предполагается  вы-
полнять со списками, выделяют некоторые их разновидности. 

Список,  в  который  предполагается  добавлять  и  удалять  элементы 
лишь с одного его конца, называется стеком. Если добавление элементов 
должно происходить с одного конца, а удаление с другого, то такой спи-
сок  называется  очередью.  Если  удалять  и  добавлять  элементы  можно  с 
любого конца списка, то такой список называется деком. Если добавлять 
можно с любого конца, а удалять только с одного, то список называется 
деком  с  ограниченным  выходом.  Списки  более  общего  вида  позволяют 
включать и удалять элементы из любой позиции. Списки классифициру-
ются  также  по  возможностям  их  сканирования  (просмотра)  в  одном  на-
правлении (от начала к концу или от конца к началу) или в обоих направ-

 

181

 

 

лениях.  В  первом  случае  список  называется  односторонним,  во  втором 
двусторонним. 

Списки,  для  которых  не  планируется  выполнять  операции  встав-
ки/удаления из произвольной позиции, удобно представлять массивами. В 
этом случае кортежный номер элемента можно либо отождествить с но-
мером элемента в массиве, либо сделать его легко вычисляемым по этому 
номеру. Такие списки называют списками с прямым доступом к элемен-
там. Другими словами, под прямым доступом мы понимаем возможность 
по  номеру  элемента  в  кортеже  за  единицу  времени  определять  как  сам 
элемент, так и его позицию в памяти. 

При  представлении  кортежей,  для  которых  планируется  выполнение 
операций вставки/удаления элемента из произвольной позиции, использу-
ется возможность нахождения программным путем свободного простран-
ства в памяти для размещения вставляемого элемента. При использовании 
языков программирования высокого уровня эти обязанности берет на себя 
обычно система программирования (оператор new – в языках PASCAL и 
C). При вставлении нового элемента в список место, куда он вставляется, 
указывается с помощью косвенной адресации. Это может быть адрес эле-
мента,  перед  которым  вставляется  новый  элемент,  либо  после  которого, 
либо  и  тот  и  другой.  Такой  способ  дает  возможность  лишь  последова-
тельного доступа к элементам. Другими словами, при последовательном 
доступе гарантируется определение за единицу времени позиции очеред-
ного  элемента  лишь  по  позиции  предыдущего  или  следующего  за  ним 
элемента, но не по его номеру в кортеже. 

Отметим  еще,  что  при конструировании списков иногда удобно эле-
ментами списка считать не сами элементы множества E, а их позиции в 
памяти. В первом случае списки по терминологии Р. Тарьяна называются 
экзогенными  (внутренними),  а  во  втором  эндогенными  (внешними).  Эн-
догенный способ используют в тех случаях, когда элементы множества E 
для своего представления требуют большого пространства и переписыва-
ние элемента из одного участка памяти в другой сопряжено с большими 
затратами времени. 

Преимущества использования эндогенных списков вместо экзогенных 
может  ярко  проявиться  в  такой  задаче,  как  сортировка  (упорядочение) 
элементов списка в порядке возрастания или убывания некоторой число-
вой  характеристики,  называемой  ключом  элемента.  Основными  опера-
циями  при  сортировке,  определяющими  ее  трудоемкость,  являются  опе-
рация сравнения ключей и операция перемещения элементов. Очевидно, 
что  при  эндогенном  способе  представления  списка  суммарные  затраты 

 182

 

 

времени на перемещения элементов могут оказаться намного меньше, чем 
при экзогенном способе. 

Возможность более быстрой перестановки коротких адресов по срав-
нению  с  перестановкой  длинных  записей  не  исчерпывает  преимуществ 
эндогенного представления списков. Предположим, что нам одновремен-
но понадобилось не одно, а несколько разных упорядочений одного и то-
го же списка по разным критериям. Для этого достаточно ввести несколь-
ко  адресных  массивов,  при  упорядочении  по  каждому  критерию  пере-
ставляются элементы соответствующего адресного массива. 

При описании операций над списками будем считать, что каждый из 
них описан с помощью дескриптора, имеющего форму записи, состоящей 
из нескольких полей. Дескриптор предназначен для того, чтобы явно ука-
зать составные части, из которых формируется список. Как правило, в де-
скриптор будет входить поле first, содержащее позицию первого элемен-
та. Если в конструкции списка используется некоторый массив, то в деск-
рипторе указывается имя этого массива. 

Поля, относящиеся к конкретному списку L, будем записывать в фор-

L.<имя_поля>. 

В полях дескриптора будем указывать также имена процедур и функ-
ций,  которые  реализуют  примитивные  операции  над  списками  при  рас-
сматриваемой их реализации. 

Так, например, дескриптор списка L может иметь форму  

ме 

 

 

 

 

 

 

[first, length]. 

При таком дескрипторе 
•  L.first означает позицию первого элемента списка L, 
•  L.length – его длину. 

1.2. Списки с прямым доступом 

Прямой  доступ,  как  правило,  реализуется  при  представлении  списка 
массивом. В книге [5] этот способ называется последовательным распре-
делением. Элементы кортежа размещаются в идущих подряд ячейках не-
которого массива. Для локализации списка в массиве введем целочислен-
ную  переменную  first  для  хранения  номера  позиции  массива,  в  которой 
расположен  его  первый  элемент,  и  целочисленную  переменную  length, 
означающую длину списка. Равенство length = 0 является признаком того, 
что массив содержит пустой список. Иногда для переменных, хранящих 

 

183

 

 

позицию элемента массива, удобно иметь какое-либо условное значение, 
выходящее за рамки индексации массива. Будем обозначать его beyond. 

Рассмотрим подробнее реализацию списка с прямым доступом, даю-
щую возможность добавлять элементы к списку с любого его конца. Вос-
пользуемся  циклической  «нумерацией»  элементов  массива,  при  которой 
следующим  за  последним  элементом  массива  считается  его  первый  эле-
мент,  а  предыдущим  для  первого  –  последний  (речь  идет  об  элементах 
массива,  а  не  об  элементах  списка).  Если  элементы  массива  пронумеро-
вать  числами  от  0  до  n − 1,  то  переход  к  следующему  (предыдущему) 
элементу  списка  осуществляется  с  помощью  прибавления  (вычитания) 
единицы по модулю n, где n – длина массива. 

Дескриптор такого списка будет иметь форму 

S = [n, info, first, length]. 

Добавление элемента к началу списка осуществляется его записью в 
позицию newfirs = (first – 1) mod n (0 ≤ newfirst < n) с последующим при-
сваиванием first := newfirst, а добавление в конец − запись элемента в по-
зицию  (first  +  length)  mod  n  с  последующим  выполнением  оператора 
length := (length + 1). Заметим, что при таком способе начальный фраг-
мент кортежа может оказаться в конце массива, а конечный фрагмент – в 
начале. Заметим также, что добавление нового элемента возможно только 
при условии length < n. Следует заметить также, что в системах програм-
мирования со статическим распределением памяти под массивы, которое 
происходит во время компиляции, длину массива следует выбирать дос-
таточной для размещения списков, порождаемых разрабатываемым алго-
ритмом. Следует иметь ввиду, что максимальная длина списка зависит не 
только от алгоритма, но и от входных данных. 

Основные отображения для списка с прямым доступом, имеющего де-

скриптор S = [n, info first length], определяются следующим образом 

Info (pos) = S.info [pos], 

Next (pos) = if (pos = S.first+S.length−1) then pos 

else if (S.length < S.n) then (pos + 1) mod S.n else beyond, 

Preced (pos) = if (pos = S.first) then pos 

else if (S.length < S.n) then (pos − 1) mod S.n else beyond, 

Last = (S.first + S.length − 1) mod S.n, 

Number (pos) = if (S.first < pos) then (pos − S.first + 1) 

 

 

 

 

 

 

 184

 

 

else (S.pos − S.first + S.n − 1). 

Приведем несколько процедур для работы со списками с прямым дос-

тупом. 

 

 

 

 

 

 

 

 

 

 

 

 

if S.length < S.n  
then {S.info[(S.first + S.length) mod S.n] := e; S.length := S.length + 1} 
else 'массив переполнен' 

Создать пустой список S 
Procedure SetEmpty (S); 
begin S.first:=0; S.length:=0 end; 
Добавить элемент e к концу списка S 
Procedure AddToEnd (e, S); 
begin 
 
 
 
end; 
Добавить элемент e к началу списка S 
Procedure AddToBegin (e, S); 
begin 
 
 
 
end; 
Заменить элемент с кортежным номером k на элемент e 
Procedure Set (k, e, S); 
Begin  
S.info [S.first + k − 1] := e  
end; 
Удалить последний элемент списка S 
Procedure DelLast (S); 
begin 
 
 
end; 
Удалить первый элемент списка S 

if S.length > 0 then S.length:= S.length − 1 
else 'список пуст' 

If S.length < S.n  
then {S.first := S.first−1; S.info[S.first] := e; S.length := S.length + 1} 
else 'массив переполнен' 

185

 

 

Procedure DelFirst (S); 
begin 
 
 
 
end; 

if S.length > 0  
then {S.first := (S.first + 1) mod S.n; S.length := S.length − 1} 
else 'список пуст' 

1.3. Списки с последовательным доступом 

где t − позиция (адрес) узла в памяти. Поскольку у последнего элемента 
нет следующего, его поле Next заполняют значением nil. Иногда вместо 
nil используют ссылку на самого себя, что также может являться призна-
ком конца списка. Мы часто будем пользоваться именно этим способом 
распознавания конца списка. Представление списка с помощью таких уз-
лов  обеспечивает  сканирование  списка  от  начала  к  его  концу.  Доступ  к 
самому списку осуществляется через его голову с помощью переменной 

Последовательный доступ к элементам списка, как правило, реализу-
ется с использованием динамического выделения памяти во время испол-
нения программы. Поиск свободных участков памяти обычно возлагается 
на  систему  программирования.  В  книге  [5]  этот  способ  называется  свя-
занным  распределением.  Мы  будем  называть  такие  списки  связными. 
Преимущества связных списков перед списками с прямым доступом про-
являются  в  тех  случаях,  когда  часто  используются  вставки  и  удаления 
элементов из списков. Еще одно преимущество динамического выделения 
памяти может проявиться, когда в алгоритме одновременно используется 
большое количество списков, каждый из которых в процессе работы мо-
жет  потребовать  большой  объем  памяти,  однако  в  совокупности  эта  па-
мять может быть ограничена приемлемой величиной. 

Элементы связного списка, следующие друг за другом, не обязательно 
размещаются в последовательных ячейках памяти, доступ к следующему 
и  предыдущему  элементам  осуществляется  при  помощи  специальных 
ссылок  (указателей).  Чтобы  обеспечить  запоминание  указателей  на 
следующий  и  предыдущий 
списка 
«погружается»  в  узел,  для  которого  формируется  в  памяти  компьютера 
запись, состоящая из нескольких полей. В простейшем случае эта запись 
может  состоять  из  двух  полей.  Одно  из  них  Info  предназначено  для 
запоминания самого элемента, а другое − Next для запоминания позиции 
следующего.  Для  обозначения  такого  узла  будем  использовать 
следу

элементы,  каждый 

ющую форму 

элемент 

t: [Info, Next], 

 

 

 

 

 186

 

 

first,  содержащей  позицию  первого  элемента.  Такие  списки  называются 
односторонними. 

При описании операций со списками через t^ будем обозначать узел, 
расположенный в позиции t. Для доступа к полям узла t^ используем фор-
му t^.Info, t^.Next и т. д. 

Оператор для создания нового узла будем записывать в виде  

Для обеспечения сканирования как от начала к концу, так и от конца к 

началу, используют узлы следующего вида 

Create (t: [Info, Next]). 

t: [Info, Next, Preced]. 

 

 

 

 

e1

 

e2

first 

Поле  t^.Preced  используется  для  запоминания  позиции  элемента, 
предшествующего элементу, находящемуся в позиции t. Доступ к такому 
списку может осуществляться как через его начало с помощью перемен-
ной first, так и через конец с помощью переменной last. Такие списки на-
зываются двусторонними. 

Рис. 1. Одн сторонний список: вход через первый элемент; 
сканирование от начала к концу, признак конца − Next(pos) = 

На рис. 1–6 изображено несколько разновидностей списков. Узлы спи-
сков  изображены  прямоугольниками,  разделенными  на  части  по  числу 
полей.  Стрелки  проведены  в  соответствии  со  значениями  полей  Next  и 
Preced. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Рис.  3.  Односторонний  циклический  список:  вход  через  первый  эле-
мент; 

Рис. 2. Односторонний список: вход через первый элемент; сканирова-

  
first 

en   

 
о(

 

)

  

first 

(

e2

   en

en

e1

  

  

  

ние 

en

  

e1

e2 

e2

en

e1

  

e2

en

 

 

 

last 
187

Рис. 4. Односторонний циклический список: вход через последний элемент с  омо-
 п
la.
щью ссылки Last^.next; сканирование от начала к концу, признак конца – pos =  st 

  

 

 

e

  

first 

 
 
 
 
 
 
 
 
 
  
 
  Рис. 5. Двусторонний список: вход через первый элемент, сканирование от нача-
 
 
 
 
 
 
 
 
 
 

к концу и от конца к началу; признак начада – Proced(pos) = nil;  

Рис. 6. Двусторонний циклический список: вход через первый элемент; сканирова-

first 

ние 

 

e2

 

e2

 

e1

  

ла  

en

 

en

  

Рассмотрим  основные  отображения  и  операции  на  примере  двусто-

роннего списка, сформированного из узлов вида t: [Info, Next, Preced]. 

Считаем, что дескриптор списка S имеет вид: [first, last]. 
Ниже условимся считать, что признак конца – Next (pos) = nil, а при-

знак начала – Preced (pos) = nil. 

Основные отображения определяются следующим образом. 

Info (pos) = pos^. info, 
Next (pos) = pos^. next, 
Preced (pos) = pos^. preced, 

Создать пустой список S 
SetEmpty ( S ); 
begin S. first := nil end; 
Удалить из списка S элемент, находящийся в позиции pos памяти 
Procedure Del(S, pos); 

 

 

 

 

 

 

 

 188

 

 

t := pos^.preced; u := pos^.next;  
t^.next := u; u^.preced := t 

begin  
 
 
end; 
Замечание. В теле процедуры Del отсутствует параметр S. При ее ис-
пользовании могут возникнуть проблемы, связанные с некорректным об-
ращением, так как в процедуре не производится проверка того, является 
ли позиция pos позицией какого-либо элемента списка S. Ответственность 
за некорректное обращение несет вызывающая программа. Проверка это-
го условия с помощью сканирования списка могла бы оказаться слишком 
дорогой и свела бы на нет преимущества использования связных списков. 
Еще одна проблема, связанная с использованием этой операции, заключа-
ется в том, что узел pos^ может оказаться недоступным при потере значе-
ния переменной pos, но память будет оставаться занятой. Если это неже-
лательно,  следует,  воспользовавшись  системными  средствами,  освобо-
дить занимаемую узлом память. Замечания по поводу некорректного об-
ращения будут справедливы и для некоторых следующих процедур, одна-
ко, мы не будем каждый раз напоминать об этом. 

Вставить  в  список  S  элемент  e  после  элемента,  находящегося  в 

позиции pos 

 

 

 

 

 

create ( t: [e, pos^.next, pos] ); 

Procedure InsertAfter ( S, pos, e ); 
begin 
 
  pos^.next^.preced := t; 
  pos^.next := t 
end; 
Следующие  две  операции  рассмотрим  на  примере  одностороннего 

циклического списка (рис. 4). 

create (t: [e, S.last^.next]); 

Добавить элемент e к концу списка S 
Procedure AddToEnd (e, S); 
begin 
 
  S.last:= t; 
end; 
Добавить элемент e к началу списка S 
Procedure AddToBegin (e, S); 

189

 

 

create(t: [e, S^.last^.next]); 

begin  
 
  S.last^.next := t  
end; 
Следующие  три  процедуры  рассмотрим  на  примере  двустороннего 

циклического списка (см. рис. 6). 

t := S.first^.next; 

Удалить последний элемент списка S 
Procedure DelLast (S); 
begin  
t := S.first^.preced^.preced;  
 
t^.next := S.first;  
 
  S.first^.preced := t  
end; 
Удалить первый элемент списка S 
Procedure DelFirst (S); 
begin 
 
  S.first^.preced^.next := t; 
  S.first := t 
end; 
Удалить из списка S элемент, находящийся в позиции pos 
Procedure DelPosition (S, pos); 
begin 
 
 
 
 
 
 
end; 

if pos = S.first  
then DelFirst (S)  
else  
if pos = S.last 
then DelIast (S) 
else {t^.preced^.next := t^.next; t^.next^.presed := t^.presed} 

1.4. Некоторые дополнительные операции 

со связными списками 

Конкатенация.  Эта  операция  предназначена  для  соединения  двух 

 

 

 

 

 

 

 

 
 

 

 190

 

 

спи
сков в один результирующий. Она выполняется эффективно в тех слу-
чаях, когда обеспечен доступ к последнему элементу списка с трудоемко-
стью O(1). При соединении двух списков S1 и S2 первый элемент списка 
S2 становится преемником последнего элемента списка S1. При этом воз-
никают вопросы – должен ли получившийся список иметь какое-то новое 
имя и должны ли сохраниться как таковые исходные списки S1 и S2? 
В  рассмотренной  ниже  процедуре  Concat,  реализующей  опера
цию 
единить два списка», принято следующее решение. К списку S1 при-
«Со
соединяется список S2, список S2 сохраняется, а результирующим являет-
ся список S1. Следует, однако, понимать, что если в список S2 будут вне-
сены  изменения,  они  автоматически  произойдут  в новом списке. Трудо-
емкость этой операции – O(1). 
begin S1. last^. next := S2.fi
rst end; 
Из списка S удалить элементы, уд
овлетворяющие некоторому усло-
. Предположим, что требуемое условие на элемент e проверяется пре-

 

 

вию
дикатом condition (e). 

t := S.first; 

begin 
 
  while t ≠ nil do 
 
end; 
  список  S1,  состоящий  из  элементов  данного  списка  S, 
Построить
влетворяющих  некоторому  условию.  Предположим,  что  требуемое 

{if condition (t^.info) then DelPosition (S, pos); t:=t^.next} 

удо
условие на элемент e проверяется предикатом condition (e). 

 

 

 

 

 

 

{if condition(t^.info) then AddToEnd (e, S1 ); t := t^.next} 

t := S.first; SetEmpty(S1); 

begin 
 
  while t ≠ nil do 
 
end; 
 
олучить список S1 реверсированием списка S 
П
begin 
 
 

 SetEmpty(S1); 
t := S.first; 

191

 

 

  while  t ≠ nil do {AddToBegin (t^.inf, S1);  t := t^.next} 
end; 
. Мод

елирование списков с последовательным доступом 

при помощи массивов 
е  динамических  ссылок  нев

Если  использовани
озможно  или  нежела-
тел
ьно (тому могут быть свои причины), список со связями можно смоде-
лировать при помощи массивов. В массиве Inf хранятся элементы списка, 
т.е. значения соответствующих полей узлов списка со связями. Позицией 
элемента является значение целочисленного индекса массива. Кроме того, 
вводится целочисленный массив Next, в котором для каждого узла списка 
указана позиция в которой расположен его преемник. В качестве индекс-
ного пространства используем отрезок [1..n] целочисленного типа. 
В  одних  и  тех  же  массивах  Inf  и  Next  могут  размещаться  сра
зу  не-
ско
лько списков, состоящих из узлов одного типа. С учетом такого воз-
можного сосуществования различных списков, их элементы могут разме-
щаться в этих массивах хаотично, подобно тому, как узлы списков, пред-
ставленных  с  помощью  ссылок,  могут  хаотично  располагаться  в  памяти 
компьютера. 
показано возможное заполнение массивов Inf и Next для од-
На рис. 7 
тороннего списка, представляющего кортеж (a, b, c, d, e) (пустые клет-

нос
ки не имеют отношения к этому списку). 
 

1 
Адрес
e 
Inf 
N  ext
0 
о лир ван  од осторон
с. 7. М де

3 
b 
6 
ие

2 
 
 
о

4 
 
 
н

5 
 
 

6 
c 
9 
нег

7 
 
 
п

9 
8 
d 
 
 
1 
а  и п

11
10
a 
 
 
3 
ощи ма

ом

12 
 
 
в

о с иск пр

сси ов 
Ри
ступ к списку можно осуществить через его первый элемент, 

До
пози-
 которого в массиве задается значением переменной first = 11. Значе-
ция
ние Next[1] = 0 говорит о том, что в позиции 1 расположен элемент, у ко-
торого нет преемника, то есть последний элемент кортежа. 
На рис. 8 показано возможное заполнение массивов Inf, 
 представления кортежа (a, b, c, d, e) двусторонним списком. 
12
 
 
 

Pos 
Inf 
Next 
Preced
Рис. 8. Моделирование двустороннего списка при помощи массивов 

3 
b 
6 
11 

Next и Preced 

11
a 
3 
0 

10
 
 
 

1 
e 
0 
9 

6 
c 
9 
3 

9 
d 
1 
6 

2 
 
 
 

4 
 
 
 

5 
 
 
 

7 
 
 
 

8 
 
 
 

 

 

1.5

 

 

 

для

 

 192

 

 

e

Length з
явно, то

Основные  отображения 

Info(pos),  N x (t
po , 
с
  бра ом сл  какие
. Е и
адают я очевидным о
 с
ч
 их мож
 одни

бо
 вычислять  ере  другие кан ро ни
 те 

з
з
и ва
Info, Next, Preced
 

же массивы

s) Preced(pos) F rsi

t,  Last, 
, 
х  е заданы 
-ли  из ни н
ем пи а. 
ск

Чтобы

енного  хранения  нескольких  однотипных  списков,  позици

использовать для од-
и  этих 
сивов  объединяют  в  один  так  называемый  свободный  список  Avail. 

оврем
н
мас
Это можно сделать, например, с помощью операторов 

но
 
и

 
 с

 

 

for i := 1 to n – 1 do Next[i] := I + 1; 

begin 
  Avail.first:=1; 
  Next[n] := 0; 
 
  Preced[1] := 0; 
 
end; 
Массив  Info  при
льзуются элементы массивов Info, Ne

for i := 2 to n do Preced[i] := i – 1; 

 

 

 

 

 

il

 из списка Ava . В момент создания

  этом  не  заполняется.  При  создании  новых  списков 
xt, Preced, предварительно уда-
испо
 нового узла из списка Avail 
ляемые
  используется  для  добавления  в 
я тся  головной  элемент,  который  и
е
удал
исок. С другой стороны, при удалении элемента из какого-либо 
новы
й сп
спи
ска, освобождаемая позиция добавляется к свободному списку для по-
следующего использования. Такая техника использовалась, когда системы 
программирования  не  имели  стандартных  средств  динамического  выде-
ления памяти. Однако в условиях ограниченной памяти этот прием можно 
использовать и сейчас. Дело в том, что при достаточно большом объеме 
оперативной памяти стандартные системы вынуждены использовать мно-
горазрядную адресацию, в то время как для позиционирования в массивах 
Info, Next, Preced можно использовать малоразрядные представления чи-
сел. 

1.6. Деревья и графы 

Деревья  находят  широкое  применение  при  проектировании  алгорит-
мов и, в частности, структур данных. Отсылая читателя к литературе по 
теории графов [11], будем пользоваться такими понятиями как узел, реб-
ист,  потомок,  сын,  левый  потомок,  правый  потомок,  предок,  отец, 
ро,  л
корень, ветвь и другими
вем дерево, в котором 
  максимально  возможное  (как  правило,  небольшое)  число 
фиксировано
потомков для каждого из его узлов. В частности, если число потомков для 
каждого узла не превосходит двух, то дерево называется бинарным, если 

. Регулярным деревом назо

 

193

 

 

не более трех – тернарным. Если это число может равняться только двум 
или трем, то дерево называется (2–3)-деревом. 

Достаточно  универсальным  является  способ  представления  регуляр-
ных деревьев, при котором каждый узел представляется записью, содер-
жащей  кроме  прикладной  информации  также  позиции  смежных  с  ним 
элементов,  например,  позиции  потомков  или  наряду  с  потомками  пози-
цию  предка  или  еще  каких  либо  узлов,  в  зависимости  от  потребностей. 
Рег
улярность дерева позволяет фиксировать число полей, достаточное для 
представления любого узла. 

Так, узлы бинарного корневого дерева можно представлять записями 

вида 

 

 

[Element, Left, Right], 

язанную  с  узлом  прикладную  информацию, 
t  − позицию его левого потомка, а Right −позицию правого потомка. 
дерево в таком случае можно представить позицией его корня. Если 
, то узлы бинарно-

где  Element  представляет  св
Lef
Само 
 алгоритме необходимо 
в
го
 корневого дерева можно
 

продвижение от узла к предку
 вида 

 представлять записями

[Element, Left, Right, Father], 
где Father – позиция предка рассматриваемого узла. 

 

Для представления нерегулярных деревьев (то есть деревьев, узлы ко-
няют следующий 
уются и каждый узел 
ю его первого (лево-

торых могут иметь произвольное число потомков) приме
способ
представляется
го) потомка и позицию его «правого брата». 

: потомки каждого узла нумер
ю, включающей в себя позици

 представления
 запись

Для регулярных деревьев более экономным по памяти может оказать-
ся представление дерева с помощью массива. Рассмотрим этот прием на 
примере бинарного дерева. Значения индексов массива отождествляются 
с узлами дерева, пронумерованными так, что корень получает номер 1, а 
 2i и 2i + 1. При таком пред-
потомки узла c номером i получают номера
влении предок узла с номером i будет иметь номер i div 2 (частное от 
ста
деления i на 2). Аналогично можно представить тернарное и другие регу-
лярные деревья. 

Остановимся вкратце на представлении графов общего вида. 
Обыкновенный  граф  с  n  вершинами  часто  представляют  матрицей 
смежности, то есть матрицей размера n × n, в которой элемент, располо-
женный в i-й строке и j-м столбце, равен 1, если вершины графа с номе-

 194

 

 

и i, j соединены ребром, и равен 0, если такого ребра нет. Если
 граф не 
ентирован, то его матрица смежности симметрична, и можно ограни-

рам
ори
читься хранением ее треугольной части. 

Матричный  способ  представления  может  оказаться  неэкономным  с 
точки зрения использования памяти, если граф разрежен. Так, например, 
известно, что число ребер связного планарного графа с n вершинами не 
превосходит величины (3n − 6) при n ≥ 3
, то есть, оценивается величиной 
O(n
), а не как в общем случае O(n2). Представлять такие графы матрицей 
смежности, как правило, нецелесообразно. 

Другой способ представления графа – это список или массив пар вер-
шин, представляющих ребра. При таком способе, если граф не ориенти-
рован, то из двух возможных пар (i, j) и (j, i) целесообразно хранить толь-
ко одну, например, ту, у которой первая ком

понента меньше второй. 

Еще  один  способ,  часто  имеющий  преимущества  перед  указанными 
выше – это представление графа массивом или списком списков (см. рис. 
9). А именно, для каждой вершины организуется список смежных с ней 
 вер-
вершин. В этом случае легко осуществляется доступ к окрестностям
ши
н.  Примерно  такого  же  эффекта  можно  достичь,  представляя  граф  с 
помощью двух массивов: inf [1..m] и adr [1..(n + 1)], где m – число ребер 
графа. Массив adr назовем адресным, а inf – информационным. В инфор-
мационном  массиве  вначале  перечисляются  номера  вершин,  смежных  с 
первой вершиной, затем со второй и так далее. В адресном массиве ука-
зываются номера позиций информационного массива так, чтобы для каж-
дой  вершины  i  по  ним  можно  было  находить  фрагменты  массива  inf,  в 
которых записаны номера вершин смежных с этой вершиной. Например, 
adr[i] может хранить позицию, с которой начинаются в массиве inf вер-
шины, смежные с i-й, при этом adr[n + 1] – первая позиция за пределами 
массива inf. В таком случае, если нам требуется с каждой вершиной j из 
окрестности вершины i выполнить оператор S(j), то можно сделать это с 
помощью оператора цикла 

 

for k := adr[i] to adr [i + 1]−1 do S(inf[k]). 

 i, а второй раз в

Заметим, что если граф не ориентирован, то каждое ребро (i, j) будет 
представлено дважды: один раз в последовательности вершин, смежных с 
 последовательности вершин, смежных с вер-
вершиной
шиной j. Но эта
ки зрения вре-
мен
и выполнения операций над окрестностями вершин графа. Как недос-
таток такого представления графа можно отметить неудобство при дина-
мической  модификации  графа,  например,  добавление  к  графу  ребра  мо-

 избыточность бывает часто полезна с точ

 

195

 

 

 

 

  

  

v

v

жет потребовать большого количества пересылок в массиве inf. Этого не-
достатка лишен способ представления графа, показанный на рис. 9. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Представление графа комбинацией списков: множество вершин представлено 
. 

. 9. 
писк м (v1, v2, …, vn
с

в, к каждому из которых справа подцеплен список 
смежных с ним вершин 

. 

) узло

Рис

  

  

 

 

 

 

о

1  2

n 

v

  

  

 196

 

 
 
 

 

 

Глава 2. РАЗДЕЛЕННЫЕ МНОЖЕСТВА 

Разделенные множества – это абстрактный тип данных, предназна-
ченный  для  представления  коллекции,  состоящей  из  некоторого  числа k 
попарно непересекающихся подмножеств U1, U2, ..., Uk заданного множе-
ства  U.  Для  простоты  в  качестве  U  будем  рассматривать  множество 
{1, 2, …, n}. 

Этот тип данных применяется в таких задачах, как отыскание мини-
мального  остовного  дерева  для  заданного  взвешенного  неориентирован-
ного графа, построение компонент связности графа, минимизация конеч-
ного автомата и многих других, требующих динамического поддержания 
некоторого отношения эквивалентности. Примеры таких задач будут рас-
смотрены ниже. 

Как  правило,  в  таких  задачах  вычисления  начинаются  с  пустой  кол-
лекции подмножеств (k = 0). Затем по мере вычислений формируются но-
вые подмножества, включаемые в коллекцию. Формирование новых под-
множеств  осуществляется  либо  путем  создания  одноэлементного  под-
множества,  либо  путем  объединения  уже  существующих  в  коллекции 
подмножеств.  Для  осуществления  таких  действий  используются  имена 
включенных в коллекцию подмножеств. В качестве имени подмножества 
будем  использовать  один  из  его  элементов  (главный  элемент),  выбирае-
мый по определенному правилу. Поскольку в коллекции всегда будут на-
ходиться  попарно  непересекающиеся  подмножества  множества  U,  такое 
имя будет однозначно определять требуемое подмножество. 
 

2.1. Операции над разделенными множествами 

 

СОЗДАТЬ  (x).  Эта  операция  предназначена  для  введения  в  коллек-
цию  нового  подмножества,  состоящего  из  одного  элемента  x,  при  этом 
предполагается,  что  x  не  входит  ни  в  одно  из  подмножеств  коллекции, 
созданной к моменту выполнения этой операции. Элемент x указывается в 
качестве  параметра.  Именем  созданного  подмножества  будет  считаться 
сам элемент x. 

ОБЪЕДИНИТЬ (x, y). С помощью этой операции можно объединить 
два  подмножества  коллекции,  имеющие,  соответственно,  имена  x  и  y,  в 
одно  новое  подмножество,  при  этом  оба  объединяемые  подмножества 

 

197

 

 

удаляются  из  коллекции,  а  вновь  построенное  подмножество  получает 
некоторое  имя.  Во  всех  рассматриваемых  нами  случаях  именем  нового 
полученного  в  результате  этой  операции  подмножества  будет  одно  из 
имен x или y. Имена объединяемых подмножеств указываются в качестве 
параметров. 

НАЙТИ (x,  y).  Эта  операция  позволяет  определить  имя  y  того  под-
множества коллекции, которому принадлежит элемент x. Если элемент x 
до выполнения операции не входил ни в одно из подмножеств коллекции, 
то в качестве y берется 0. 

Последовательность  σ,  составленную  из  операций  типа  СОЗДАТЬ, 

ОБЪЕДИНИТЬ,  НАЙТИ,  назовем  корректной,  если  перед  выполнени-        
ем  каждой  операции  из  последовательности  σ  выполнены  условия  ее 
применения.  Например,  перед  выполнением  очередной  операции  вида 
ОБЪЕДИНИТЬ  (x,  y)  подмножества  с  именами x  и y  должны  быть  уже 
созданы. Перед выполнением операции СОЗДАТЬ (x), элемент x не дол-
жен  принадлежать  ни  одному  из  подмножеств  коллекции.  Операция 
НАЙТИ (x, y) применима при любом значении аргумента x ∈ U. Следует 
только  помнить,  что  если  x  не  принадлежит  ни  одному  из  подмножеств 
коллекции, то получим y = 0. 

Мы рассмотрим несколько способов представления коллекции разде-
ленных  множеств  в  памяти  компьютера  и  алгоритмической  реализации 
перечисленных операций. А именно, будут рассмотрены представления 

•  с помощью массива, 
•  с помощью древовидной структуры, 
•  с  помощью  древовидной  структуры  с  использованием  рангов  вер-

шин, 

шин и сжатия путей.  

•  с  помощью  древовидной  структуры  с  использованием  рангов  вер-

Последний из перечисленных способов является наиболее эффектив-
ным по времени выполнения произвольных корректных последовательно-
стей операций типа СОЗДАТЬ, ОБЪЕДИНИТЬ, НАЙТИ. Строго говоря, 
во всех перечисленных случаях будут использоваться массивы, но интер-
претации их содержимого будут различными. Каждый раз при описании 
очередной  реализации  мы  будем  обсуждать  оценки  трудоемкости  рас-
сматриваемых операций. 
 
 
 

2.2. Примеры использования разделенных множеств 

 

 198

 

 

Пример   1. Рассмотрим задачу выделения компонент связности не-
ориентированного графа. Напомним, что компонентой связности называ-
ется максимальное по включению подмножество вершин графа такое, что 
любые  две  его  вершины  связаны  цепью.  Полагаем,  что  вершины  графа 
пронумерованы  числами  1,  2,  ...,  n  и  каждое  ребро  представлено  парой 
(i, j) номеров вершин. Предполагаем также, что множество ребер непусто. 
Алгоритм  выделения  компонент  связности  неориентированного 

графа. 
1.  Создать коллекцию из n одноэлементных подмножеств множества 

 

{1, 2, ..., n}; 

2.  Прочитать очередное ребро (i, j); 
3.  Найти имя a подмножества коллекции, содержащего элемент i; 
4.  Найти имя b подмножества коллекции, содержащего элемент j; 
5.  Если a ≠ b, то объединить подмножества коллекции с именами a и 

b; 

 

 

6.  Если  есть  еще  непрочитанные  ребра,  перейти  к  п.  2,  в  противном 

случае закончить вычисления. 

 

Очевидно, построенные подмножества коллекции будут представлять 
искомые компоненты связности. Используя названия основных операций 
над  коллекцией  разделенных  множеств,  представленный  выше  алгоритм 
можно записать в следующем виде 
1.  For i:= 1 to n do СОЗДАТЬ (i); 
2.  Прочитать очередное ребро (i, j); 
3.  НАЙТИ (i, a);  
4.  НАЙТИ (j, b);  
5. 
6.  Если  есть  еще  непрочитанные  ребра,  перейти  к  п.  2,  в  противном 

if a ≠ b then ОБЪЕДИНИТЬ (a, b);  

случае закончить вычисления. 

 

Пример   2.  Рассмотрим  неориентированный  связный  граф  без  пе-
тель, ребрам которого приписаны в качестве весов вещественные числа. 
Требуется построить остовное дерево, накрывающее все вершины графа и 
имеющее  минимальный  суммарный  вес  входящих  в  него  ребер.  Итак, 
пусть  заданный  граф  G  имеет  множество  V  вершин,  пронумерованных 
числами 1, 2, ..., n, и множество E ребер. Каждому ребру e из множества 
E  поставлена  в  соответствие  пара  (N(e),  K(e))  его  концевых  вершин  и 
число C(e) – его вес. Для решения этой задачи были предложены различ-

 

199

 

 

ные  алгоритмы.  Мы  рассмотрим  алгоритм,  который  предложил  Краскал 
[1], [6]. 
 

Алгоритм Краскала. 

1.  Создать коллекцию из n одноэлементных подмножеств множества        

{1, 2, ..., n}; 

из множества E; 

2.  Создать пустое множество T; 
3.  Во множестве E найти ребро e с минимальным весом и удалить его 

4.  Найти имя a подмножества коллекции, содержащего элемент N(e); 
5.  Найти имя b подмножества коллекции, содержащего элемент K(e); 
6.  Если a ≠ b, то объединить подмножества с именами a и b, а ребро e 

добавить к множеству T; 

7.  Если множество E не пусто и | T | < n − 1, перейти к п. 3, в против-

ном случае закончить вычисления. 

Заметим, что в процессе работы алгоритма во множестве T будут на-
ходиться  ребра,  составляющие  ациклический  подграф  исходного  графа, 
являющийся лесом, состоящим из некоторого числа деревьев. Отсутствие 
циклов гарантируется проверкой «Если a ≠ b» в пункте 6 описанного ал-
горитма. Фактически при a ≠ b происходит объединение двух поддеревь-
ев в одно дерево с помощью ребра e, найденного на шаге 3. 

Если исходный граф связен, как это сказано в постановке задачи, то 
построенное с помощью такого алгоритма множество T будет, очевидно, 
представлять дерево, накрывающее все вершины исходного графа. Дока-
зательство того факта, что суммарный вес входящих в него ребер будет 
минимальным, можно найти в работе [1]. 

В алгоритме естественным образом используется структура разделен-
ных  множеств.  Обратим  внимание  на  операцию  поиска  во  множестве  E 
ребра e с минимальным весом. Эффективность этой операции существен-
но  зависит  от  выбора  структуры  данных  для  хранения  множества  E. 
Приемы эффективного выполнения этой операции рассмотрены в разделе 
«Приоритетная очередь». 
 
 
 
 
 

 

 

 200

 

 

2.3. Представление разделенных множеств 

с помощью массива 

Пусть  U  =  {1,  2,  …,  n}  –  множество,  из  элементов  которого  будет 

строиться коллекция разделенных подмножеств. 

Одним  из  очевидных  способов  представления  коллекции  является 
представление  ее  с  помощью  массива.  При  таком  способе  для  каждого 
элемента i в соответствующей (i-й) ячейке массива помещаем имя (кано-
нический элемент) того подмножества, которому принадлежит элемент i. 
Если элемент i не принадлежит ни одному из подмножеств коллекции, то 
в i-ю ячейку записываем 0. 

Реализация операций с помощью массива. Обозначим через f мас-
сив длины n, с помощью которого будем представлять коллекцию. Пустая 
коллекция представляется массивом, заполненным нулями. 

Операция СОЗДАТЬ (x) осуществляется записью элемента x в ячей-

ку с номером x. Время выполнения операции – O(1). 

Операция ОБЪЕДИНИТЬ (x, y)  осуществляется следующим обра-
зом. Просматриваются элементы массива f и в те ячейки, в которых было 
записано  имя х,  заносится  новое  имя  – у. Таким образом, именем вновь 
образованного подмножества будет у, а x перестанет быть именем какого-
либо подмножества. Очевидно, время выполнения этой операции – O(n). 

Операция НАЙТИ (x, y) выдает в качестве y содержимое элемента с 

номером х в массиве f. Время выполнения операции – O(1). 

 

 

 

 

При  такой  реализации  разделенных  множеств  очевидно  время  вы-         

полнения  m  произвольных  операций,  среди  которых  O(n)  операций 
ОБЪЕДИНИТЬ есть величина O(m⋅n). 

2.4. Представление разделенных множеств 

с помощью древовидной структуры 

Древовидную структуру для представления разделенных подмножеств 
впервые предложили Галлер и Фишер [8]. Пусть, по-прежнему, U = {1, 2, 
…, n} – множество, из элементов которого будет строиться коллекция. 

Каждое  подмножество коллекции представляется корневым деревом, 
узлы которого являются элементами этого подмножества, то есть отожде-
ствляются с номерами из множества {1, 2, …, n}. Корень дерева исполь-
зуется в качестве имени соответствующего подмножества (канонический 
элемент).  Для  каждого  узла  дерева  определяется  узел  p(x),  являющийся 
его родителем в дереве; если x – корень, то полагаем p(x) = x. 

 

201

 

 

Фактически в памяти компьютера это дерево будем представлять мас-
сивом p[1..n] так, что p(x) будет предком узла x, если x не является кор-
нем, и p(x) = x, если x – корень. Если же x не входит ни в одно из под-
множеств коллекции, то p(x) = 0. 

Рассмотрим пример. Пусть U = {1, 2, …, 7} и коллекция состоит из 
двух  подмножеств  {1,  2,  3,  7}  и  {4,  6}.  Деревья,  представляющие  эти 
подмножества,  могут  быть  такими  как  на  рис.  1.  Кружочки  обозначают 
узлы дерева; указатели на родителей представлены при помощи стрелок. 
Именем одного из этих подмножеств является 3, другого – 6: 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
1 
: 3 

 
3
  3
 

2 

  

p

 

 

 

 

 

 

 

0

2

1

6

6

7

3

4

6

 

 

7

4

 

3

6

5

1

 

  

Реализация операций с помощью древовидной структуры. Опера-

ция  СОЗДАТЬ (x)  назначает  в  качестве  родителя  узла  х  сам  узел  х  с      
помощью присваивания p[x]:= x. Таким образом, время выполнения опе-
рации есть O(1). В результате выполнения операции СОЗДАТЬ (x) обра-
зуется  новое  одновершинное  дерево  с  петлей  в  корне,  изображенное  на 
рис. 2 
 
 
 
 

Если  к  коллекции  подмножеств,  изображенных  на  рис.  1  применить 
операцию СОЗДАТЬ (5), то получим коллекцию, изображенную на рис. 3. 

 

Рис. 1 

x

Рис. 2 

 

 

 

 

 202

 

 

1

2 

3

p

7

 

1
 3

6

4

 

2

1

 

3

3

 

4

6

Рис. 3 

 

5
  5

 

6

6

 

7

3

5

 

 

 
 
 
 
 
 
 
 
 
 
 
 
  

 

Операция ОБЪЕДИНИТЬ (x, y) назначает узел y родителем узла х с 
помощью присваивания p[x]:= y. Заметим, что х и у должны быть до вы-
полнения  рассматриваемой  операции  корнями  соответствующих  деревь-
ев.  Именем  вновь  образованного  подмножества  будет  у,  а  x  перестанет 
быть  именем  какого-либо  множества.  Время  выполнения  этой  операции 
есть O(1). 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
Если  применить  операцию  ОБЪЕДИНИТЬ (3, 6)  к  коллекции,  на 
рис. 3, то получим коллекцию, состоящую из двух подмножеств {1, 2, 3, 

Рис. 4

1 
3 

6

7

3

4

2 

p: 

6
6

7
3

2
1

5

1 

3
6

4
6

5
5

 

 

203

 

 

4, 6, 7} и {5}, изображенную на рис. 4. Именем первого из этих подмно-
жеств будет 6, второго – 5). 

Операция  НАЙТИ (x, y)  осуществляется  продвижением  по  указате-
лям на родителей от узла х до корня дерева. В качестве y берется этот ко-
рень. Описанные действия можно реализовать с помощью операторов 

while р[x] ≠ x do x := p[x]; y := x. 

Очевидно, время выполнения данной операции есть O(h), где h – дли-
на пути из узла х в корень соответствующего дерева. Но заметим, что при 
выполнении операций СОЗДАТЬ и ОБЪЕДИНИТЬ, возможно, образова-
ние дерева в виде линейной цепочки из n узлов, изображенной на рис. 5.  
 
 
 
 
 
 
 
 
 
 
 
 
 

 2

n

1

Рис. 5 

 

К  такой  цепочке  может  привести,  например,  последовательность  опера-
ций 
  СОЗДАТЬ (1); 
  СОЗДАТЬ (2); 
  ……………….. 
  СОЗДАТЬ (n); 
  ОБЪЕДИНИТЬ (1, 2); 
  ОБЪЕДИНИТЬ (2, 3); 
  …………………. 
  ОБЪЕДИНИТЬ (n – 1, n); 

Как  видим,  h  может  достигать  величины  n,  поэтому  трудоемкость 

операции НАЙТИ является величиной O(n). 

Худший  случай  применения  операции НАЙТИ в данной ситуации – 

 

 

 

 

 204

 

 

это  НАЙТИ (1, y).  В  этом  случае  необходимо  сделать  n  –  1  переход  по 
ссылкам на родителей, чтобы дойти от узла 1 к корню дерева n, и один 
переход, чтобы узнать, что родитель узла n есть сам узел n. 

составленной  из  m 

Если количество выполнений операции СОЗДАТЬ равно n, то время 
выполнения  последовательности, 
операций 
ОБЪЕДИНИТЬ  и/или  НАЙТИ,  при  рассматриваемой  реализации  разде-
ленных множеств есть величина O(m⋅n). Действительно, время выполне-
ния m операций ОБЪЕДИНИТЬ, очевидно, есть O(m), так как время вы-
полнения  одной  такой  операции  есть  константа.  Время  выполнения  m 
операций  НАЙТИ  есть  O(m⋅n),  так  как  время  выполнения  одной  такой 
операции есть O(n). Итак, время выполнения m произвольных операций 
есть O(m⋅n). 

2.5. Представление разделенных множеств 

с использованием рангов вершин 

Предыдущую  реализацию  разделенных  множеств  можно  усовершен-
ствовать следующим образом. Операцию ОБЪЕДИНИТЬ можно выпол-
нить  так,  чтобы  высота  дерева,  соответствующего  объединению  двух 
множеств, была как можно меньше. А именно, корень большего по высо-
те дерева сделать родителем корня другого дерева. Назовем такую реали-
зацию операции ОБЪЕДИНИТЬ объединением по рангу. В качестве ран-
га в данном случае берется высота соответствующего дерева.  

Реализация операций с использованием рангов вершин. Для такой 
реализации разделенных множеств необходимо хранить с каждым узлом x 
дополнительно еще одну величину – высоту поддерева, корнем которого 
является узел x. Будем называть ее высотой, или рангом, узла x. Осталь-
ные операции нужно настроить на корректную работу с этим полем. Бу-
дем хранить высоту каждого узла x в ячейке h[x] массива h. 

Операция СОЗДАТЬ (x) назначает в качестве родителя узла х тот же 
самый  х,  а  высотой  узла  х  считат  0.  Таким  образом,  время  выполнения 
данной  операции  есть  O(1).  В  результате  выполнения  операции 
СОЗДАТЬ  (x)  образуется  новое  дерево,  изображенное  на  рис.  6.  Число, 
расположенное рядом с узлом, обозначает его высоту. Описанные дейст-
вия реализуются с помощью операторов 
 

 

 

 

 
 

 

p[x]:= x; h[x]:= 0. 

205

 

0

 x

 
Рис. 6 

 

 
 
 
 
 
 

 

 

 

Операция ОБЪЕДИНИТЬ (x, y) назначает корень большего по вы-
соте дерева родителем корня другого дерева. Если деревья имеют одина-
ковую высоту, то узел у назначается родителем узла х, после чего увели-
чивается значение высоты узла у на единицу. Заметим, что х и у должны 
быть до выполнения операции корнями соответствующих деревьев. Име-
нем вновь образованного подмножества будет имя того из объединяемых 
подмножеств, у которого корень имел большую высоту, а имя другого из 
объединяемых  подмножеств  перестанет  быть  именем  какого-либо  из 
подмножеств. Очевидно, время выполнения этой операции есть констан-
та.  Выполнить  описанные  действия  можно  с  помощью  следующей 
процедуры. 
  Procedure ОБЪЕДИНИТЬ (x, y); 
  begin  
 
 
 
  end; 

if (h[x] < h[y]) then p[x] := y  
else if (h[x] > h[y]) then p[y] := x  
else {p[x] := y; h[y] := h[y] + 1}  

 
 
 

 

На рис. 7 и 8 показано применение операции ОБЪЕДИНИТЬ (3, 6) к 
коллекции, изображенной на рис. 3, с учетом высот объединяемых подде-
ревьев. Рядом с кружочками, изображающими узлы, показаны их высоты. 
Так как h(3) = 2 > h(6) = 1, то родителем узла 6 становится узел 3. 
  Операция НАЙТИ (x, y) осуществляется так же как и в предыдущей 
реализации, продвижением по указателям на родителей от узла х до корня 
дерева.  В  качестве  y  берется  найденный  корень.  Например,  результатом 
применения  операции  НАЙТИ (4, y)  к  коллекции,  изображенной  на       
рис. 8, будет y = 3. 
 
 
 

 206

 

 

2

 

  

  

1

1

  

2

0

  3

0

p
h

  

  

7

  

1
3
1

  

2

3

  

6

 

1

 

4

0

5

  

0

 

 

2
1
0

4
6
0

3
3
2
Рис. 7 

5
5
0

6
6
1

7
3
0

5

 

  

0

1 

  

1

7

0

6

 

1

2

 

0

  
p: 
h

1 
3
1

2
1
0

0
4
6
0
Рис. 8 

3
3
2

3

4

 

 

5
5
0

6
3
1

7
3
0

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Очевидно,  время  выполнения  данной  операции,  как  и  ранее  пропор-
ционально длине пути из узла х в корень соответствующего дерева. Од-
нако длина такого пути в данном случае может быть оценена иначе. Для 
оценки длины этого пути докажем следующие леммы. 

Лемма 1. В результате выполнения любой последовательности опера-

 

207

 

 

ций  из  набора  {СОЗДАТЬ,  ОБЪЕДИНИТЬ,  НАЙТИ}  над  пустой  кол-
лекцией разделенных множеств для любого узла x выполняется неравен-
ство n[x] ≥ 2h(x), где n[x] – количество узлов в поддереве с корнем х, h[x] 
– высота узла х. 

Доказательство.  Очевидно,  перед  первым  применением  операции 
ОБЪЕДИНИТЬ  для  любого  узла  x  имели  n[x]  =  1,  h[x]  =  0  и,  следова-
тельно, n[x] ≥ 2h(x). Операции СОЗДАТЬ и НАЙТИ не могут нарушить 
доказываемое  неравенство,  поэтому  доказательство  можно  провести  ин-
дукцией по количеству применений операции ОБЪЕДИНИТЬ. 

Предположим,  что  перед  очередным  применением  операции 
ОБЪЕДИНИТЬ  (х,  у)  доказываемое  неравенство  все  еще  остается  вер-
ным, тогда если высота узла x меньше высоты узла y, то дерево, получен-
ное с помощью ОБЪЕДИНИТЬ (х, у), имеет корень y, а высоты узлов х и 
у не изменились. Количество узлов в дереве с корнем х не изменилось, а 
количество  узлов  в  дереве  с  корнем  у  увеличилось.  Таким  образом,  как 
для узлов x, y, так и для всех остальных неравенство сохраняется. Случай, 
когда высота узла x больше высоты узла y, аналогичен рассмотренному. 

Если  же  высоты  деревьев  с  корнями  х  и  у  до  выполнения  операции 
были одинаковы (h[x] = h[y] = h), то узел у становится родителем узла х, 
высота узла у увеличивается на 1, а высота узла х не изменяется. Пусть 
после  выполнения  операции  величины  h[x],  h[y],  n[x],  n[y]  становятся 
равными  соответственно  h'  [x],  h'  [y],  n'  [x],  n'  [y],  тогда  имеем  h'  [y]  = 
= h [y] + 1, h' [x] = h[x], n' [x] = n[x], n' [y] = n[y] + n[x]. По предположению 
индукции,  имеем  n[y]  ≥ 2h[y],  и  n[x]  ≥  2h[x].  Следовательно,  после  вы-
полнения рассматриваемой операции для узлов x и y имеем соотношения 
n' [x] = n[x] ≥ 2h[x] = 2h' [x] и n' [y] = n [y] + n [x] ≥ 2h [y] + 2h [x] = 2h + 1 = 
= 2h' [y]. Таким образом, утверждение леммы остается верным и в этом 
случае. 

Лемма 2. Если за время работы, начавшейся с пустой коллекции, опе-
рация СОЗДАТЬ применялась n раз, то для любого h ≥ 0 число k узлов 
высоты h удовлетворяет неравенству k ≤ n/2h. 

Доказательство.  Пусть  x1, x2, ..., xk  –  все  узлы  высоты  h,  тогда  по 
лемме 1 при i = 1, 2, …, k справедливы неравенства n [xi] ≥ 2h. Следова-
тельно, 
 

 

 208

n ≥ n [x1] + n [x2] + ...+ n [xk] ≥ 2kh, 

откуда и следует требуемое неравенство k ≤ n / 2h. 

 

 

Следствие  1.  В  результате  выполнения  любой  последовательности 
операций  из  набора  {СОЗДАТЬ,  ОБЪЕДИНИТЬ,  НАЙТИ}  над  пустой 
коллекцией разделенных множеств, для любого узла x имеет место нера-
венство h[x] ≤ log n. 

Доказательство. Дерево максимальной высоты образуется, очевидно, 
лишь тогда, когда все n элементов объединяются в одно множество. Для 
такого  дерева  количество  k  узлов  максимальной  высоты  h  равно  1,  по 
лемме 2 имеем 1 = k ≤ n / 2h, откуда 2h ≤ n и, следовательно, h ≤ log n. 
Следствие 2. Время выполнения операции НАЙТИ есть O(log n). 
Следствие 3. При реализации разделенных множеств с использовани-
ем рангов время выполнения m операций ОБЪЕДИНИТЬ и/или НАЙТИ 
есть величина O(m·log n). 

Замечание.  При  реализации  операции  объединения  подмножеств  в 
качестве ранга узла можно использовать количество узлов в поддереве с 
корнем  в  данном  узле.  Утверждение  леммы  1  будет  справедливым  и  в 
этом  случае,  следовательно,  сохранятся  и  оценки  времени  выполнения 
операций. 
 

2.6. Представление разделенных множеств 

с использованием рангов вершин и сжатия путей 

 

 

 

 

 

Предыдущий  способ  реализации  разделенных  множеств  можно  еще 
улучшить  за  счет  усовершенствования  реализации  операции  НАЙ-
ТИ (х, y). Она теперь будет выполняться в два прохода. При первом про-
ходе находится корень у того дерева, которому принадлежит х. При вто-
ром проходе из х в у все встреченные узлы делаются непосредственными 
потомками  узла  у.  Этот  прием,  как  увидим  ниже,  намного  уменьшает 
время выполнения последующих операций НАЙТИ. 

Реализация операций c использованием рангов вершин и сжатия 
путей.  Рассматриваемая  реализация  не  требует  новых  полей  данных  по 
сравнению с предыдущим случаем. Как и прежде, для каждого узла i бу-
дем хранить указатель p[i] на его родителя и ранг r [i], который теперь не 
обязательно будет равен высоте дерева с корнем i. Он будет равен этой 
высоте, если из последовательности применяемых операций удалить все 
операции найти. 

Операция СОЗДАТЬ (x) выполняется с помощью операторов 

begin p[x]:= x; r[x] := 0 end. 

209

 

 

 

В качестве родителя узла х берется тот же самый х, а его рангом считаем 
0. Таким образом, время выполнения операции есть константа. 

Операция ОБЪЕДИНИТЬ (x, y) выполняется как и прежде, разница 
лишь в том, что вместо массива h используется массив r. Время выполне-
ния операции – константа. 
  Procedure ОБЪЕДИНИТЬ (x, y);  
  begin 
 
 
 
  end; 

if (r [x] < r [y]) then p [x] := y  
else if (r [x] > r [y]) then p [y] := x  
else {p [x] := y; r [y] := r [y] + 1} 

 
 
 

 

Операция  НАЙТИ (x, y),  как  уже  говорилось,  выполняется  в  два 
прохода. При первом проходе мы идем от узла х к его родителю, потом к 
родителю его родителя и так далее, пока не достигнем корня у дерева, со-
держащего узел х. При втором проходе из х в у все встреченные на этом 
пути узлы делаются непосредственными потомками узла у. Будем назы-
вать  это  «сжатием  путей».  Очевидно,  как  и  раньше,  время  выполнения 
одной такой операции есть O(log n). Но ниже будет доказано, что время 
выполнения  m  таких  операций  на  самом  деле  меньше,  чем  O(m·log n). 
Заметим, что при выполнении этой операции ранги узлов не изменяются. 
  Procedure НАЙТИ (x, y); 
  begin 
 
 
  end; 

z := x; while (р [x] ≠ x) do x := p [x]; 
y := x; while (p [z] ≠ z) do {z1 := z; z := p [z]; p [z1]:= y} 

 
 

 

2.7. Анализ трудоемкости 

 

 

 

 210

 

 

 

Для анализа трудоемкости выполнения операций нам потребуются две 
функции.  Одна  из  них,  b(n),  является  суперэкспонентой  и  определяется 
следующим образом: 

b(0) = 0,      b(n) = 2b(n–1)  при  n > 0. 

Вторая  –  суперлогарифм  log  *n,  по  основанию  2,  определяемая  соотно-
шением: 

log *n = max{k: b(k) ≤ n} 

 

 

Суперлогарифм  является  в  некотором  смысле  обратной  функцией  к 
суперэкспоненте,  log*(b (n)) = n.  Значения  функций  log*n  и  b (n)  при  не-
скольких значениях аргументов приведены в следующих таблицах. 

 

 

n 
b(n) 
0 
0 

1 
1 

0 
0 
2 
2 

1 
1 
4 
3 

3 
2 

2 
2 

3 
4 
5  … 15
3  … 3 

4 
16 

5 

65536 

6 
265536

n 

16  … 65535 65536  …  265536–1 
4  … 4 

5  … 

5 

 

log*n 
Ребро (x, p(x)) при текущем состоянии коллекции назовем корневым, если 
p(x) − корень и p(x) = x (петля); назовем его прикорневым, если p(x) − ко-
рень и p(x) ≠ x, в противном случае – внутренним. 

Отметим  следующие свойства коллекции на множестве из n элемен-
тов. Прикорневое ребро может превратиться во внутреннее, а корневое в 
прикорневое только при выполнении операции ОБЪЕДИНИТЬ. 

Внутреннее  ребро  (x, y)  при  первом  же  выполнении  операции 
НАЙТИ, «проходящей через него», исчезает, но вместо него появляется 
прикорневое ребро (x, y′ ), при этом r (y′ ) > r (y), следовательно, внутрен-
нее ребро «участвует в поиске» не более одного раза. 

Если при выполнении очередной операции ОБЪЕДИНИТЬ (x, y) узел 
y становится родителем узла x, то после ее выполнения справедливо нера-
венство r (y) > r (x). 

При  выполнении  операции  НАЙТИ  ранги  узлов  не  изменяются,  но 

узлы могут менять своих родителей, то есть меняется структура леса. 

Если перед выполнением операции НАЙТИ узел х был родителем уз-
ла у, а после выполнения этой операции родителем узла у стал узел х' ≠ х, 
то выполняется неравенство r (x) < r (x' ). Следовательно, даже после из-
менения  леса  в  результате  выполнения  операции  НАЙТИ  ранги  вдоль 
любого пути от листа к корню будут строго возрастать. 

При выполнении операции ОБЪЕДИНИТЬ ранг любого некорневого 
элемента не изменяется, а ранг корня либо сохраняется, либо увеличива-
ется на 1. 

Теорема.  Время  выполнения  последовательности  операций,  состоя-
щей  из  n  операций  СОЗДАТЬ,  u ≤ n – 1  операций  ОБЪЕДИНИТЬ  и  f 
операций  НАЙТИ,  при  использовании  рангов  и  сжатия  путей  является 
величиной O((f + n) log *u). 

Доказательство. Пусть s1, s2, …, sm – все операции вида СОЗДАТЬ, 
ОБЪЕДИНИТЬ, НАЙТИ, объявленные в формулировке теоремы и выпи-

 

211

 

 

санные в порядке их следования, m = n + u + f. Очевидно, суммарная тру-
доемкость всех операций СОЗДАТЬ есть O(n), суммарная трудоемкость 
всех  операций  ОБЪЕДИНИТЬ  есть  O(u).  Остается  оценить  суммарную 
трудоемкость операций НАЙТИ.  

Через rt(x) обозначим ранг узла x, который получится после выполне-
ния операции st, а pt(x) − родитель узла x, получающийся после выполне-
ния этой операции. 

Определим  множество  Gk(t) = {x:  log  *rt(x) = k} = {x:  b(k)  ≤  rt(x)  <      

< b(k + 1)}. Для краткости будем обозначать log *rt(x) = it(x). 

Поскольку ранг узла может увеличиваться лишь при выполнении опе-
рации ОБЪЕДИНИТЬ, причем не более чем на 1, то после u таких опера-
ций ранг никакого узла не может стать больше u, следовательно, макси-
мальный индекс k при котором Gk(t) может быть непустым равен log *u. 
Оценим теперь суммарное время, требуемое для выполнения f опера-
ций  НАЙТИ,  очевидно,  оно  пропорционально  числу  ребер,  ведущих  от 
сыновей к отцам и встречающихся при выполнении всех таких операций. 
Для оценки времени, затрачиваемого на реализацию этих операций, при-
меним  бухгалтерский  прием.  Отнесем  расход  времени  на  прохождение 
очередного ребра (x, y) от узла x к его родителю y при выполнении опера-
ции  st+1  типа  НАЙТИ  на  одну  из  трех  разных  статей  расходов:  «корне-
вую», «транзитную» и «местную» в зависимости от следующих условий. 

Если it(x) ≠ it(y) и y в рассматриваемый момент не является корнем, то 
на  статью  T  транзитных  расходов.  Если  it(x) = it(y)  =  k  и  y  не  является 
корнем, то расходы относим на статью Mk местных расходов в k-ом диа-
пазоне, если же y – корень, то на статью K корневых расходов. 

Сумму местных расходов во всех диапазонах обозначим через 

 

M

=

lg

u*

∑

k

=

0

. 

kM

 

Тогда  имеем  K = O(f  ),  так  как  при  каждом  выполнении  операции 
НАЙТИ проходится одно корневое и возможно одно прикорневое ребро. 
Для транзитных переходов имеем T = O(f·log *u), так как при каждом 
выполнении операции НАЙТИ происходит не более log *u переходов из 
одного диапазона в другой. 

Для оценки величины M введем потенциал ct(x) = rt(pt(x)) узла x после 
выполнения  операции  st.  Если  к  узлу  x  еще  не  применялась  операция 
СОЗДАТЬ, то ct(x) = 0. 

Потенциалом группы Gk(t) при текущем состоянии коллекции назовем 

 212

 

 

величину  

tC
)(

k

=

∑

xc
.)(
t
tGx
)(
∈

k

. 

Очевидно, в любой момент времени справедливы неравенства 

(1) 
Покажем,  что  для  любого  узла  x  при  любом  t  =  1, 2, 3,…, m  выпол-

Ck(t) ≤ |Gk(t)| b(k + 1). 

няется неравенство ct(x) ≥ ct–1(x). 

Действительно,  если  st  −  операция  СОЗДАТЬ (x)  то  ct–1(x) = ct(x) = 0, 
то есть потенциал узла x также как, очевидно, и всех остальных не изме-
няется. 

Пусть st − операция ОБЪЕДИНИТЬ (x, y). В случае rt–1(x) < rt–1(y) име-
ем ct(x) = rt(p(x))   = rt(y) = rt–1(y)   > rt–1(x) = rt–1(p(x)) = ct–1(x) и ct(y) = ct–1(y). 
Случай  rt–1(x) > rt–1(y)  аналогичен.  В  случае  rt–1(x) = rt–1(y)  имеем  ct(y)  = 
= rt(p(y)) = rt(y)  =  rt–1(y) + 1 > rt–1(y) = rt–1(p(y)) = ct–1(y), ct(x) = rt(p(x)) = 
= rt(y) = rt–1(y)+1 > rt–1(y) = rt–1(x) = rt–1(p(x)) = ct–1(x). 

Пусть теперь st является операцией НАЙТИ, проходящей через узел x 
и  при  этом  pt–1(x)  не  корень  (x  получает  нового  родителя  pt(x)).  Тогда 
имеем  ct(x) = rt(pt(x)) = rt–1(pt(x)) > rt–1(pt–1(x)) = ct–1(x).  В этом  случае  со-
вершен переход по внутреннему ребру (местный или транзитный). 

Итак, для любого узла x величина c(x) при выполнении операции вида 
СОЗДАТЬ, ОБЪЕДИНИТЬ, НАЙТИ, не может уменьшиться и, следова-
тельно,  

 

Суммируя это неравенство по всем t и, учитывая неравенства (1), по-
лучаем,  что  число  Mk  местных  переходов  при  всех  операциях  НАЙТИ 
удовлетворяет неравенству 

Mk ≤ Ck(m) – Ck(0) ≤ Ck(m) ≤ |Gk| b(k + 1). 

Заметим  далее,  что  утверждение  леммы  2,  которая  гарантирует,  что 
количество узлов ранга r не более n/2r остается верным и при использова-

 

213

 

 

 

 

 

 

 

 

 

 

Ck(t) ≥ Ck(t – 1). 

При этом, если st – операция НАЙТИ, то у Mk(t)  вершин при ее вы-
полнении  потенциал  увеличится,  по  крайней  мере,  на  1,  следовательно, 
число Mk(t) местных переходов в группе Gk(t) при ее выполнении удовле-
творяет неравенству  

Mk(t) ≤ Ck(t) – Ck(t – 1). 

 

 

нии сжатия путей, так как при выполнении операции НАЙТИ ранги эле-
ментов не меняются. Следовательно, справедливы соотношения 
n
+

11
++++
2

2
kb
(

= ∑

n
2
2
kb
(

n
2
r

n
kb
(

1
4

kb
(

1)1
−+

1
8

)1

...

|

G

k

|

.

 

=

)

kbr
)(
=

<

2

⎞
=⎟
⎠

⎛
⎜
⎝

)

 

Отсюда 

M k

n
+

)1

kb
(

2)1
≤+

n

, 

M

=

k∑

nOM
(

=

⋅

log

u
)*

. 

≤

2
kb
(
u
*log

k

=

0

 

 

 

 

 

 

 

 

 

 

 

 

 214

Итак, суммарная трудоемкость выполнения f операций НАЙТИ равна 

K + T + M = O(f + f⋅log *u + n log *u) = O((f + n) log *u), 

Учитывая  теперь  оценки  трудоемкости  операций  СОЗДАТЬ  и 

ОБЪЕДИНИТЬ получаем утверждение теоремы. 

Замечание. Р.Е. Тарьян [8] доказал, что время выполнения последова-
тельности, состоящей из u операций ОБЪЕДИНИТЬ с перемешанными с 
ними f операциями НАЙТИ, где u ≤ n – 1, u + f = m, является величиной 
O(m α(m, n)). Также он показал, что эта оценка не может быть улучшена, 
а,  значит,  алгоритм  может  потребовать  для  своего  выполнения 
Ω (m α (m, n)) времени. 

Здесь  α (f, n) = min{i ≥ 1: A (i, ⎣f / n⎦) > log  n},  где  A (i, j)  –  функция 

Аккермана, задаваемая равенствами: 

A (1, j) = 2j при j ≥ 1, 

A (i, 1) = A (i – 1, 2) при i ≥ 2, 

A (i, j) = A (i – 1, A(i, j – 1)) при i, j ≥ 2. 

Сводные данные о сложности операций 

с разделенными множествами 
Реализация с помощью массива 

СОЗДАТЬ (x) 
ОБЪЕДИНИТЬ (x, y) 
НАЙТИ (x, y) 
m операций 

O(1) 
O(n) 
O(1) 
O(mn) 

 

 

Реализация с помощью древовидной cтруктуры 

СОЗДАТЬ (x)  
ОБЪЕДИНИТЬ (x, y) 
НАЙТИ (x, y) 
m операций 

O(1) 
O(1) 
O(n) 
O(mn) 

Реализация с помощью древовидной структуры 

с использованием рангов вершин 

СОЗДАТЬ (x) 
ОБЪЕДИНИТЬ (x, y) 
НАЙТИ (x, y) 
m операций 

O (1) 
O(1) 
O(log n) 
O(m log n) 

Реализация с помощью древовидной структуры 

с использованием рангов и сжатия путей 
СОЗДАТЬ (x) 
ОБЪЕДИНИТЬ (x, y) 
НАЙТИ (x, y) 
m операций 

O(1) 
O(1) 
O(log n) 
O(n lg*(u + 1)) 
O(m α (m, n)) 

215

 

 

 

 

 

 

 

 

Глава 3. ПРИОРИТЕТНЫЕ ОЧЕРЕДИ 

3.1. Основные определения 

 

 
 
 

 

 

 216

Приоритетная  очередь  –  это  абстрактный  тип  данных,  предназна-
ченный для представления взвешенных множеств. Множество называется 
взвешенным, если каждому его элементу однозначно соответствует чис-
ло,  называемое  ключом  или  весом.  Основными  операциями  над 
приоритетной очередью являются следующие операции. 

•  ВСТАВИТЬ во множество новый элемент со своим ключом.  
•  НАЙТИ во множестве элемент с минимальным ключом. Если эле-
ментов с минимальным ключом несколько, то находится один из 
них. Найденный элемент не удаляется из множества. 

•  УДАЛИТЬ из множества элемент с минимальным ключом. Если 
элементов  с  минимальным  ключом  несколько,  то  удаляется  один 
из них. 

Дополнительные операции над приоритетными очередями. 
•  ОБЪЕДИНИТЬ два множества в одно. 
•  УМЕНЬШИТЬ ключ указанного элемента множества на заданное 

положительное число. 

Приоритетная  очередь  естественным  образом  используется  в  таких 
задачах,  как  сортировка  элементов  массива,  отыскание  во  взвешенном 
неориентированном  графе  минимального  остовного  дерева,  отыскание 
кратчайших  путей  от  заданной  вершины  взвешенного  графа  до  его  ос-
тальных вершин и многих других. 

Приоритетную  очередь  можно  представить  с  помощью  массива  или 
списка  элементов,  но  такие  реализации  не  эффективны  по  времени  вы-
полнения  основных  операций.  Так,  например,  поиск  элемента  с  мини-
мальным ключом в неупорядоченном массиве или списке требует после-
довательногого просмотра всех его элементов. Если поддерживать упоря-
доченность массива или списка по ключу, то «неудобной» окажется опе-
рация вставки нового элемента. 

Чаще  всего  приоритетная  очередь  представляется  с  помощью  корне-
вого дерева или набора корневых деревьев с определенными свойствами. 
При  этом  узлам  дерева  ставятся  во  взаимно  однозначное  соответствие 
элементы рассматриваемого множества. 

 

 

Соответствие между узлами дерева и элементами множества называ-

ется кучеобразным, если для каждого узла i соблюдается условие: 

Ключ  элемента,  приписанного  узлу  i,  не  превосходит  ключей  эле-

ментов, приписанных его потомкам. 

Такие представления взвешенных множеств называются кучами. Вид 
дерева  и  способ  его  представления  в  памяти  компьютера  подбирается  в 
зависимости  от  тех  операций,  которые  предполагается  выполнять  над 
множеством  и  от того, насколько эти операции сказываются на суммар-
ной трудоемкости алгоритма. 
 

3.2. Представление приоритетной очереди  

с помощью d-кучи 

 

 

 

Представления приоритетной очереди с помощью d-кучи, основано на 

использовании так называемых завершенных d-арных деревьев (d ≥ 2). 

Завершенное  d-арное  дерево  −  это  корневое  дерево  со  следующими 

свойствами: 

1. Каждый внутренний узел (то есть узел, не являющийся листом де-
рева), за исключением, быть может, только одного, имеет ровно d потом-
ков. Один узел-исключение может иметь от 1 до d – 1 потомков. 

2. Если k − глубина дерева, то для любого i = 1, ..., k – 1 такое дерево 

имеет ровно d 

i узлов глубины i. 

3.  Количество  узлов  глубины  k  в  дереве  глубины  k  может  варьиро-

ваться от 1 до d 

k. Это свойство является следствием первых двух. 

Узлы завершенного d-арного дерева принято нумеровать следующим 
образом:  корень  получает  номер  0,  потомки  узла  с  номером  i  получают 
номера: i⋅d + 1, i⋅d + 2, ..., i⋅d + d. Такая нумерация удобна тем, что позво-
ляет разместить узлы дерева в массиве в порядке возрастания их номеров, 
при этом позиции потомков любого узла в массиве легко вычисляются по 
позиции самого узла. Так же легко по позиции узла вычислить позицию 
его  родителя.  Так  для  узла,  расположенного  в  позиции  i,  родительский 
узел располагается в позиции (i – 1) div d, где div – операция деления на-
цело. 

В  изображении  завершенного  d-арного  дерева  узлы  одинаковой  глу-
бины удобно располагать на одном уровне, при этом потомки одного узла 
располагаются слева направо в порядке объявленных номеров. При таком 
рисовании нижний уровень заполняется, возможно, не полностью. 

Отметим некоторые простые утверждения о завершенных d-арных де-

 

217

 

 

ревьях, которые будут полезны при анализе трудоемкости основных опе-
раций. 

Утверждение 1. Длина h пути из корня завершенного d-арного дерева 

с  n > 1  узлами  в  любой  лист  удовлетворяет  неравенствам: log d n – 1 <     
< h < log d n + 1. 

Доказательство. Минимальное количество узлов в d-куче высоты h 
(h > 0), по свойствам 2 и 3 d-арного дерева, очевидно, равно 1 + d + d 2 +  
+  … + d h – 1 + 1 (последний уровень содержит лишь один узел).  

Максимальное количество узлов в такой d-куче равно 1 + d + d 

2 + … 
h узлов). Отсюда имеем неравенст-

h (последний уровень содержит d 

(1 + d + d 

2 + ⋅⋅⋅ + d 

h – 1 + 1) ≤ n ≤ (1 + d + d  

2 + ⋅⋅⋅ + d 

h). 

Суммируя левую и правую части как геометрические прогрессии, по-

(d 

h – 1) / (d – 1) + 1 ≤ n ≤ (d 

h + 1 – 1) / (d – 1), 

и после некоторых очевидных оценок с помощью логарифмирования по-
лучаем требуемые неравенства: 

log d n – 1 < h < log d n + 1. 

Утверждение  2.  Количество  узлов  высоты  h  не  превосходит  n/d 

h. 
(Под высотой узла понимается расстояние от него до наиболее далекого 
потомка). 

Кучу, содержащую n элементов, будем представлять двумя массивами 
a[0 .. n − 1]  и  key[0 .. n − 1],  полагая  a[i]  −  имя  элемента,  приписанного 
узлу i; key[i]  − его ключ. Иногда под a[i] удобно понимать сам элемент 
исходного множества или ссылку на него. В некоторых прикладных зада-
чах  нет  необходимости  помещать в приоритетную очередь ни сами эле-
менты, ни их имена, в таких случаях при организации кучи используется 
лишь массив key[0 .. n − 1]. 

На  рис.  1  приведен  пример  кучи  для  d = 3,  n = 18.  Кружочками  изо-
бражены узлы дерева, в них записаны элементы массива, представляющие 
имена элементов кучи. 

Пример кучи при d = 3, n = 7 для приоритетной очереди, содержащей 
элементы с ключами 1, 2, 2, 2, 3, 4, 5, изображен на рис. 2, где пара чисел 
в каждом кружочке обозначает номер узла и ключ соответствующего эле-
мента. 

+ + d 
ва: 
 

лучим 

 

 

 

 

 

 218

 

 

a[0]

a[1]

a[2]

a[3]

a[4] 

a[5] a[6]

 

a[7] a[8] a[9]

a[10]

a[11]

a[12] 

a[13]  a[14]  a[15] 

a[16] a[17]

Рис. 1 

0:1

1:2

2:2

3:2

4:3 

5:4

6:5

Рис. 2 

 
 
 
 
 
 
 
 
 
 
 
 

 

 
 
 
 
 
 
 
 
 

 

При  реализации  основных  операций  над  кучами  используются  две 
вспомогательные операции – ВСПЛЫТИЕ и ПОГРУЖЕНИЕ. При реали-
зации этих операций будем использовать еще одну вспомогательную опе-
рацию  –  транспонирование,  с  помощью  которой  будем  менять  местами 
элементы, расположенные в двух разных узлах дерева. Ее реализация мо-
жет быть представлена следующим образом: 

 

Procedure tr(i, j); 
begin  

temp0 := a[i]; a[i] := a[j]; a[j] := temp0; 
temp1 := key[i]; key[i] := key[j]; key[j] := temp1; 

end; 

 

Замечание.  Если  в  кучу  помещаются  только  ключи  элементов,  то 
процедура  транспонирования  модифицируется  соответствующим  обра-
зом. 

 

219

 

 

Операция ВСПЛЫТИЕ. Эта операция может быть применена в тех 
случаях, когда в некотором узле кучи, например, в i-ом, расположен эле-
мент x, нарушающий кучеобразный порядок, то есть ключ элемента в узле 
i меньше ключа элемента y, приписанного узлу, являющемуся родителем 
узла i. 

Данная  операция  меняет  местами  х  и  y.  Если  после  этого  элемент  х 
снова не удовлетворяет условиям кучи, то еще раз проводим аналогичную 
перестановку. И так до тех пор, пока х не встанет на свое место. 

Рассмотрим 3-дерево, представленное на рис. 3. В этом дереве куче-
образный  порядок  нарушает  элемент  с  ключом  14,  приписанный  узлу  с 
номером 17, так как его родительскому узлу приписан элемент с ключом 
31 > 14. 
 
 
 
 
 
 
 
 
 
 
 

7:40  8:16  9:32 

13:33  14:34

5:31  6:36 

15:35 

12:50 

17:14

10:18

16:33

11:19

0:13 

2:15 

1:21 

4:30 

3:17 

Рис. 3 

0:13 

Применим к узлу 17 операцию ВСПЛЫТИЕ. Элементы с ключами 31 
и 14 меняются местами. В результате получается дерево представленное 
на рис. 4. 
 
 
 
 
 
 
 
 
 
 
 

7:40  8:16  9:32 

13:33  14:34

5:14  6:36 

15:35 

12:50 

16:33

17:30

11:19

10:18

1:21 

2:15 

4:30 

3:17 

 

 

 

 220

 

 

Рис. 4. 

 

Теперь нарушен кучеобразный порядок в узле 5 (21 > 14), меняем мес-
тами элементы c ключами 21 и 14. В результате получаем кучу, изобра-
женную  на  рис. 5.  Кучеобразный  порядок  восстановлен,  операция 
ВСПЛЫТИЕ завершена. 
 
 
 
 
 
 
 
 
 
 
 

7:40  8:16  9:32 

13:33  14:34

5:21  6:36 

12:50 

15:35 

16:33

17:30

10:18

11:19

0:13 

1:14 

2:15 

3:17 

4:30 

Рис. 5 

 

 

 

 

 

Вычислительная  сложность  этой  операции  пропорциональна  числу 
сравнений  элементов  и  их  обменов.  Это  число,  очевидно,  не  более  чем 
удвоенное число узлов в пути от узла x до корня дерева. Длина такого пу-
ти в d-куче с n узлами не превосходит ее высоты, а именно logd n + 1, по 
доказанному  выше  утверждению  1.  Значит,  время  выполнения  данной 
операции – O(logd n). 

Реализация операции ВСПЛЫТИЕ. Входным параметром этой опе-

рации является номер узла, в котором нарушен порядок. 

procedure ВСПЛЫТИЕ(i); 
begin 
p := (i – 1) div d;   
while (i ≠ 0) and (key[p] > key[i]) do {tr(i, p); i := p; p := (i – 1) div d}; 
end; 
Замечания 
1. Операцию ВСПЛЫТИЕ можно применять не только к d-куче, но и к 

другим видам куч. 

2. Для более эффективного выполнения операции ВСПЛЫТИЕ можно 
поступить следующим образом. Запомнить элемент, находящийся в узле 
i, переместить элемент из его родительского узла p = (i – 1) div d в узел i, 

 

221

 

 

 

затем из узла (p – 1) div d в узел p и так до тех пор, пока не освободится 
узел  для  запомненного  элемента.  После  этого  поместить  запомненный 
элемент на освободившееся место. Более точно это можно выразить с по-
мощью операторов: 

 

begin  
key0:= key[i]; a0:= a[i]; p := (i – 1) div d; 
while (i ≠ 0) and (key[p] > key0 do 
{a[i]:=a[p]; key[i]:= key[p]; i:= p; p:= (i – 1) div d}; 
a[i]:= a0; key[i]:= key0 
end; 
Операция  ПОГРУЖЕНИЕ.  Эта  операция  также  применяется  для 
восстановления  свойства  кучеобразности.  Пусть,  например,  в  i-ом  узле 
расположен элемент x, нарушающий кучеобразный порядок таким обра-
зом, что ключ элемента x больше ключа элемента y, приписанного потом-
ку узла i. В этом случае среди непосредственных потомков узла i выбира-
ется тот, которому приписан элемент y с наименьшим ключом и элементы 
х и y меняются местами. Если после этого элемент х снова не удовлетво-
ряет условиям кучи, то еще раз проводим аналогичную перестановку. И 
так до тех пор, пока х не встанет на свое место. 

Рассмотрим 3-дерево представленное на рис. 6. В узле 1 расположен 

0:13 

элемент  х  с  ключом  31,  и  этот  узел  имеет  двух  потомков  с  меньшими    
ключами,  а  именно  30  и  14.  Применим  к  элементу  х  операцию 
ПОГРУЖЕНИЕ. 
 
 
 
 
 
 
 
 
 
 
 
 

7:40  8:16  9:32 

13:33  14:34 

5:14  6:36 

12:50 

16:23

17:21

10:18

11:19

15:35 

1:31 

2:15 

3:17 

4:30 

Среди  непосредственных  потомков  узла  1  находим  узел,  которому 

Рис. 6 

 

 222

 

 

0:13 

приписан элемент y с наименьшим ключом, в нашем случае это узел 5, c 
ключом 14. Меняем местами элементы х и y. В результате получается де-
рево, изображенное на рис. 7. 
 
 
 
 
 
 
 
 
 
 
 
 

7:40  8:16  9:32 

13:33  14:34

5:31  6:36 

12:50 

15:35 

10:18

17:21

11:19

16:23

4:30 

3:17 

1:14 

2:15 

Рис. 7 

Теперь элемент x снова имеет потомка с меньшим, чем у него ключом 
(а точнее, оба его потомка имеют меньшие ключи). Снова находим непо-
средственного потомка узла, содержащего элемент х, в котором находится 
элемент  с  наименьшим  ключом,  и  меняем  его  и  x  местами.  Получается 
дерево, изображенное на рис. 8. 
 
 
 
 
 
 
 
 
 
 
 
 

7:40  8:16  9:32 

13:33  14:34 

5:21  6:36 

15:35 

12:50 

17:31

10:18

16:23

11:19

0:13 

1:14 

2:15 

4:30 

3:17 

Рис. 8 

 

 

Теперь  x  находится  в  узле  17  и  не  имеет  потомков  с  меньшим,  чем          

у  него,  ключом  (точнее,  у  него  вообще  нет  потомков).  Операция 
ПОГРУЖЕНИЕ завершена. 

Вычислительная  сложность  этой  операции  пропорциональна  числу 
сравнений элементов и их обменов. Для каждого узла в пути следования 

 

223

 

 

 

 

 

данной операции производится d сравнений (при поиске потомка с мини-
мальным ключом) и один обмен. Длина этого пути в d-куче с n узлами не 
превосходит ее высоты, а именно log d n, по доказанному выше утвержде-
нию 1. Значит время выполнения данной операции – O(d ⋅ log d n). 

Для  реализации  операции  погружения  воспользуемся  функцией 
minchild (i), позволяющей для любого узла i находить его непосредствен-
ного  потомка  с  минимальным  ключом.  Если  у  узла  i  нет  потомков,  то 
minchild (i) = 0. 

 

Реализация операции ПОГРУЖЕНИЕ 
procedure ПОГРУЖЕНИЕ(i); 
begin  
c := minchild(i); 
while (c ≠ 0) and (key[c] < key[i]) do {tr(i, c); i:= c;  
c := minchild (c)} 
end; 
function minchild (i); 
begin 
if i⋅d + 1 > n then minchild := 0 
else 
begin first_child := i ⋅ d + 1;  
last_child := min ((i + 1)⋅d – 1, n); 
min_key := key[first_child]; 
for i := first_child to last_child do  
if key[i] < min_key then {min_key := key[i]; minchild := i} 
end 
end; 
Операция ВСТАВКА. Если перед выполнением этой операции куча 
содержала n  узлов  (напомним, что они пронумерованы числами от 0 до  
n – 1), то добавляем к дереву (n + 1)-й узел (его номер будет n) и припи-
сываем ему элемент с именем nameX и ключом keyX. Вставка нового эле-
мента производится посредством отведения для него места в n-ых пози-
циях  массивов  a  и  key  соответственно,  после  чего  к  добавленному  узлу 
применяется  операция  ВСПЛЫТИЕ  для  восстановления  кучеобразного 
порядка. 

Вставим в d-кучу, изображенную на рис. 9, новый элемент с ключом 

 224

 

14. 
 
 
 
 
 
 
 
 
 
 
 

 

 

 

0:13 

1:21 

2:15 

3:17 

4:30 

5:21  6:36 

7:40  8:16  9:32 

10:18

11:19

12:50 

13:33  14:34 

15:35 

16:23

Рис. 9 

Сначала добавляем к дереву новый узел с номером 17 и приписываем 

0:13 

1:21 

ему элемент с ключом 14. Получим дерево, представленное на рис. 10. 
 
 
 
 
 
 
 
 
 
 
 
 

7:40  8:16  9:32 

13:33  14:34 

11:19  12:50 

5:31  6:36 

15:35 

17:14

10:18

2:15 

3:17 

16:23

4:30 

Рис. 10 

 

 

 

 

 

 

Затем  применяем  к  узлу  17  операцию  ВСПЛЫТИЕ.  При  описании 

этой операции использовался именно этот пример (см. рис. 3, 4, 5). 

Вычислительная  сложность  данной  операции  равна  константе  плюс 

вычислительная сложность операции ВСПЛЫТИЕ, то есть O(logd n). 

Реализация операции ВСТАВКА 
procedure ВСТАВКА (nameX, keyX ); 
begin a[n]:= nameX; key[n] := keyX; ВСПЛЫТИЕ (n); n := n + 1 end; 
Операция  УДАЛЕНИЕ.  Эта  операция  используется  для  удаления 

225

 

 

элемента,  приписанного  узлу  с  заданным  номером  i.  Сначала  элемент, 
приписанный последнему узлу дерева, переносится на место удаляемого 
элемента, последний узел при этом становится ненужным и поэтому уда-
ляется из дерева. Далее, если узел i, в который помещен новый элемент, 
имеет  родителя,  с  большим  ключом,  то  к  узлу  i  применяется  операция 
ВСПЛЫТИЕ, в противном случае − ПОГРУЖЕНИЕ. 

Таким  образом,  ориентируясь  на  худший  случай,  вычислительную 

сложность операции УДАЛЕНИЕ оцениваем величиной O(d⋅log d n). 

 

Реализация операции УДАЛЕНИЕ: 
procedure УДАЛЕНИЕ(i); 
begin  
a[i]:= a[n – 1]; key[i]:= key[n – 1]; n:= n – 1; 
if i ≠ 0 and key[i] < key[(i – 1) div d] then ВСПЛЫТИЕ (i)  
else ПОГРУЖЕНИЕ (i) 
end; 
Операция  УДАЛЕНИЕ_МИНИМУМА.  Эта  операция  предназначе-
на для взятия из кучи элемента с минимальным ключом (он находится в 
корне дерева) и удалением его из кучи с помощью операции УДАЛЕНИЕ. 

 

 

 

 

 

 

 

 226

Реализация операции УДАЛЕНИЕ_МИНИМУМА: 
procedure УДАЛЕНИЕ_МИНИМУМА (nameX, keyX); 
begin nameX:= a[0]; keyX:= key[0]; УДАЛЕНИЕ (0) end; 
Функция  MINKEY.  Эта  функция  предназначена  для  определения 

минимального ключа без удаления соответствующего элемента. 

 

 

 

Реализация функции MINKEY: 
function MINKEY; 
begin MINKEY: = key[0]; end; 
Трудоемкость операции MINKEY, очевидно, равна O(1) 
Операция УМЕНЬШЕНИЕ_КЛЮЧА. Предназначена для уменьше-
ния  ключа у элемента, приписанного узлу с заданным номером i, на за-
данную  величину  ∆.  Это  действие  может  нарушить  кучеобразный  поря-
док лишь таким образом, что уменьшенный ключ элемента в узле i станет 
меньше ключа элемента в родительском узле. Для восстановления поряд-
ка в куче используется операция ВСПЛЫТИЕ. 

Вычислительная сложность данной операции состоит из времени, за-

 

 

 

трачиваемого  на  уменьшение  ключа  (то  есть  константы),  и  времени  вы-
полнения  операции  ВСПЛЫТИЕ  (то  есть  O(log d n)).  В  итоге  вычис-
лительная сложность операции УМЕНЬШИТЬ_КЛЮЧ равна O(log d n). 

 

 

Реализация операции УМЕНЬШЕНИЕ_КЛЮЧА: 
procedure УМЕНЬШИТЬ_КЛЮЧ (i, delta); 
begin key[i] := key[i] – delta; ВСПЛЫТИЕ (i); end; 
Операция  ОКУЧИВАНИЕ.  Заметим,  что  если  d-куча  создается  пу-
тем n-кратного применения операции ВСТАВКА, то суммарная трудоем-
кость ее создания будет равна O(n⋅log d n). Если же все n элементов снача-
ла занимают в произвольном порядке массив a[0 .. n – 1] и, соответствен-
но,  массив  key[0 .. (n − 1)],  то  можно  превратить  их  в  d-кучу,  применяя 
операцию ПОГРУЖЕНИЕ по очереди к узлам (n – 1), (n – 2), … , 0. 

Такой процесс будем называть окучиванием массива. Для доказатель-
ства того, что в результате действительно устанавливается кучеобразный 
порядок  достаточно  заметить,  что  если  поддеревья  с  корнями  в  узлах      
n – 1, n − 2, …, i + 1 упорядочены по правилу кучи, то после применения 
процедуры ПОГРУЖЕНИЕ к узлу i поддерево с корнем в этом узле также 
станет упорядоченным по правилу кучи. 

Итак, остановимся на следующей реализации. 
Реализация операции ОКУЧИВАНИЕ: 
procedure ОКУЧИВАНИЕ; 
begin for i := n – 1 downto 0 do ПОГРУЖЕНИЕ (i) end; 
Утверждение 3. Вычислительная сложность операции ОКУЧИВАНИЕ 

равна O(n). 

Доказательство. Заметим, что трудоемкость погружения с высоты h 
равна O(h), а количество узлов высоты h не превосходит n/d h. Осталось 
оценить сумму  

 

 

 

 

 

 

 

 

H

∑

h

1
=

nh
hd

, 

где H = ⎡log d n⎤ и убедиться, что полученная сумма есть O(n). 

Для суммирования можно воспользоваться формулой 

k

∑

i

1
=

i
x

i

k

1
+

x

=

−
x
k

k
(
x
(

+
−

1)
1)

x
2

+

k

.

 

227

 

 

Предоставляем читателю возможность завершить доказательство. 

  Операция СОЗДАТЬ_СПИСОК_МИНИМАЛЬНЫХ. Эта операция 
применяется  для  получения  списка  элементов,  которые  имеют  ключи 
меньшие  заданного  значения  key0,  и  реализуется  следующим  образом. 
Если ключ элемента, находящегося в корне больше, чем key0, то это дере-
во  не  имеет  искомых  элементов.  В  противном  случае  включаем  его  в 
выходной список S, а затем применяем ту же процедуру ко всем потомкам 
узла, включенного в список. 

Пусть куча содержит k элементов с ключами меньшими, чем key0. По 
свойству кучи, они все расположены на ее «верхушке». Данная процедура 
обходит  эту  верхушку  за  время,  пропорциональное  k,  и  для  каждого  из 
этих  k  элементов  просматривает  все  его  d  (или  меньше)  непосредствен-
ных потомков. Получаем, что время выполнения данной процедуры явля-
ется величиной O (d⋅k). 

Реализация операции СОЗДАТЬ_СПИСОК_МИНИМАЛЬНЫХ: 
procedure СОЗДАТЬ_СПИСОК_МИНИМАЛЬНЫХ(S, key0); 
begin 
 
 
 
 
 
 
 
 
 
end; 

Инициализируем список S пустым списком; 
Инициализируем стек; 
0 ⇒ стек; 
while стек не пуст do 
begin 
стек ⇒ i; 
if (key[i] < key0) then Добавить a[i] к списку S; 
for j:=d*i + 1 to d*(i + 1) do if j ≤ (n – 1) then j ⇒ стек; 
end 

Сводные данные о трудоемкости операций с d-кучами 

ВСПЛЫТИЕ (i) 
ПОГРУЖЕНИЕ (i) 
ВСТАВКА (nameX, keyX) 
УДАЛЕНИЕ (i) 
УДАЛЕНИЕ_МИН (nameX, keyX) 
MINKEY 
УМЕНЬШЕНИЕ_КЛЮЧА (i, ∆) 
ОБРАЗОВАTЬ_ОЧЕРЕДЬ 

O(logd n) 
O(d logd n) 
O(logd n) 
O(d logd n) 
O(d logd n) 
O(1) 
O(logd n) 
O(n) 

 

 

 

 

 228

 

 

СПИСОК_МИН (x, h) 

O(d k) 

Замечание. Для d-куч «неудобной» является операция слияния куч. 

3.3. Применение приоритетных очередей 

в задаче сортировки 

Под задачей сортировки в простейшем случае понимают следующее: 
дана последовательность (key[1], key[2], ... , key[n]) из n элементов неко-
торого  линейно  упорядоченного  множества,  например,  целых  или веще-
ственных чисел, записанных в массив key. Требуется переставить элемен-
ты массива так, чтобы после перестановки выполнялись неравенства: 

Key [1] ≤ key [2] ≤ ... ≤  key [n]. 

 

 

 

 

 

 

 

Уточнения этой задачи связаны с теми средствами, с помощью кото-
рых предполагается ее решение. Нас интересуют алгоритмы с точки зре-
ния  их  компьютерной  реализации.  Оценивая  качество  различных  алго-
ритмов,  обычно  интересуются  тем,  как  зависит  время  счета  от  длины  n 
сортируемой последовательности и требуется ли для этого дополнитель-
ная  память,  размер  которой  зависит  от  n.  Существенную  роль  при  этом 
играет метод доступа к элементам памяти. При сортировке во внутренней 
(оперативной) памяти обычно используется прямой доступ, а во внешней 
– последовательный. 

Бесхитростная сортировка в памяти с прямым доступом. Бесхит-
ростный алгоритм сортировки может заключаться в выполнении следую-
щих операторов 

for k := 1 to n − 1 do for i := k + 1 to n do  
if key[i] < key[k] then tr(i, k); 
Здесь  tr(i, k)  –  процедура,  транспонирующая  элементы  key[i],  key[k]. 

Заметим, что число сравнений  

"key[i] < key[k]" 

 

при реализации такого алгоритма равно n (n – 1) / 2. В частности, это оз-
начает, что время работы этого алгоритма равно O(n2). 

Сортировка  методом  «разделяй  и  властвуй».  Предположим,  что  в 
нашем распоряжении имеется процедура РАЗДЕЛЯЙ (i, j, k), которая по 
заданным значениям индексов i, j находит некоторое промежуточное зна-
чение  k  и  переставляет  элементы  сегмента  key[i..j]  так,  чтобы  для  s = i,      
i + 1, ..., k – 1  выполнялось  неравенство  key[s] ≤ key[k],  а  для  s = k + 1, 

 

229

 

 

k + 2,  ..., j − неравенство key[k] ≤ key[s]. 

Тогда для сортировки сегмента key[i .. j] может быть использована ре-

курсивная процедура СОРТИРУЙ. 
procedure СОРТИРУЙ (i, j); 
begin if i = j then exit 
 
 
end; 
Для сортировки всего исходного массива достаточно выполнить опе-

else {РАЗДЕЛЯЙ (i, j, k); СОРТИРУЙ (i, k – 1);  

СОРТИРУЙ (k + 1, j)} 

 

ратор СОРТИРУЙ (1, n). 

Заметим,  что  если  бы  процедура  РАЗДЕЛЯЙ  работала  линейное  от 
длины сегмента время и давала значение k, близкое к середине между i и 
j, то число обращений к ней приблизительно равнялось бы log n и сорти-
ровка  всего  массива  проходила  бы  за  время  порядка  O(n⋅log n).  Однако 
можно доказать, что при естественной реализации эта оценка справедлива 
лишь в среднем. 
Упражнения 

 1.  Разработайте  вариант  процедуры СОРТИРУЙ без использования ре-
курсии.  Сколько  дополнительной  памяти  требуется для запоминания 
границ еще не отсортированных сегментов? 

2.  Охарактеризуйте работу процедуры СОРТИРУЙ на заранее отсорти-

 

рованном массиве. 

3.  Напишите  на известном вам алгоритмическом языке программу сор-
тировки числового массива с помощью процедуры СОРТИРУЙ и ис-
пытайте ее на массивах, сгенерированных с помощью датчика случай-
ных чисел. Составьте таблицу, отражающую время работы вашей про-
граммы на массивах разной длины. Каков максимальный размер мас-
сива, который можно отсортировать составленной программой на ва-
шем компьютере? 
Сортировка  «слиянием».  Этот  метод  является  разновидностью  ме-
тода  «разделяй  и  властвуй»,  впрочем,  уместнее  его  было  бы  назвать 
«властвуй и объединяй». 

Предположим, что у нас есть процедура СЛИВАЙ (i, j, k), которая два 
уже отсортированных сегмента key[i..(j – 1)] и key[j..k] преобразует (сли-
вает) в один сегмент key[i..k], делая его полностью отсортированным. То-
гда рекурсивная процедура 

 

 

 230

 

 

procedure СОРТИРУЙ (i, j); 
begin if i = j then exit 
 
 
end; 

else {m:= (i + j) div 2; СОРТИРУЙ (i, m);  

СОРТИРУЙ (m + 1, j); СЛИВАЙ (i, m, j)}; 

очевидно, сортирует сегмент key[i .. j], а для сортировки всего исходного 
массива  достаточно  выполнить  оператор  СОРТИРУЙ  (1, n).  Как  видим, 
вопрос  балансировки  размера  сегментов  решается  здесь  просто.  Число 
обращений к процедуре СЛИВАЙ (i, m, j) равно log n, а время ее выпол-
нения  легко  сделать  линейным  от  суммарной  длины  сливаемых  сегмен-
тов. 

 

 

 

Упражнения 

1.  Разработайте процедуру СЛИВАЙ и вариант процедуры СОРТИРУЙ 
без использования рекурсии. Сколько дополнительной памяти требу-
ется для ее реализации? 

2.  Оцените теоретически время работы алгоритма по методу слияния. 
3.  Напишите  на известном вам алгоритмическом языке программу сор-
тировки числового массива методом слияния и испытайте её на мас-
сивах,  сгенерированных  с  помощью  датчика  случайных  чисел.  Со-
ставьте  таблицу,  отражающую  время  работы  вашей  программы  на 
массивах  разной  длины.  Каков  максимальный  размер  массива,  кото-
рый  можно  отсортировать  составленной  программой  на  вашем  ком-
пьютере? 
Сортировка с помощью d-кучи. Для представления сортируемой по-
следовательности используем структуру d-кучи. Сортировку можно про-
вести в два этапа. 
1.  Окучить  сортируемый  массив,  применяя  последовательно  операцию 
ПОГРУЖЕНИЕ по очереди к узлам (n − 1), (n − 2), … , 0 в предполо-
жении,  что  сначала  все n ключей занимают в произвольном порядке 
массив key[0 .. n – 1].  

2.  Осуществить  окончательную  сортировку  следующим  образом.  Пер-
вый  (минимальный)  элемент  кучи  меняем  местами  с  последним, 
уменьшаем  размер  кучи  на  1  (минимальный  элемент  остается  в  по-
следней позиции массива key, не являясь уже элементом кучи) и при-
меняем  операцию  ПОГРУЖЕНИЕ  к  корню,  затем  повторяем  анало-
гичные действия, пока размер кучи не станет равным 1. 
Эти два этапа реализуются с помощью процедуры SORT, которая сор-

 

231

 

 

тирует массив по убыванию ключей. 

procedure SORT(n); 
begin 
for i := n – 1 downto 0 do ПОГРУЖЕНИЕ (i); 
while n > 1 do {tr (1, n); n:= n – 1; ПОГРУЖЕНИЕ (1)} 
end; 
Заметим,  что  процедура  SORT  не  требует  дополнительной  памяти, 

размер которой зависел бы от длины массива key. 

Упражнения 
Докажите, что оператор 
for i := n – 1 downto 0 do ПОГРУЖЕНИЕ (i); 

 в процедуре SORT можно заменить на оператор 

 

 

 

 

 

 

 

 232

 

for i:= n div 2 downto 1 do ПОГРУЖЕНИЕ (i). 
Напишите на известном вам алгоритмическом языке программу сор-
тировки числового массива с помощью процедуры SORT(n) и испытайте 
её  на  массивах,  сгенерированных  с  помощью  датчика  случайных  чисел. 
Составьте таблицу, отражающую время работы вашей программы на мас-
сивах разной длины. Каков максимальный размер массива, который мож-
но отсортировать составленной программой на вашем компьютере? 

3.4. Нахождения кратчайших путей в графе 

Входные данные: 
•  Граф G с взвешенными ребрами (под весами можно понимать дли-
ны ребер, если речь идет о геометрическом графе, или любые дру-
гие числовые характеристики ребер). 

•  Стартовая  вершина  s  (вершина  от  которой  вычисляются  расстоя-

ния до всех остальных вершин). 
Выходные данные: 
•  Массив dist[1.. n], (dist[i] – кратчайшее расстояние от вершины s 

до вершины i). 

ти из s в i). 

•  Массив up[1..n], (up[i] – предпоследняя вершина в кратчайшем пу-

Замечание. Приводимый ниже алгоритм Дейкстры корректно решает 
задачу для графов с неотрицательными весами вершин. Если же в графе 
есть  ребра  с  отрицательными  весами,  но  нет  циклов  с  отрицательным 
суммарным весом, то для решения задачи можно использовать алгоритм 

 

 

Форда, Беллмана. 

Алгоритм Дейкстры 

1.  Заполнить массив up [1..n] нулями. 
2.  Каждой вершине i приписать в качестве ключа dist [i] – максимально 
возможное число (оно должно быть больше чем длина наибольшего из 
кратчайших  путей  в  графе;  в  процессе  вычислений  это  число  будет 
уменьшаться и в итоге заменится на длину кратчайшего пути из вер-
шины s в вершину i). 

3.  Организовать приоритетную очередь из вершин графа, взяв в качестве 

ключей величины dist [i], i= 1, 2, …, n. 

4.  Заменить ключ вершины s на 0. 
5.  Пока очередь не пуста выполнять операции 6 – 7. 
6.  Выбрать  (с  удалением)  из  приоритетной  очереди  элемент  r0  с  мини-

мальным ключом; 

7.  Для каждой вершины r смежной с r0 выполнить операции 8, 9. 
8.  Вычислить величину delta = dist[r] – (dist[r0] + L(r0, r)); 
9.  Если  delta  >  0,  то  уменьшить  ключ  dist [r]  элемента  r  на  величину 

delta и заменить старое значение величины up [r] на r0; 

 

233

 

 

Глава 4. ОБЪЕДИНЯЕМЫЕ ПРИОРИТЕТНЫЕ ОЧЕРЕДИ 

4.1. Левосторонние кучи 

 
 
 

 

 

Левосторонняя куча [3], [10] − это представление приоритетной оче-
реди с помощью так называемого левостороннего бинарного дерева. При 
реализации  приоритетных  очередей  левосторонними  кучами  предусмат-
ривается возможность их объединения.  

Бинарным  деревом  называется  корневое  дерево,  у  которого  каждый 
узел имеет не более двух непосредственных потомков. Один из потомков 
называется левым, другой, если он есть − правым. Узел называем непол-
ным, если он имеет менее двух непосредственных потомков. В частности, 
листья дерева являются неполными узлами.  

Рангом узла называем увеличенное на 1 расстояние (число ребер) от 

него до ближайшего неполного потомка. 

о

Ранг  узла  можно  определить  также  следующим  образом.  Расширить 
данное  дерево  до  полного  бинарного  дерева,  добавляя  к  каждому  узлу, 
имеющему менее двух потомков, в том числе и к листьям исходного де-
рева,  недостающее  количество  потомков.  Затем  приписать  каждому  из 
листьев полученного расширенного дерева ранг 0, а ранг каждого из ос-
тальных узл в определить как минимум  з рангов ег непосредственных 
потомков плюс 1. Очевидно, ранги вершин исходного дерева совпадут с 
рангами соответствующих вершин расширенного дерева. 

Левостороннее дерево – это бинарное дерево, для каждого узла кото-
рого  ранг  его  левого  непосредственного  потомка  в  расширенном  дереве 
не меньше ранга его правого потомка. 

Ветвью бинарного дерева называем последовательность его узлов, на-
чинающуюся  с  корня,  заканчивающуюся  листом,  и  такую,  что  каждый 
следующий узел является непосредственным потомком предыдущего. 

Правой ветвью дерева называем ветвь такую, что каждый следующий 

о 

и

узел является непосредственным правым потомком предыдущего. 

Пример левостороннего дерева (и его расширения) приведен на рис. 1. 
Ребра  исходного  дерева  изображены  жирными  линиями,  а  ребра,  добав-
ленные при расширении – пунктиром. Числа рядом с узлами – их ранги. 
 
 
 

3

 234

2

1

0

0

2

1 1

0

1

00

1

0

0

0

1 

0
0

0

 

 

Рис. 1 

Свойства левостороннего дерева 
1. Правая ветвь из любого узла дерева в лист имеет минимальную дли-

 

ну среди всех таких ветвей. 

2. Длина правой ветви левостороннего дерева, имеющего n узлов, ог-

раничена величиной c ⎣log2n⎦, c = const. 

Первое  свойство  непосредственно  следует  из  определения  левосто-
роннего  дерева.  Для  доказательства  второго  свойства  рассмотрим  лево-
стороннее дерево T, у которого длина правой ветви равна h. Индукцией 
по числу h докажем, что число n узлов в таком дереве удовлетворяет не-
равенству  n ≥ 2h – 1.  Действительно,  при  h = 1  утверждение  очевидно. 
При h > 1  левое  и  правое  поддеревья  дерева T  будут левосторонними, а 
ранги их корней больше или равны h – 1. Следовательно, по предположе-
нию индукции число узлов в каждом из них больше или равно 2h – 1 – 1, а 
в дереве T − больше или равно 

(2h – 1 – 1) + (2h – 1 – 1) + 1 = 2h – 1. 

Для реализации приоритетной очереди с помощью левосторонней ку-

чи будем использовать узлы вида 

 
 
 
 
 
 
 
 

 

 

 

 

 

 

Node = (element, key, rank, left, right, parent), 

содержащие следующую информацию: 

•  element  –  элемент  приоритетной  очереди  или  ссылка  на  него  (ис-

пользуется прикладной программой), 

•  key – его ключ (вес), 
•  rank – ранг  узла, которому приписан рассматриваемый элемент, 
•  left, right  – указатели на левое и правое поддеревья, 
•  parent  – указатель на родителя. 
Куча  представляется  указателем  на  ее  корень.  Если h  −  указатель  на 

 

235

 

 

корень кучи, то через h будем обозначать и саму кучу. 

Заметим,  что  указатель  на  родителя  используется  лишь  в  операциях 

УДАЛИТЬ и УМЕНЬШИТЬ_КЛЮЧ (см. ниже). 

 

Операция  СЛИЯНИЕ.  Эта  операция  позволяет  слить  две  левосто-
ронние кучи h1 и h2 в одну кучу h. Реализуется она посредством слияния 
правых путей двух исходных куч в один правый путь, упорядоченный по 
правилам кучи, а левые поддеревья узлов сливаемых правых путей оста-
ются  левыми  поддеревьями  соответствующих  узлов  в  результирующем 
пути. В полученной куче необходимо восстановить свойство левизны ка-
ждого узла. Это свойство может быть нарушено только у узлов правого 
пути полученной кучи, так как левые поддеревья с корнями в узлах пра-
вых путей исходных куч не изменились. Восстанавливается свойство ле-
визны при помощи прохода правого пути снизу вверх (от листа к корню) 
с попутным транспонированием в случае необходимости левых и правых 
поддеревьев и вычислением новых рангов проходимых узлов. 

Рассмотрим процесс слияния двух левосторонних куч h1 и h2, изобра-

женных на рис. 2. 
 
 
 
 
 
 
 
 
 

10 

23

1

2

 

1

21

 

14

 

2

3 

3

6

1

8

2

12

2

7 

 

1

17

1

18

1

24

1

37

1

18

 

1

26

 

1

33

Рис. 2 

Числа внутри кружочков являются ключами элементов, приписанных 
к соответствующим узлам. Правые ветви куч показаны жирными линия-
ми. Числа рядом с узлами – их ранги. 

После  объединения  правых  путей  получим  дерево,  изображенное  на 
рис. 3. Оно не является левосторонним. В скобках указаны ранги узлов, 
какими они были в исходных кучах до слияния. 

Восстановление  свойства  левизны  кучи  начинаем  с  последнего  узла 
правой ветви. Это узел с ключом 18. Очевидно, он должен иметь ранг 1, 
совпадающий с его старым значением и поэтому не требующий обновле-
ния. 
 

(2)

3

 236

2

10 

(3)

6

1

21 

1

 14

2

12

(2)

7

1

23 

1

18

1

24

1

37

(1)

1

33

1

17

1

26

8

1

18

 

 

Рис. 3 

 
 
 
 
 
 
 
 
 
 
 
 

 

 

 

(2)

3

Следующий по направлению к корню узел правой ветви имеет ключ 8, 
ранг его левого сына не меньше ранга правого сына, следовательно, усло-
вие левизны выполняется и поэтому транспонирования его левого и пра-
вого поддеревьев не требуется. Однако, ранг этого узла необходимо обно-
вить, так как его старое значение 1 не совпадает с увеличенным на 1 ми-
нимальным из рангов его потомков, то есть с числом 2. Обновив ранг, по-
лучим кучу, изображенную на рис. 4. 
 
 
 
 
 
 
 
 
 
 
 
 
 

21 

23 

10 

(2)

1

 14

1

26

1

18

1

37

1

24

1

17

8

1

2

12

1

33

(3)

6

2

1

7

2

1

18

Рис. 4 

Теперь рассмотрим узел с ключом 7. Он имеет левого сына с ключом 
37 и рангом 1, и правого сына с ключом 8 и рангом 2. Для восстановления 
свойства левизны в этом узле необходимо поменять местами его левое и 
правое поддеревья и обновить ранг. Его новым значением будет минимум 

 

237

 

 

2

3

(2)

10 

из рангов его потомков (это ранг нового правого сына) плюс 1, то есть 2. 
В результате получаем дерево, изображенное на рис. 5: 
 
 
 
 
 
 
 
 
 
 
 
 
 

21 

23 

 14

(3)

33

12

18

24

37

17

18

6

7

8

1

2

1

1

1

1

2

1

1

1

1

2

1

26
Рис. 5 

 

3

(2)

Далее рассматриваем узел с ключом 6. Оба его сына имеют одинако-
вый  ранг  2,  следовательно,  менять  их  местами  не  требуется.  Вычислим 
лишь новое значение ранга: оно равно минимальному из рангов его детей 
(рангу правого сына) плюс 1, то есть 3. Получаем дерево, изображенное 
на рис. 6. 
 
 
 
 
 
 
 
 
 
 
 
 

1 23 

21 

10 

18

26

33

14

12

24

37

17

18

6

7

8

1

2

1

1

2

1

1

1

1

1

1

2

2

3

 

 

 238

 

 

Рис. 6 

Наконец,  рассматриваем  узел  с  ключом  3,  который  является  послед-
ним в правой ветви, полученной слиянием правых ветвей исходных куч. 
Его потомков (узлы с ключами 10 и 6) необходимо поменять местами для 

 

 

3

3

восстановления свойства левизны и обновить ранг, который будет теперь 
равен 3. После выполнения этих операций получим левостороннюю кучу, 
изображенную  на  рис.  7.  На  этом  выполнение  операции  СЛИЯНИЕ  за-
канчивается. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

12 

18 

33 

24

2

8

1

18

1

17

1

14

1

26

1

23

1

21

3

6

2

1

10

1

1

2

37

7

Рис. 7 

 

 

Очевидно, время выполнения операции СЛИЯНИЕ пропорционально 
сумме длин правых путей сливаемых куч. По свойству левосторонней ку-
чи оно не превосходит величины log n1 + log n2 < log n + log n, где n1, n2 – 
количества узлов в исходных кучах, а n = n1 + n2 – количество узлов в ре-
зультирующей куче. Следовательно, вычислительная сложность операции 
СЛИЯНИЕ равна O(log n). 

 

Реализация операции СЛИЯНИЕ 
procedure СЛИЯНИЕ(h1, h2, h); 
begin 
  if h1 = nil then {h := h2; exit};  
  if h2 = nil then {h := h1; exit}; 
  if h1^.key > h2^.key then {h3 := h1; h1 := h2; h2 := h3;} 
  h := h1; СЛИЯНИЕ(h1^. right, h2, h3); h^. right := h3; 
  if h^.left^.rank < h^.right^.rank then  
  {h3:= h^.left; h^.left := h^.right; h^.right := h3}; 
  h^.rank := min(h^.right^.rank, h^.left^.rank) + 1; 
end; 
Операция ВСТАВКА. Эта операция позволяет осуществить вставку в 
кучу h нового элемента x с ключом k. Она производится посредством об-

 

239

 

 

разования  левосторонней  кучи,  содержащей  единственный  элемент  х  с 
ключом  k,  и  слияния  ее  с  кучей  h.  Вычислительную  сложность  данной 
операции можно оценить так же, как вычислительную сложность опера-
ции СЛИЯНИЕ, то есть величиной O (log n). 

 

Реализация операции ВСТАВКА 
procedure ВСТАВКА(x, k, h); 
begin 
  CREATE node h1: [element, key, rank, left, right, parent] = [x, k, 1, 
  nil, nil, nil]; 
  СЛИЯНИЕ(h, h1, h2);  h := h2 
end; 
Операция УДАЛЕНИЕ_МИНИМУМА. Эта операция позволяет из 
кучи h удалить элемент хMin с минимальным ключом. Она производится 
посредством удаления корня кучи h (трудоемкость O (1)), а затем слияния 
его левой и правой подкуч (трудоемкость O (log n)). Таким образом, вы-
числительная сложность данной операции является величиной O (log n). 

 

Реализация операции УДАЛЕНИЕ_МИНИНИМУМА 
procedure УДАЛЕНИЕ_МИНИМУМА (h, xMin); 
begin  
  xMin := h^.element; СЛИЯНИЕ (h^.left, h^.right, h3);  h := h3 
end; 
Операция МИНИМУМ. Эта операция позволяет взять из кучи h эле-
мент с минимальным ключом, не удаляя его из кучи. Поскольку элемент с 
минимальным ключом находится в корне кучи, то требуется лишь скопи-
ровать его в нужное место. Вычислительная сложность данной операции 
O (1). 

 

 

Реализация операции МИНИМУМ 
function МИНИМУМ (h); 
begin 
  МИНИМУМ := h^.element; 
end; 
Операция  УДАЛЕНИЕ.  Эта  операция  позволяет  удалить  из  кучи  h 
элемент х, расположенный в узле, заданном позицией pos. Удаление мо-
жет быть проведено в несколько этапов. 

1.  Если  узел  х  является  корнем  кучи  h,  то  применяется  операция 

 

 

 

 

 240

 

 

УДАЛЕНИЕ_МИНИМУМА  из  кучи  h.  Иначе  выполняются  следующие 
действия. 

2. От исходной кучи h отрывается подкуча h2 с корнем в удаляемом 
узле х. Оставшаяся куча, для которой сохраняем обозначение h, не обяза-
тельно является левосторонней. 

3. Затем узел х удаляется из кучи h2, а его левая и правая подкучи сли-
 (log n), как доказано вы-

 (время выполнения – O

ваются в одну кучу 
ше). 

2h′

4. Куча 

2h′  делается таким же сыном узла р (р – родитель узла х), ка-

ким являлся для нее узел х (левым или правым). 

5. Наконец, в куче h восстанавливается свойство левизны. Фактически 
свойству  левизны  могут  не  удовлетворять  только  узлы,  находящиеся  на 
пути от р к корню кучи h. Длина этого пути в худшем случае может ли-
нейно зависеть от n. Но на самом деле нам нужно проверить только пер-
вые  не  более,  чем  ⎣log (n + 1)⎦  узлов  на  этом  пути  (потому  что  макси-
мальный по длине правый путь имеет максимум ⎣log (n + 1)⎦ узлов).  
Таким образом, время выполнения данной операции – O (log n). 

Рассмотрим  пример  применения  данной  операции.  Пусть  из  кучи  h, 

4

2

3

h:

3
p: 

изображенной на рис. 8, необходимо удалить элемент х с ключом 9. 
 
 
 
 
 
 
 
 
 
 
 
 
 

1 31 

2
x: 

18 

2

11

2

8

1

11

1

6

1

10

1

15

18

1

17

1

12

1

1

9 

5

1

1

21
Рис. 8 

 

 

Сначала отрывается подкуча h2 с корнем х. От h остаются куча h1 (не 
левосторонняя, так как свойству левизны не удовлетворяет узел р) и лево-
сторонняя куча h2, см. рис. 9. 

 

241

 

 

3
h1:

2

3
p:

4

h2: 
2
x: 

9 

1

18 

1

10

1

5

2

8

2

11

1

12

1

17

1

6

1

18

1 31 

1

15

1

11

1

21

Рис. 9 

Затем удаляется узел х, а его левая и правая подкучи h2L и h2R слива-
 при помощи применения вышеописанной операции 

 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

2h′

ются в одну кучу 
СЛИЯНИЕ, см. рис. 10. 
 
h2L
 
 
1 18 
 
 
 
 

1 31 

2h′

(3) 

на. Куча 
левым сыном, см. рис. 11. 
 
 
 
 
 
 
 
 
 

18 

p: 

1

10 

1

31

4

1

 242

Поскольку узел х не являлся корнем кучи h, операция еще не заверше-
 становится левым поддеревом узла р, так как узел х был его 

h2R:

1

10

Рис. 10 

h′2 : 
1 10

1

18

1

31

(3)
h:

2

2

11

1

12

1

17

1

18

1

6

11

1

15

1

5

2

8

1
21

1

Следуем от узла р к корню дерева, для каждого узла этого пути вос-

Рис. 11

 

 

3

2

h:

станавливаем свойство левизны и ранг. Сначала проверяем узел р: его де-
тей надо поменять местами, так как ранг узла с ключом 10 (он равен 1) 
меньше ранга узла с ключом 5 (он равен 2). После этого обновляется ранг 
узла р: он равен рангу правого сына плюс 1, то есть 2. Получилось дерево, 
изображенное на рис. 12. 
 
 
 
 
 
 
 
 
 
 
 
 
 

1 31 

18 

11 

21 

11

12

17

18

31

5 

4

1

1

6

2

1

1

1

2

2

1

1

1

1

1

1

1

 

 

Рис. 12 

3

2

h:

Следующий узел на пути к корню – это родитель узла р с ключом рав-
ным  2.  Ранги  его  сыновей  равны,  значит  менять  их  местами  не  нужно. 
Однако его собственный ранг требует обновления, новое значение равно 
рангу его правого сына плюс 1, т.е. старому: 3. В результате получается 
дерево, изображенное на рис. 13. 
 
 
 
 
 
 
 
 
 
 
 
 
Поскольку  узел  с  ключом  2  является  корнем  дерева,  операция 
УДАЛЕНИЕ завершена. 

Рис. 13

2 4

18 

21 

11 

31 

18

31

11

17

12

5 

6

1

1

1

1

1

1

1

1

1

1

1

1

1

2

2

 

 

243

 

 

 

 

Реализация операции УДАЛЕНИЕ 
procedure УДАЛЕНИЕ (h, pos); 
begin  
  if pos = h then {УДАЛЕНИЕ_МИНИМУМА (h, xMin); exit}; 
  p := pos^.parent; h2 := pos; УДАЛЕНИЕ_МИНИМУМА (h2, xMin); 
  if p^.left = pos then p^.left := h2 else p^.right := h2; 
  while p ≠ nil do 
  begin 
  if p^.left ≠ nil then r1:= p^.left^.rank else r1:= 0; 
  if p^.right ≠ nil then r2:= p^.right^.rank else r2:= 0; 
  newrank := min (r1, r2) + 1; 
  if r1 < r2 then tr (p^.left, p^.right); 
  if newrank ≠ p^.parent^.rank then p^.parent^.rank:= newrank  
  else exit; 
  p:= p^.parent; 
  end 
end 
Операция УМЕНЬШИТЬ_КЛЮЧ. Ключ узла x, находящегося в де-
реве в позиции pos, уменьшается на положительное число ∆. Это дейст-
вие  может  нарушить  кучеобразный  порядок  лишь  таким  образом,  что 
уменьшенный ключ узла х будет меньше ключа его родителя. Уменьше-
ние ключа может быть проведено в несколько этапов: 

1. От исходной кучи h отрывается подкуча h2 с корнем в узле х. Ос-

тавшаяся куча h не обязательно будет левосторонней. 

2. Затем ключ узла х уменьшается на заданное число ∆. Куча h2 при 

этом все еще остается левосторонней. 

3. В куче h следующим образом восстанавливается свойство левизны. 
Фактически свойству левизны могут не удовлетворять только узлы, нахо-
дящиеся на пути от р (р – родитель узла х) до корня h. Длина этого пути в 
худшем случае линейно зависит от n. Но на самом деле нам нужно прове-
рить только первые не более чем ⎣log (n + 1)⎦, узлов на этом пути. 

Наконец, куча h сливается с h2 за время O (log n). 
Таким образом, время выполнения данной операции – O (log n). 
Рассмотрим  пример  применения  рассматриваемой  операции.  Пусть      
в куче, изображенной на рис. 14, необходимо уменьшить ключ узла х от    
9 до 0. 

 244

 

 

3

h:

2

p: 

3 4

2

11

x:

2

9 

1

18 

1

10

1

1

31 

1

15

2

8

5

1

12

1

17

1 6

1

11

1

18

1

21

Рис. 14 

h:

(3) 2

Делается  это  следующим  образом.  От  исходной  кучи  h  отрывается 
подкуча h2 с корнем в удаляемом узле х. Теперь куча h не является лево-
сторонней, так как в узле р нарушено свойство левизны, см. рис. 15. 
 
 
 
 
 
 
 
 
 
 
 
 

2
x: 
18 

1 10

h2: 

2

8

2

11

1

6

1

17

1

18

1

15

31 

1

11

1

12

1

21

(3)

4

p: 

9 

1

1

5

1

Рис. 15 

Ключ узла х уменьшается до 0, куча h2 при этом все еще остается ле-

 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

восторонней см. рис. 16. 
 
 
 
 

1

31

2

0

x:
18

1

1

10

Следуем от узла р до корня дерева h, для каждого узла этого пути вос-
станавливаем свойство левизны и ранг. Сначала проверяем узел р: его де-
тей надо поменять местами (а фактически – только одного-единственного 

Рис. 16

 

245

 

 

1

2

(3

h:

правого сына сделать левым). После этого вычисляется новый ранг узла 
р: он равен рангу правого сына плюс 1, то есть 1 (так как правого сына 
нет). Получилось дерево, изображенное на рис. 17 
 
 
 
 
 
 
 
 
 
 
 
 

1 11 

15 

21 

p: 

11

12

17

18

5 

8 

4

6

2

1

1

2

1

1

1

1

1

Рис. 17 

 

 

3

2

h:

Следующий узел – это родитель узла р с ключом 2. Его потомков тоже 
необходимо  поменять  местами  (так  как  ранг  левого  сына  меньше  ранга 
правого). После этого ранг узла с ключом 2 вычисляется как ранг правого 
сына плюс 1, то есть 2. Получается следующая куча: 
 
 
 
 
 
 
 
 
 
 
 
 

1 11

81

41

12

21

15

11

17

18

5

6

2

1

2

1

1

1

1

1

Рис. 18 

Наконец,  сливаем  кучи h  и h2,  получая  в  результате  левостороннюю 

кучу, (см. рис. 19). 
 
 
 

 246

2 0

h:

3

2

1 18

2

11 

42

1

31

1

12 

1

10

52

1 10

1

18

81

1

10

1

15

1

11

1 21

 

 

Рис. 19 

Реализация операции УМЕНЬШИТЬ_КЛЮЧ 
procedure УМЕНЬШИТЬ_КЛЮЧ (h, pos, delta); 
begin 
  pos^.key := pos^.key – delta; if pos = h then  exit; 
  p := pos^.parent; h2 := pos; 
  if p^.left = pos then p^.left := nil else  
  if p^.right = pos then p^.right := nil; 
  while p ≠ nil do 
  begin 
 
 
  newrank := min ( r1, r2 ) + 1; 
 
 
 
  p := p^.parent 
  end; 
  СЛИЯНИЕ (h, h2, h); 
end; 

if p^.left  ≠ nil then r1 := p^.left^.rank else r1 := 0; 
if p^.right  ≠ nil then r2 := p^.right^.rank else r2 := 0; 

if r1 < r2 then tr ( p^.left, p^.right ); 
if newrank ≠ p^.parent^.rank then p^.parent^.rank := newrank  
 

else exit; 

247

 
 
 
 
 
 
 
 
 
 

 

 

 

 

 

Операция ОБРАЗОВАТЬ_ОЧЕРЕДЬ. Из элементов списка S (| S | = 
= n) образуется левосторонняя куча h. Способ формирования такой кучи 
посредством n применений операции ВСТАВИТЬ не эффективен. Читате-
лю предоставляется возможность доказать, что в худшем случае форми-
рование кучи таким способом может потребовать c⋅n⋅log n операций, где 
c = const. 

Более  эффективным  является  следующий  способ  образования  n-эле-
ментной левосторонней кучи. Заводится список Q, в который помещают-
ся n одноэлементных куч. Пока длина списка Q больше 1, из его начала 
извлекаются  две  кучи,  производится  их  слияние,  а  полученная  куча 
вставляется в конец списка Q. 

Читателю предоставляется возможность доказать, что время выполне-

ния операции ОБРАЗОВАТЬ_ОЧЕРЕДЬ таким способом O (n). 

Реализация операции ОБРАЗОВАТЬ_ОЧЕРЕДЬ 
procedure ОБРАЗОВАТЬ_ОЧЕРЕДЬ (S, h); 
begin 
  Создать список Q из одноэлементных куч, содержащих элементы 
  списка S; 
  while |Q|>1 do 
  begin 
    Из начала списка Q изъять две кучи h1, h2; 
    Создать кучу h, объединяя кучи h1, h2; 
    Поместить кучу h в конец списка Q 
  end 
end; 

Сводные данные о трудоемкости операций с левосторонними кучами 

 

 

 

 

 

 

 

 248

1. СЛИТЬ (h1, h2, h) 
2. ВСТАВИТЬ (x, h) 
3. УДАЛИТЬ_МИН (h, x) 
4. МИН (x, h) 
5. УДАЛИТЬ (x, h) 
6. УМЕНЬШИТЬ_КЛЮЧ (x, ∆, h) 
7. ОБРАЗОВАТЬ_ОЧЕРЕДЬ (q, h) 

O (log n) 
O (log n) 
O (log n) 
O (1) 
O (log n) 
O (log n) 
O (n) 

4.2. Биномиальные и фибоначчиевы кучи 

 

 

Биномиальные кучи. Для каждого k = 0,1,2,… биномиальное дерево 
Bk  определяется  следующим  образом:  B0  –  дерево,  состоящее  из  одного 
узла высоты 0; далее при k = 1,2,… дерево Bk высоты k формируется из 
двух деревьев Bk−1, при этом корень одного из них становится потомком 
корня другого. На рис. 20 изображены биномиальные деревья B0, B1, B2, 
B3, B4. 

Биномиальный лес это набор биномиальных деревьев, в котором лю-

бые два дерева имеют разные высоты. 

B0    B1           B2                    B3

B4

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Рис. 20
 

Свойства биномиальных деревьев 
1.  Дерево  Bk  состоит  из  корня  с  присоединенными  к  нему  корнями 

поддеревьев Bk−1, ... , B1, B0 в указанном порядке. 

2.  Дерево Bk имеет высоту k. 
3.  Дерево Bk имеет ровно 2k узлов. 
4.  В дереве Bk на глубине i имеется ровно C k
5.  В дереве Bk корень имеет степень k, остальные узлы имеют мень-

i узлов. 

6.  Для каждого натурального числа n существует биномиальный лес, 

в котором количество узлов равно n.  

7.  Максимальная степень вершины в биномиальном лесе с n узлами 

шую степень. 

равна log2 n. 

8.  Биномиальный лес содержит не более ⎣log2 n⎦ биномиальных под-

 

249

 

 

 

 

[key, parent, child, sibling, degree], 

деревьев. 

Чтобы  убедиться  в  существовании  биномиального  леса  из  n  узлов, 
представим n в двоичной системе счисления (разложим по степеням двой-
ки) n = a0*20 + a1*21 + ...+as*2s, где ak ∈ {0,1}. Для каждого k = 1, 2, …, 
s, такого, что ak = 1, в искомый лес включаем дерево Bk. 

Биномиальная  куча  это  набор  биномиальных  деревьев,  узлам  кото-
рых приписаны элементы взвешенного множества в соответствии с куче-
образным  порядком,  при  котором  вес  элемента  приписанного  узлу  не 
превосходит весов элементов приписанных его потомкам. 

Поскольку количество детей у узлов варьируется в широких пределах, 
ссылка на детей осуществляется через левого ребенка, а остальные дети 
образуют односвязный список. Каждый узел в биномиальной куче пред-
ставляется набором полей 

где key – ключ (вес) элемента, приписанного узлу, parent – родитель узла, 
child – левый ребенок узла, sibling – правый брат узла, degree – степень 
узла. 

Доступ  к  куче  осуществляется  ссылкой  на  самое  левое  поддерево. 
Корни  деревьев,  из  которых  составлена  куча,  оказываются  организован-
ными с помощью поля sibling в, так называемый, корневой односвязный 
список. 

Поиск элемента с минимальным ключом.  Поскольку  искомый  эле-
мент находится в корне одного из деревьев кучи, то элемент с минималь-
ным ключом находится просмотром корневого списка за время О (log n). 

Слияние двух очередей.  Две  очереди  H1  и  H2  объединяются  в  одну 
очередь H следующим образом. Последовательно выбираются деревья из 
исходных очередей в порядке возрастания их высот и вставляются в ре-
зультирующую очередь H, вначале пустую.  

Если дерево Bi очередной высоты i присутствует лишь в одной из ис-
ходных  очередей,  то  перемещаем  его  в  результирующую  очередь.  Если 
оно присутствует в одной из исходных очередей и уже есть в результи-
рующей очереди, то объединяем эти деревья в одно Bi+1, которое вставля-
ем в H. Если Bi присутствует во всех трех очередях, то сливаем две из них 
в Bi+1, которую вставляем в H, а третье дерево Bi просто перемещаем в H. 
Трудоемкость – O (log n). 

Вставка нового элемента.  Создается  одноэлементная  очередь  из 
вставляемого элемента, которая объединяется с исходной очередью. Тру-

 250

 

 

доемкость – O (log n). 

Удаление минимального элемента. Сначала в исходной куче H про-
изводится  поиск  дерева  Bk,  имеющего  корень  с  минимальным  ключом. 
Найденное  дерево  удаляется  из  H,  его  прикорневые  поддеревья  Bk−1, 
... , B1, B0  включаются  в  новую  очередь  H1,  которая  объединяется  с  ис-
ходной очередью H. Трудоемкость – O (log n). 

Уменьшение ключа. Осуществляется с помощью всплытия. Трудоем-

кость – O (log n). 

Удаление элемента. Уменьшается ключ удаляемого элемента до −∞, 
применяется всплытие, всплывший элемент удаляется как минимальный. 
Трудоемкость – O (log n). 

Фибоначчиевы кучи. Название рассматриваемых куч связано с ис-
пользованием  чисел  Фибоначчи  при  анализе  трудоемкости  выполнения 
операций. В отличие от биномиальных куч, в которых операции вставка, 
поиск элемента с минимальным ключом, удаление, уменьшение ключа и 
слияние выполняются за время O (log n), в фибоначчиевых кучах, выпол-
няются более эффективно. Операции, не требующие удаления элементов, 
в этих кучах имеют учётную стоимость O (1). Теоретически фибоначчие-
вы кучи особенно полезны, если число операций удаления мало по срав-
нению  с  остальными  операциями.  Такая  ситуация  возникает  во  многих 
приложениях. 

Например, алгоритм, обрабатывающий граф, может вызывать проце-
дуру уменьшение ключа для каждого ребра графа. Для плотных графов, 
имеющих много рёбер, переход от O (log n) к O (1) в оценке времени ра-
боты  этой  операции  может  привести  к  заметному  уменьшению  общего 
времени  работы.  Наиболее  быстрые  известные  алгоритмы  для  задач  по-
строения  минимального остовного дерева или поиска кратчайших путей 
из одной вершины используют фибоначчиевы кучи. 

К сожалению, скрытые константы в асимптотических оценках трудо-
емкости  велики  и  использование  фибоначчиевых  куч  редко  оказывается 
целесообразным: обычные двоичные (d-ичные) кучи на практике эффек-
тивнее.  С  практической  точки  зрения  желательно  придумать  структуру 
данных с теми же асимптотическими оценками, но с меньшими констан-
тами. Такие кучи будут рассмотрены в следующих разделах. 

При  отсутствии  операций  уменьшения  ключа  и  удаления  элемента, 
фибоначчиевы кучи имели бы ту же структуру, что и биномиальные. Но в 
общем случае фибоначчиевы деревья обладают большей гибкостью, чем 
биномиальные. Из них можно удалять некоторые узлы, откладывая пере-

 

251

 

 

стройку дерева до удобного случая.  

Строение фибоначчиевой кучи. Каждая фибоначчиева куча состоит 
из нескольких деревьев. В отличие от биномиальных деревьев здесь дети 
любого  узла  могут  записываться  в  любом  порядке.  Они  связываются  в 
двусторонний  циклический  список.  Каждый  узел  y  этого  списка  имеет 
поля  left [y]  и  right [y],  указывающие  на  ее  соседей  в  списке.  На  рис.  21 
показано схематическое строение фибоначчиевой кучи. 
 
 
 
 
 
 
 
 
 
 

8 

3 

2 

6 

7 

6 

4 

3 

7 

5 

9 

8 

7 

Рис. 21 

Двусторонние  циклические  списки  удобны  по  двум  причинам.  Во-
первых, из такого списка можно удалить любой узел за время O (1). Во-
вторых, два таких списка можно соединить в один за время O (1). 

Помимо  указанной  информации,  каждый  узел  имеет  поле  degree [x], 
где хранится его степень (число детей), а также поле mark [x]. В этом поле 
хранится  булевское  значение.  Смысл  его  таков:  mark [x]  истинно,  если 
узел x потерял ребенка после того, как он в последний раз сделался чьим-
либо потомком. Позже будет ясно, как и когда это поле используется. 

Корни деревьев, составляющих фибоначчиеву кучу, так же связаны с 
помощью указателей left и right в двусторонний циклический список, на-
зываемый корневым списком. Таким образом, каждый узел  фибоначчие-
вой кучи представляется записью вида 
 

Node = [key, left, right, parent, child, degree, mark]. 

Доступ к куче H производится ссылкой minH на узел с минималь-
ным ключом. Кроме того, общее число узлов задается атрибутом n [H]. 
Потенциал.  При  анализе  учётной  стоимости  операций  используют 
метод потенциала. Пусть t (H)– число деревьев в корневом списке кучи H, 
а m (H) – количество помеченных узлов. Потенциал определяется форму-
лой 

 

 

 

 252

 

 

φ (H) = t (H) + 2 m (H). 

В  каждый  момент  времени  в  памяти  может хранится несколько куч; 
общий  потенциал  по  определению  равен  сумме  потенциалов  всех  этих 
куч. В дальнейшем мы выберем единицу измерения потенциала так, что-
бы единичного изменения потенциала хватало для оплаты O(1) операций 
(формально говоря, мы умножим потенциал на подходящую константу). 
В  начальном  состоянии  нет  ни  одной  кучи,  и  потенциал  равен  0.  Как  и 
положено, потенциал всегда неотрицателен. 

Максимальная степень. Через D(n) обозначим верхнюю границу для 
степеней узлов в кучах, которые могут появиться при выполнении опера-
ций.  Аргументом  функции  D  является  общее  число  всех  узлов  в  куче, 
обозначаемое через n. 

Мы  не  будем  углубляться  в  анализ  трудоемкости  операций  с  фибо-
наччиевыми  кучами,  отсылая  читателя  к  соответствующей  литературе, 
скажем только, что D(n) = O(lоg n) и все операции кроме операции удале-
ния  элемента  имеют  амортизационную  трудоемкости  O(1),  а  операция 
удаления O(lоg n). 

Замечания. Фибоначчиевы кучи ввели Фредман и Тарьян. В их статье 
описаны также приложения фибоначчиевых куч к задачам о кратчайших 
путях из одной вершины, о кратчайших путях для всех пар вершин, о па-
росочетаниях с весами и о минимальном покрывающем дереве. 

Впоследствии  Дрисколл,  Сарнак,  Слеатор  и  Тарьян  разработали 
структуру  данных,  называемую  relaxed  heaps,  как  замену  для  фибонач-
чиевых  куч.  Есть  две  разновидности  такой  структуры  данных.  Одна  из 
них  даёт  те  же  оценки  учётной  стоимости,  что  и  фибоначчиевы  кучи. 
Другая  –  позволяет  выполнять  операцию  DecreaseKey  за  время  O(1)  в 
худшем случае, а операции ExtractMin и Delete – за время O(lоg n) в худ-
шем случае. Эта структура данных имеет также некоторые преимущества 
по  сравнению  с  фибоначчиевыми  кучами  при  использовании  в  парал-
лельных алгоритмах. 
 

4.3. Тонкие кучи 

 

 

Рассматриваемые здесь тонкие и в следующем разделе толстые кучи 
предложены  Фридманом  и  Капланом  как  альтернатива  фибоначиевым 
кучам. Долгое время фибоначиевые кучи считались рекордными по про-
изводительности.  Оценки  операций  над  фибоначиевыми  кучами  имеют 
амортизационный характер, а скрытые в них константы велики настолько, 
что реальный выигрыш во времени работы с ними достигался только на 

 

253

 

 

данных «астрономических» размеров. Рассматриваемые здесь тонкие ку-
чи имеют те же асимптотические оценки, что и фибоначчиевы но гораздо 
практичнее их. Оценки для толстых куч “хуже” по операции слияния вы-
полняемой  за  O(log n)  времени.  Достоинством  этой  структуры  является 
то, что её оценки рассчитаны на худший случай. Заметим, что на данный 
момент  ни  фибоначиевы,  ни  толстые,  ни  тонкие  кучи  не  являются  ре-
кордными,  так  как  Бродал  предложил  новую  структуру,  которую  будем 
называть кучей Бродала. Кучи Бродала характеризуется такими же, как и 
фибоначеевы  кучи  оценками  операций,  но  все  оценки  справедливы  для 
худшего случая. К сожалению, структура, предложенная Бродалом, слож-
на  для  реализации.  Рассмотрим  реализацию  приоритетной  очереди,  с 
помощью тонкой кучи. 

Основные  определения.  Тонкие  кучи,  как  и  многие  другие  кучеоб-

разные структуры, аналогичны биномиальным кучам. 

Тонкое дерево Tk ранга k – это дерево, которое может быть получено 
из биномиального дерева Bk, удалением у нескольких внутренних, то есть 
не являющихся корнем или листом, узлов самого левого сына. Заметим, 
что у листьев детей нет, а если у корня Bk удалить самого левого сына, то 
Bk превратится в Bk–1. Ранг тонкого дерева равен количеству детей корня. 
Для любого узла x в дереве Tk обозначим: Degree (x) ─ количество де-
тей у узла x; Rank (x) ─ ранг соответствующего узла в биномиальном де-
реве Bk. 

Тонкое дерево Тk удовлетворяет следующим условиям: 

1.  Для любого узла х либо Degree (x) = Rank (x), в этом случае говорим, 
что узел х не помечен (полный); либо Degree (x) = Rank (x) − 1, в этом 
случае говорим, что узел х помечен (неполный). 

2.  Корень не помечен (полный). 
3.  Для любого узла х ранги его детей от самого правого к самому левому 

равны соответственно 0, 1, 2, … , Degree(x) − 1. 

4.  Узел х помечен тогда и только когда его ранг на 2 больше чем ранг его 

самого левого сына, или его ранг равен 1, и он не имеет детей. 
На рис. 22 приведены примеры тонких деревьев; числа рядом с узлами 
обозначают их ранги. Вверху изображено биномиальное дерево B3. Внизу 
два  полученных  из  B3  тонких  дерева  ранга  три.  Стрелки  указывают  на 
помеченные узлы. 

Заметим, что биномиальное дерево является тонким деревом, у кото-

рого все узлы непомечены. 

Тонкий лес это набор тонких деревьев, ранги которых не обязательно 

 254

 

 

попарно различны. 

Нагруженный  лес  это  лес,  узлам  которого  взаимно  однозначно  по-

 

3
3 

2
2 

1
1 

1
1 

 

0
0

3: 
B

B3

ставлены в соответствие элементы взвешенного множества. 
 
 
 
 
 
 
 
 
 
 
 
 

1
1 
0
0 

Т3: 
T3

Т3: 
T3

2
2
 

0
0 

2
2 

1
1

 

0
0

 

0
0

 

0
0

 

0
0

 

1
1 

0
0 

3 

3

3
3 

0

0 

0
0 

Рис. 22 

 

Тонкая куча это кучеобразно нагруженный тонкий лес. 
Заметим, что в тонкой куче могут встречаться тонкие деревья одина-
кового  ранга,  в  то  время  как  в  биномиальной  куче  все  деревья  должны 
иметь попарно различные ранги. 

Утверждение. Для любого натурального числа n существует тонкий 
лес, который содержит ровно n элементов и состоит из тонких деревьев 
попарно различных рангов. 

Действительно, любой биномиальный лес, является тонким, а для би-

номиального леса рассматриваемое утверждение справедливо. 

Пусть D(n) − максимально возможный ранг узла в тонкой куче содер-

жащей n элементов. 

= (1+√5)/2 – золотое сечение. 

Теорема.  В  тонкой  куче  из  n  элементов  D(n)  ≤  logΦ (n),  где  Φ =           

Доказательство. Сначала покажем, что узел ранга k в тонком дереве 
имеет не менее Fk ≥ Фk–1 потомков, включая самого себя, где Fk – k-е чис-
ло  Фибоначчи,  определяемое  соотношениями  F0 = 1,  F1 = 1,  Fk = Fk–2+ 
Fk+1 для k ≥ 2. 

Действительно, пусть Tk – минимально возможное число узлов, вклю-
чая самого себя, в тонком дереве ранга k. По свойствам 1 и 3 тонкого де-
рева получаем, следующие соотношения: 
k
−

2

 

T0 = 1, T1 = 1, 

T
k

1
+≥

 для k ≥ 2. 

T
i

∑

i

=

0

 

255

 

 

Числа Фибоначчи удовлетворяют этому же рекуррентному соотноше-
нию, причем неравенство можно заменить равенством. Отсюда по индук-
ции  следует,  что  Tk ≥ Fk  для  любых  k.  Неравенство  Fk ≥ Фk–1  хорошо  из-
вестно. 

Теперь убедимся в том, что максимально возможный ранг D(n) тонко-
го дерева в тонкой куче, содержащей n элементов, не превосходит числа 
log
. Действительно, выберем в тонкой куче дерево максимального 
  ≥  ФD(n)–1.  
ранга. Пусть n

* количество вершин в этом дереве, тогда n  ≥  n*

φ n
1)(
+

Отсюда следует, что D(n) ≤  
На рис. 23 изображено биномиальное дерево B3. Внизу два получен-
ных  из  B3  тонких  дерева  ранга  три.  Стрелки  указывают  на  помеченные 
узлы. 
 

φ n
1)(
+

log

. 

 

B3: 

B3

2
2 

0
0 

1
1 
0 

0

1 
1 

0 
0 

3 

0
0 

Т3: 

T3

2 
2 

0 
0 

0 
0 

3
3 

1 
1 

0 
0 

Т3: 

2
2 

0
0 

T3

3
3 

1
1 

0
0 

1
1 

0
0 

Рис. 23 

 

 

 

 

 
 
 
 
 
 
 
 
 
 
 
 

 256

Представление тонкой кучи в памяти компьютера. Тонкие кучи 

формируют из узлов, представленных записями следующего вида: 

Node = (Key, Left, Right, LChild, Rank), 

Где Key − ключ элемента приписанного узлу; Left − указатель на ближай-
шего левого брата, если такового нет, то на родителя, а если нет и родите-
ля то указатель заземлен; Right − указатель на ближайшего правого брата, 
если  такового  нет,  то  указатель  заземлен;  LChild  −  указатель  на  самого 
левого сына, если такового нет, то указатель заземлен; Rank − ранг узла. 

Таким образом, узлы-братья связаны в двусвязный список при помо-
щи указателей Left и Right. У самого левого брата в этом списке, указа-

 

 

тель  Left  указывает  на  общего  родителя  всех  узлов  в  списке.  У  самого 
правого брата из списка, указатель Right заземлен. Корни деревьев в тон-
кой куче связаны в односвязный циклический список. Этот список будем 
называть  корневым  списком.  Корневой  список  реализуется  при  помощи 
поля Right. Поле Left у каждого узла корневого списка заземлено. 

В  случае  необходимости  в  описании  узла  может  присутствовать  и 
другая прикладная информация. На рис. 24 приведен пример тонкой кучи 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Тонкая куча: 

Представление со ссылками, в узлах указаны ранги 

First 

Mi

0 

1

2

0

1

0

0

Рис. 24 

 
Заметим, что принадлежность заданного узла корневому списку кучи, 

осуществляется проверкой указателя Left на заземленность. 

Введем еще одну запись Heap, которая будет соответствовать отдель-

ной куче и иметь вид: 
 

Heap = (First, Min), 

 

где First − указатель на начальный элемент корневого списка; Min − ука-
затель на элемент корневого списка с минимальным ключом. 

Очевидно, узел с минимальным ключом обязательно находится в кор-

невом списке. 

Реализация основных операций и оценки трудоемкости. Сосредо-
точим  внимание  на  амортизационных  оценках  трудоемкости.  Будем  по-
лучать их методом потенциалов. Потенциалом тонкой кучи будем считать 
величину Ф = n + 2⋅m, где n – количество деревьев в куче, а m – число по-
меченных  вершин.  Заметим,  что  потенциал  кучи  неотрицателен  и  в  на-

 

257

 

 

чальный момент равен 0. 

Операция  MakeHeap.Эта  операция  создает  указатель  MakeHeap  на 
новую  пустую  кучу.  Очевидно,  фактическая  стоимость  операции  есть 
О (1), а потенциал созданной кучи равен 0. 

Операция  FindMin(H).  Указатель  FindMin  на  узел  с  минимальным 
ключом в куче H определяется с помощью указателя Min. Если куча пус-
та, то результирующий указатель нулевой. Амортизационная оценка, сов-
падает с фактической и равна О (1), потенциал не изменяется. 

Операция  Insert(i, H).  С  помощью  этой  операции  осуществляется 
вставка в кучу H нового элемента с ключом i. При ее реализации создает-
ся  новое  тонкое  дерево  ранга  0,  которое  вставляется  в  корневой  список 
кучи H, разрывая его в произвольном месте. При необходимости перевы-
числяется ссылка на минимальный элемент. 

Операция увеличивает потенциал на 1, так как добавляется одно дере-
во в корневой список кучи, но это не влияет на амортизационную оценку, 
которая равна фактической О (1). 

Операция Meld(H1, H2). Результатом этой операции является указа-
тель Meld на кучу, полученную слиянием двух куч H1 и H2. Она осуще-
ствляется соединением корневых списков сливаемых куч. При таком спо-
собе выполнения операции, как и при реализации вставки элемента в ку-
чу, можем получить в корневом списке результирующей кучи несколько 
деревьев одинакового ранга. При удобном случае, а именно при удалении 
минимального элемента, мы освободим корневой список от этой неодно-
значности. Оценка совпадает с оценками для всех предыдущих операций. 
Суммарный потенциал не изменяется.  

Операция  DeleteMin(H).  Эта  операция  предназначена  для  удаления 
узла с минимальным ключом из непустой кучи H. Для ее реализации уда-
ляем  минимальный  узел  из  корневого  списка  кучи H,  добавляем  список 
детей удаленного узла в корневой список и повторяем следующий "свя-
зывающий шаг". 

Находим любые два дерева, корни которых имеют одинаковые ранги, 
и связываем их, делая корень с большим ключом новым левым потомком 
корня с меньшим ключом, увеличивая ранг нового полученного тонкого 
дерева на единицу. При этом следует удалить из корневого списка кучи H 
корень с большим ключом. Как только не останется деревьев с корнями 
одинакового  ранга,  в  полученном  корневом  списке,  необходимо  найти 
элемент с минимальным ключом.  

Рассмотрим теперь, с помощью каких средств реализуется связываю-

 258

 

 

щий шаг. Для хранения ссылок на корни деревьев используем временный 
массив RankT, размера D(n). Величина RankT [i] будет указателем на тон-
кое дерево ранга i. Если найдётся еще одно дерево ранга i, то свяжем два 
дерева ранга i в одно дерево ранга i + 1, в i ячейке массива RankT устано-
вим  нулевой  указатель  и  продолжим  связывающую  процедуру  с  вновь 
полученным деревом ранга i + 1. 

При  включении  списка детей необходимо учесть возможность поме-
ченности детей минимального узла. То есть уменьшить их ранг там, где 
это необходимо. Это требование вытекает из свойства 2 определения тон-
кого  дерева.  Очевидно,  для  проверки  помеченности  узла требуется О(1) 
операций.  

В результате выполнения связывающих шагов получаем заполненный 
массив RankT. Теперь остаётся только связать все деревья, находящиеся в 
этом массиве, в корневой список и найти в этом списке новый минималь-
ный  элемент.  Очевидно,  все  это  можно  выполнить  с  трудоёмкостью 
О(D(n)). 

Чтобы оценить амортизационную стоимость операции DeleteMin под-
считаем фактическую стоимость операции и изменение потенциала. Фак-
тическая стоимость складывается из О(1) операций на проверку кучи на 
пустоту,  О(D(n))  действий  при  добавлении  детей  минимального  узла  в 
корневой  список  и  О(Количества  связывающих  шагов)  +  О(D(n))  при 
выполнении связывающих шагов. 

В итоге фактическая стоимость операции удаления минимального эле-

мента есть О(Количество связывающих шагов + D(n)). 

Очевидно, потенциал уменьшился, как минимум на число связываю-
щих шагов, так как при каждом связывающем шаге количество деревьев в 
корневом  списке  уменьшается  на  единицу.  Поскольку  амортизационная 
стоимость равна фактической стоимости плюс изменение потенциала, то 
амортизационная стоимость равна равна О(D(n). 

Операция DecriseKey (∆, i, H). При уменьшении ключа у некорневого 
элемента i в куче H на величину ∆ может быть нарушено свойство куче-
образности. Для восстановления этого свойства перемещаем поддерево с 
корнем в изменяемом элементе в корневой список, но при этом, возмож-
но, оставшееся после переноса дерево может не оказаться тонким.  

Покажем как, затратив О (1) амортизированного времени, исправлять 
его структуру. В процедуре DecriseKey после уменьшения ключа коррек-
тируется, если это необходимо, указатель на минимальный элемент кучи. 
После этого проверяется, не является ли измененный узел x корнем дере-

 

259

 

 

ва Т. Если это действительно так, то процедура завершается, в противном 
случае переносим поддерево с корнем в узле x в корневой список кучи и 
запускаем процедуру коррекции оставшегося дерева T′. 

Будем различать два вида нарушений свойств тонкого дерева: 
1.  Братские нарушения это нарушения третьего правила из определе-

2.  Родительские нарушения это нарушения первого или второго пра-

ния тонкого дерева. 

вила. 

Рассмотрим подробнее каждое из двух видов нарушений. 
Назовем узел y узлом локализации братского нарушения среди детей 
узла z, если ранг узла y отличается от ранга его ближайшего правого брата 
на  2,  либо  он  не  имеет  правого  брата  и  его  ранг  равен  1.  Пример  на        
рис. 24. 

 
 
 
 
 
 
 
 

B4

Узел y

2

1

0

3

2

1 

0

0 

0 

1 

0 

0

Рис. 24 

Узел z 

4 

0 

Назовем  узел  y  узлом  локализации  родительского  нарушения,  если 

выполнено одно из трех условий: 

1.  Ранг узла y на три больше чем ранг его самого левого сына. 
2.  Ранг узла y равен двум и он не имеет детей. 
3.  Узел y есть помеченный корень дерева. 
Пример на рис. 25. 

Узел y 

3 

2 

1 

0 

0 

B4:

2

4 

1

0

1

0

0

0

Рассмотрим теперь, как можно перестроить дерево, чтобы избавиться 

Рис. 25 

 

 
 
 
 
 
 
 
 

 

 260

 

 

от  братского  нарушения  либо  свести  его  к  родительскому.  Пусть  узел  y 
это  узел  локализации  братского  нарушения.  Рассмотрим  два  возможных 
варианта. 

Узел  y  непомечен,  то  есть  ранг  его  самого  левого  сына  на  единицу 

меньше ранга самого узла y. Пример на рис. 26. 
 
 
 
 
 
 
 
 

1 

1 

0 

0 

0 

0

1

0

3

2

Рис. 26 

B4:

4 

0 

Узел y

2

0

В данном случае, чтобы исправить братское нарушение, помещаем на 
место пропущенного в братском списке поддерева, поддерево с корнем в 
самом левом сыне узла y. Узел y при такой операции становится помечен-
ным, но зато дерево теперь удовлетворяет всем трём свойствам определе-
ния  тонкого  дерева.  Очевидно,  что  это  операция  заканчивает  процедуру 
исправления дерева. 

Узел y помечен, тогда уменьшаем ранг узла y на единицу. Это не ис-
правит дерево, но зато теперь узлом локализации нарушения будет левый 
братузла  y,  либо  его  родитель.  В  последней  ситуации  нарушение  стано-
вится родительским. Пример на рис. 27. 
 
 
 
 
 
 
 
 
 

Узел y 

B4:

0 

1 

1 

0 

4 

0 

0 

0

2

0

3

2

Рис. 27 

 

 

Таким образом, мы либо исправим структуру дерева, либо рекурсивно 

придем к узлу локализации родительского нарушения. 

Выясним, что же делать с родительскими нарушениями. Пусть узел y 
это узел локализации родительского нарушения, а узел z это родитель уз-

 

261

 

 

ла y. Тогда предлагается переместить поддерево с корнем в узле y в кор-
невой список кучи, делая при этом узел у непомеченным. Считаем, что z – 
это не корень дерева. Если узел z не был помечен, то, очевидно, процеду-
ра  исправления  дерева  закончена.  Если  он  был  помечен,  то  считаем  его 
узлом локализации нового родительского нарушения. При этом, очевид-
но,  количество  помеченных  узлов  уменьшится  на  единицу.  Продолжая 
такого  вида  рекурсивные  шаги,  мы  либо  дойдём  до  корня  дерева,  либо 
исправим его структуру раньше. Если узел z стал корнем, то для того что-
бы исправить структуру дерева необходимо лишь сделать ранг корня на 
единицу большим ранга его самого левого сына. На этом процедура ис-
правления дерева будет закончена. 

Заметим, что каждый промежуточный шаг рекурсии уменьшает число 
помеченных узлов на единицу. И добавляет в корневой список не более 
одного дерева. Тогда потенциал при каждом шаге рекурсии уменьшается 
как минимум на единицу. Отсюда и следует обещанная оценка О(1) вре-
мени выполнения операции DecriseKey. 

Операция Delete(i, H) удаляет элемент i из кучи H следующим обра-
зом.  Уменьшается  ключ  удаляемого  элемента  i  до  некоторого  значения 
меньшего  минимального,  и  элемент  удаляется  как  минимальный.  Оче-
видно, трудоемкость этой операции есть О(D(n)). 

амортизационная 

операций 
DeleteMin  и  Delete на тонкой куче из n элементов равна O(log n), а для 
остальных операций как видели ранее – О(1). 

трудоемкость 

выполнения 

Итак, 

 

 

4.3. Толстые кучи 

Рассматриваемое в этом разделе представление приоритетной очереди 
основано  на  использовании  так  называемых  избыточных  счетчиков,  по-
зволяющих за время О(1) инкрементировать любой разряд. Заметим, что 
использованные  здесь  счетчики лишь один из способов реализации тол-
стых  куч.  На  самом  деле,  для  их  реализации  подойдёт  произвольный d-
арный счетчик, при условии, что трудоемкость инкрементирования любо-
го его разряда является константной. 

Избыточное  представление  чисел.  Основные  определения.  Избы-
точным b-арным представлением неотрицательного целого числа х счита-
ем последовательность d = dn, dn−1, …, d0, такую, что 

x

=

i

ibd

,

 

n

∑

i

=

0

 

где di ∈{0, 1, .., b}, i  {0, 1, …, n}. Будем называть d

∈

i цифрой стоящей в 

 262

 

 

i-м разряде. В примерах запятые между цифрами опускаем. 

Заметим,  что  избыточное  представление  отличается  от  обычного  b-
арного представления использованием «лишней» цифры b, что приводит 
к  неоднозначности  представления  чисел.  Например,  при  b = 3,  число  3, 
может быть представлено как 3 и как 10.  

В примерах, в которых b = 10, цифру “10” будем обозначать символом 

b. 

Назовем b-арное избыточное представление числа регулярным, если в 
нем между любыми двумя цифрами, равными b, найдется цифра, отлич-
ная от b – 1. 

Пример. Пусть b = 10, а число x, представляется в обычной десятич-
ной системе последовательностью 1100, тогда, представления b9b и bb0 
не являются регулярными b-арными избыточными представлениями чис-
ла x, а представления 1100 и 10b0 регулярны. 

Пусть L(i) − номер разряда отличного от b − 1 и ближайшего слева от 

i-го разряда в регулярном b-арном избыточном представлении d. 

Определим  L′(i)  следующим  образом:  L′(i)  =  L(i),  если  di  ∈{b  −  1,       

b −2} и d(L(i)) = b; L′(i) – произвольное число > i, если di ∈{b − 1, b − 2} 
и d(L(i)) < b − 1; L′(i) – не определено, если di ∉{b − 1, b − 2}. 

Величину L′(i) будем называть прямым указателем. 
Пусть  d = dn, …, d0  −  b-арное  регулярное  представление  некоторого 

числа. 

Фиксацией  цифры  b,  стоящей  в  i-ом  разряде  представления  d 
(Fix (i)) назовем операцию, заключающуюся в обнулении цифры di и ин-
крементировании цифры di+1, при этом если i = n, то полагаем dn+1= 1. При 
каждом выполнении операции фиксации будем обновлять значение L′(i). 
Очевидно, при b > 2 операцию Fix (i) можно выполнить с помощью сле-
дующих операторов. 
 

if di = b then {di:= 0; di+1:= di+1+1}; if di+1 = b-1 then L′(i):= L′(i+1) else 

L′(i):= i+1 

 

Инкрементирование  i-ой  цифры  избыточного  представления  d 

(Inc (i)) можно выполнить с помощью операторов  

 

Fix (i); if (di = b -1) or (di = b -2) then Fix (L′(i)); di:= di + 1; Fix (i) 
Очевидно,  инкрементирование  i-го  разряда  регулярного  b-арного  из-

быточного  представления  числа  х,  производит  представление  числа  х′  =     

 

263

 

 

Нетрудно  доказать,  что  операции  фиксации  и  инкрементирования, 
примененные  к  регулярному  избыточному  представлению,  не нарушают 
регулярности и корректно вычисляют указатели L с трудоемкостью O(1). 
Эта  схема  может  быть  расширена  для  выполнения  за  константное 
время  декрементирования  произвольной  цифры  добавлением  дополни-
тельного цифрового значения b+1. Оставляем детали в качестве упражне-
ния. 

Представление толстой кучи. Основные определения. Определяем 

толстое дерево Fk ранга k (k = 0, 1, 2,…) следующим образом: 

•  Толстое дерево F0 ранга ноль, состоит из единственного узла. 
•  Толстое дерево Fk ранга k, для k ≥ 1, состоит из трех деревьев Fk−1, 
ранга k − 1, связанных так, что корни двух из них являются самы-
ми левыми потомками корня третьего. 

Ранг узла x, в толстом дереве, определяется как ранг толстого подде-

рева с корнем в узле x. 

На рис. 28 приведены примеры толстых деревьев  

= х + bi. 

 
 
 
 
 
 
 
 
 
 
 
 

 

 264

 

F0

0

F1

1

0

0

F2

2

1

1

0

0

0

00

0

2

1

0
000

0

1

1

0

0 0 0

0

F3

2

3

1

1

0 0

0 0

000

0

Рис. 28 

Свойства толстых деревьев. 
1.  В толстом дереве ранга k ровно 3k узлов. 
2.  Для любого натурального числа n существует лес из толстых де-
ревьев,  в  котором  ровно  n  узлов.  Такой  лес  можно  построить, 
включив в него столько деревьев ранга i, каково значение i-го раз-
ряда представления числа n в троичной системе счисления. Заме-
тим, что для построения такого леса можно использовать и избы-
точные троичные представления. 

 

 

3.  Толстый лес из n узлов содержит О(log n) деревьев. 
Доказательства этих свойств оставляются читателю в качестве упраж-

нения. 

Рассмотрим  лес  из  нескольких  толстых  деревьев,  ранги  которых  не 
обязательно попарно различны и узлам которых взаимно однозначно по-
ставлены в соответствие элементы взвешенного множества. Такой лес бу-
дем  называть  нагруженным.  Узел  в  нагруженном  лесе  назовем  непра-
вильным,  если  его  ключ  меньше  ключа  его  родителя.  Нагруженный  лес 
назовем почти кучеобразным, если для каждого значения k в нем имеется 
не более двух неправильных узлов ранга k. 

Толстая куча − это почти кучеобразный, нагруженный лес.  
Представление  толстой  кучи.  Каждый  узел  толстой  кучи  будем 

представлять записью следующего вида: 
 

FatNode = (Key, Parent, Left, Right, LChild, Rank),  

 
где Key − ключ элемента приписанного узлу дерева; Parent − указатель на 
родителя; Left − указатель на ближайшего левого брата; Right − указатель 
на ближайшего правого брата; LChild − указатель на самого левого сына; 
Rank − ранг узла. Таким образом, “Братья” связаны в двусвязный список 
при  помощи  указателей  Left  и  Right.  У  самого  левого  (правого)  брата  в 
этом списке, указатель Left (Right) заземлен. 

На рис. 29 представлено толстое дерева F2 (внутри узлов указаны их 

ранги). 
 
 
 
 
 
 
 
 
 
 
 

F2

2

0

0

1

0

1

0

0 

0

Рис. 29

Представление толстой кучи. Для представления толстой кучи вве-
дём новую структуру, которую назовём “Корневым счетчиком”, а для то-
го чтобы быстро находить неправильные узлы введем ещё один избыточ-
ный счётчик, который назовём “Счетчиком нарушений”. Таким образом, 
толстую кучу можно представить записью следующего вида 

 

265

 

 

 

 

FatHeap = (RootCount, CountViolation, MinPointer, MaxRank), 

Где RootCount – массив соответствующий “Корневому счетчику”; Count-
Violation – массив соответствующий “Счетчику нарушений”; MinPointer 
–  указатель  на  элемент  кучи  имеющий  минимальный  ключ;  MaxRank  – 
наибольший ранг среди рангов деревьев присутствующих в куче 

Корневой счетчик. Корневой счетчик состоит из избыточного троич-
ного представления числа элементов в куче и набора списочных элемен-
тов. 

Значение  i-го  разряда  избыточного  корневого  представления  равно 
количеству деревьев ранга i присутствующих в куче. При таком опреде-
лении  избыточного  корневого  представления,  число,  которое  оно  пред-
ставляет равно числу узлов, в куче, так как толстое дерево ранга i содер-
жит ровно 3i узлов. Заметим, что состояние избыточного корневого пред-
ставления определяется не однозначно. Отсюда следует, что толстая куча 
с  одним  и  тем  же  набором  элементов  может  быть  представлена  различ-
ными наборами толстых деревьев. Очевидно, для любой толстой кучи со-
стоящей из n элементов, существует регулярное избыточное представле-
ние корневого счетчика. 

Списочный элемент, приписанный i-ому разряду избыточного корне-
вого представления, это указатель на список деревьев ранга i, присутст-
вующих в куче образованный посредством указателей Right корневых уз-
лов связываемых деревьев. 

Определение корневого счетчика позволяет сделать несколько утвер-

ждений. 

1.  Корневой счетчик позволяет иметь доступ к корню любого дерева 

ранга i за время O(1). 

2.  Вставка  толстого  дерева  ранга 

i,  соответствует  операции 

инкрементирования i-го разряда корневого счетчика. 

3.  Удаление толстого дерева ранга i, соответствует операции декре-

ментирования i-го разряда корневого счетчика. 

4.  Операции  инкрементирования  и  декрементирования  i-го  разряда 
корневого счетчика осуществляются за константное от числа эле-
ментов в куче время. 

Представление корневого счетчика. Корневой счетчик представляем 
расширяющимся  массивом  RootCount,  каждый  элемент  которого  это  за-
пись с тремя полями: 
 

(Value, ForwardPointer, ListPointer), 

 266

 

 

i; 

 
которые интерпретируем следующим образом: 

•  RootCount[i].Value – i-й разряд, равный количеству деревьев ранга 

•  RootCount [i].ForwardPointer – прямой указатель i-го разряда; 
•  RootCount  [i].ListPointer  –  указатель  на  список  деревьев  ранга  i, 
присутствующих в толстой куче. Деревья в этом списке связаны при 
помощи указателя Right корневых узлов связываемых деревьев. Ес-
ли  в  куче  нет  деревьев  ранга  i,  то  указатель  ListPointer  заземлен. 
Заметим, что если значение RootCount [i].Value равно нулю, то нам 
не важно, каково значение указателя RootCount [i].ListPointer. 

Инициализация  корневого  счетчика  (InitRootCount).  Поскольку 
корневой счётчик реализован, как массив записей, то возникает вопрос о 
величине данного массива и о том, что делать, когда весь этот массив за-
полнен. Чтобы была возможность оценить время инициализации счетчи-
ков величиной O(1) используем поразрядную их инициализацию. То есть 
будем добавлять новые разряды только тогда, когда возникает такая не-
обходимость. И при этом инициализировать новый разряд сразу в обоих 
счётчиках. Для этого мы вводим переменную MaxRank, которая показы-
вает нам, какая часть массивов счётчиков используется в данный момент.  
При начальной инициализации необходимо установить счётчики в со-
стояние, которое соответствует пустой куче. Очевидно, что в пустой куче 
не  может  быть  никаких  нарушений.  Операция  инициализации  выглядит 
следующим образом.  

Обновление  прямого  указателя  i-го  разряда  корневого  счётчика 

(UpdateForwardPointer(i)) заключается в выполнении операторов  

 

 

 

 

 

If (RootCount[i+1].Value = 3-1) 

then RootCount[i].ForwardPointer:= RootCount[i+1].ForwardPointer 
else RootCount[i].ForwardPointer:= i+1; 

Корректировка  списочной  части  i-го  разряда  корневого  счётчика 
при вставке в кучу нового дерева ранга i (InsertTree(i, p)). Эта процеду-
ра вставляет новое дерево ранга i (на него указывает указатель p), в спи-
сочную част  i-го р зряда корневог  счётчика RootCount и заключается в 
выполнении операторов 

о

ь

а

 

 

p1 := RootCount[i].ListPointer; 
if (RootCount[i].Value ≠ 0) then p^.Right := p1 else p^.Right := nil; 
p^.Left:= nil; RootCount[i].ListPointer:= p; 

267

 

 

Корректировка  списочной  части  i-го  разряда  корневого  счётчика 
при  удалении  из  кучи  дерева  ранга  i  (DeleteTree(i;  p)).  Эта  процедура, 
удаляет дерево ранга i (на него указывает указатель p), из списочной час-
ти  i-го  разряда  корневого  счётчика  RootCount.  Считаем,  что  указанное 
дерево присутствует в куче. Процедура заключается в выполнении опера-
торов 
 

p1:= RootCount[i].ListPointer; 
If (p1 = p) then RootCount[i].ListPointer:= p^.Right; 
j:= 1; 
While (j ≤ RootCount[i].Value) and (p1^.Right ≠ p) do Begin j := j+1; p1 := 

p1^.Right End; 

 

p1^.Right := p^.Right; 
Связывание (Fastening(p1, p2, p3)) трех толстых деревьев ранга i, 
в одно толстое дерево ранга i +1. Эта функция принимает три указателя 
(p1, p2, p3) на три разных толстых дерева одного и того же ранга i, и воз-
вращает указатель на вновь сформированное дерево ранга i + 1. Проце-
дура заключается в выполнении операторов 

If  (p1^.key  ≤  p2^.Key)  and  (p1^.key  ≤  p3^.Key)  then  {MinP:=p1; 

p1:=p2; p2:=p3}; 

p1; p2:= p3}; 

p1; p2:= p2}; 

If (p2^.key ≤ p1^.Key) and (p2^.key ≤ p3^.Key) then {MinP:=p2; p1:= 

If (p3^.key ≤ p1^.Key) and (p3^.key ≤ p2^.Key) then {MinP:= p3; p1:= 

 

 

 

 

p1^.Right := p2; p1^.Left := nil; p1^.Parent := MinP; 
p2^.Right := MinP^.LChaild; p2^.Left := p1; p2^.Parent := MipP; 
if (PMin^.LChild ≠ NiL) then PMin^.LChild^.Left :=p2; 
MinP^.LChaild := p1; MinP^.Rank := MinP^.Rank +1; 
PMin^.Right := NiL; PMin^.Left :=NiL; Fastening:= MinP; 

Функция GetKey (p) по указателю p на элемент определяет значе-

ние его ключа и реализуется оператором  

If (p = nil) then Min :=  ∞  else Min := p ^.Key; GetKey := Min; 

Функция MinKeyNodeRoot(p), которая по указателю P на списочную 
часть разряда корневого счетчика возвращает указатель на корневой узел 
с минимальным ключом, реализуется операторами 

p1:= p; MinP:= p1; 

 268

 

 

While (p1 ≠ nil) do 
Begin If (p1^.Key < MinP^.Key) then MinP := p1; p1:= p1^.Right End 
MinKeyNodeRoot := MinP; 
Очевидно,  что  трудоемкость  всех  приведенных  выше  операций  оце-

 

нивается величиной O(1). 

Операция фиксации (FixRootCount(i)). Операция фиксации i-го раз-
ряда  корневого  счётчика  подразумевает,  что  его  значение  равно  трем,  а 
списочная  часть  содержит  указатель  на  список  деревьев  ранга  i,  состоя-
щий ровно из трёх деревьев. При проведении этой операции значение в i-
ом  разряде  должно  стать  равным  нулю,  а  значение  в  i  +  1-ом  разряде 
увеличиться  на  единицу.  То  есть  в  куче  не  должно  остаться  деревьев 
ранга i, а количество деревьев ранга i + 1 должно увеличится на единицу. 
Для  этого  следует  удалить  из  кучи  три  присутствующих  в  ней  дерева 
ранга  i,  связать  их  в  дерево  ранга  i  +  1  и  вставить  вновь  полученное 
дерево в кучу.  

Следует  учесть,  что  ранг  нового  дерева  может  стать  больше  чем 
MaxRank, что потребует инициализацию новый разряда. Для этого необ-
ходимо увеличить значение MaxRank на единицу и заполнить новое поле, 
а так же необходимо провести инициализацию нового разряда  
Операция фиксации осуществляется с помощью операторов 
if (MaxRank = i) 

 

then  {MaxRank:=  i+1;  RootCount[i+1]^.Value:=  0;  CountViola-

tion[i+1].Value:= 0} 

else { UpdateForwardPointer(i+1)}; 

 

RootCount[i].Value:= 0; 
p1:= RootCount[i].ListPointer; p2:= p1^.Right; p3:= p2^.Right; 
p:= Fastening(p1, p2, p3); RootCount[i]^.ListPointer:= nil; 
InsertTree(i+1, p); 
RootCount[i+1].Value:= RootCount [i+1].Value + 1 
Очевидно, если списочная часть корневого счётчика до операции со-
ответствовала избыточному корневому представлению, то и после опера-
ции  фиксации  это  соответствие  сохранится.  Сохраняется  так  же  и  регу-
лярность представления. Трудоёмкость данной операции O(1). 

Инкрементирование  i-го  разряда  корневого  счётчика  (IncRoot-
Count (i, p)). По сравнению с описанным алгоритмом инкрементирования 
i-го разряда избыточного представления здесь мы должны учесть работу 
со списочной частью и обновить прямые указатели. Процедура реализует-

 

269

 

 

ся операторами 

If (RootCount[i].Value = 1) or (RootCount[i].Value = 2) 
Then If (RootCount [ RootCount[i].ForwardPointer ].Value = 3)  
then FixRootCount(RootCount[i].ForwardPointer); 
If (RootCount[i].Value = 3) then FixRootCount(i); 
InsertTree(i, p); 
RootCount[i].Value:= RootCount[i].Value + 1; 
UpdateForwardPointer(I); 
If (RootCount[i].Value = 3) then FixRootCount(I) 

Очевидно, если корневой счётчик находится в корректном состоянии 
и i 
 MaxRank, то операция инкрементирования i-го разряда корневого 
≤
счётчика,  переводит  корневой  счётчик  в  новое  корректное  состояние. 
Трудоёмкость этой операции равна О(1). 

Процедура  удаления  дерева  из  кучи  подразумевает  наличие  в  куче 
этого  дерева.  Пусть  удаляемое  дерево  имеет  ранг  i.  Тогда  значение  i-го 
разряда  избыточного  корневого  представления  не  равно  нулю.  То  есть 
уменьшение этого значения на единицу не испортит регулярности пред-
ставления и не потребует обновления, каких-либо указателей. Необходи-
мо лишь соответствующим образом обработать списочную часть. Проце-
дура реализуется операторами 

 

DeleteTree(i, p); RootCount[i].Value:= RootCount[i].Value –1; 
Трудоёмкость операции О(1). 
Нахождения дерева с минимальным ключом в корне (MinKey) реа-

лизуется операторами 

MinP:= nil; 
For i:= 0 to MaxRank do  
Begin 
p1 := MinKeyNodeRoot (RootCount[i].ListPointer); 
If (GetKey(p1) < GetKey(MinP)) then MinP:= p1; 
End; 
MinKey:= MinP; 
Трудоёмкость данной операции так же О(1). 
Счётчик  нарушений.  К  сожалению,  здесь  не  удаётся  разделить 
структуру на избыточное представление и списочную часть, как в корне-
вом счётчике. По этому рассмотрим работу со счетчиком нарушений бо-
лее подробно. Счётчик нарушений состоит из расширенного избыточного 

 

 

 

 

 270

 

 

двоичного представления, и набора списочных элементов. 

Отличие заключается в том, что: 
1.  Нас теперь не интересует само число, а интересуют только значе-

ния разрядов. 

2.  Операция фиксации тесно связана с толстой кучей. 
Значение i-го разряда для счётчика нарушений интерпретируется как 
количество не правильных узлов ранга i, а его списочная часть это указа-
тели на не правильные узлы ранга i. 

Такое определение счётчика нарушений позволяет сделать несколько 

утверждений: 

 

 

•  наличие счетчика нарушений позволяет иметь доступ к любому не 

правильному узлу ранга i за время O(1); 

•  операции  инкрементирования  i-го  разряда  счётчика  нарушений 
(естественно, лишь в случае, когда новое значение ключа у изме-
няемого узла становиться меньше значения ключа его родителя); 

•  операции  инкрементирования  и  декрементирования  i-го  разряда 
корневого счётчика осуществляются за константное от числа эле-
ментов в куче время. 

Представление  счётчика  нарушений.  Счётчик  нарушений  это  рас-
ширяющийся  массив,  элементы  которого  являются  записями  из  четырех 
полей 

(Value, ForwardPointer, FirstViolation, SecondViolation), 

со  следующей  интерпретацией:  CountViolation  [i].Value  –  количество  не 
правильных  узлов  ранга  i  в  куче,  CountViolation  [i].ForwardPointer  – 
прямой  указатель  i-го  разряда,  CountViolation  [i].FirstViolation  и  Count-
Violation [i].SecondViolation – указатели на не правильные узлы ранга i. 

Заметим, что если значение CountViolation [i].Value равно единице, то 
важно лишь значение первого указателя FirstViolation, и не важно, значе-
ние второго SecondViolation. А если CountViolation [i].Value равно нулю, 
то не интересны оба указателя. 

Далее ограничимся рассмотрением только наиболее важных операций. 
Так как счётчик нарушений похож на описанный выше корневой счётчик. 
По этому акцентируем внимание лишь на различиях. Реализация всех не-
обходимых процедур оставляется читателю в качестве упражнения.  

Инициализация  счётчика  нарушений.  Для  инициализации  нового 
звена счётчика нарушений необходимо лишь занулить его значение в но-
вом  разряде.  Делается  это  только  тогда,  когда  мы  вводим  в  кучу  новое 

 

271

 

 

дерево  ранга  MaxRank  +  1.  Это  первый  момент  появления  в  куче  узла 
ранга MaxRank + 1. Для тех нарушений, которые могут возникнуть в уз-
лах ранга меньше либо равного MaxRank + 1, соответствующие разряды 
счётчика  нарушений  уже  инициализированы,  а  узлов  большего  ранга  в 
куче пока нет. 

Вспомогательные процедуры. 
1.  Процедура  обновления  прямого  указателя  i-го  разряда  “Счётчика 
нарушений”  аналогична  процедуре  UpdateForwardPointer(i)  для 
корневого  счётчика.  Необходимо  лишь  учесть,  что  счётчик  нару-
шений двоичный. 

2.  Процедура  корректировки  списочной  части  i-го  разряда  счётчика 
нарушений  при  появлении  в  куче  нового  i-рангового  нарушения, 
назовём  её  InsertViolation  (i;  pNode)  вставляет  новый  нарушен-
ный  узел,  обновляя,  в  зависимости  от  значения  CountViolation 
[i].Value либо первый (FirstViolation), либо второй (SecondViola-
tion) указатель. Причём, перед тем как вставлять в счётчик нару-
шений новое, необходимо проверить, не присутствует ли оно там. 
3.  Процедура взаимной замены поддеревьев кучи с корнями в узлах 
p1 и p2, назовём её InterChange (p1, p2) подразумевает, что ранги 
обмениваемых деревьев одинаковы. 

5. 

4.  Так  же  нам  необходима  функция  SearchBrather (p),  которая 
возвращает указатель на брата того же ранга, что и передаваемый 
ей узел. Она проверяет ранги своего правого и левого брата (если 
такие существуют) и возвращает указатель на брата того же ранга 
(такой существует обязательно).  
 Функция,  которая  связывает  три  толстых  дерева  ранга  i,  в  одно 
толстое дерево ранга i + 1, аналогична соответствующей функции 
для корневого счётчика. 

6.  Функция,  которая  возвращает  указатель  на  минимальный,  нару-
шенный узел ранга i, среди элементов i-го разряда счётчика нару-
шений. Если i-й разряд счётчика нарушений пуст, то возвращается 
nil. 

Как и в случае корневого счётчика, все операции выполняются за кон-

стантное время. 

Свойство регулярности. Определим свойство регулярности для счет-
чика  нарушении.  Назовем  состояние  счётчика  нарушений  регулярным, 
если между любыми двумя цифрами, равными двум, существует цифра, 
отличная  от  единицы.  Неправильный  узел  ранга  i,  в  дальнейшем  будем 

 272

 

 

называть i -ранговым нарушением. 

Операция фиксации. Фиксация, i-й цифры di = 2, соответствует либо 
преобразованию двух i-ранговых нарушений, в одно (i + 1)-ранговое на-
рушение, либо устранению обоих i-ранговых нарушений. Проводить эту 
операцию предлагается следующим образом. 

Упорядочиваем  два i-ранговых  нарушения так, чтобы они имели од-
ного родителя (очевидно, что в общем случае i-ранговые нарушения мо-
гут иметь разных родителей). Сделать это предлагается заменой поддере-
ва  с  корнем  в  нарушенном  узле,  чей  родитель  имеет  меньший  ключ,  на 
поддерево  с  корнем  в i-ранговом  брате  нарушаемого узла, чей родитель 
имеет  больший  ключ.  Легко  проверить,  что  такая  замена  не  приводит  к 
созданию  новых  нарушений.  Пусть  узел y  это  общий  родитель  двух  на-
рушаемых узлов после замены. Пусть узел y принадлежит дереву F. 

2. 

Разобьем дальнейшее рассмотрение на два случая. 
1.  Ранг y равен i + 1. Пусть F 

1 и F 

2 это толстые деревья ранга i, с 

1 и F 

у − это толстое де-

корнями в двух нарушаемых узлах. А дерево F 
рево ранга i, полученное из поддерева с корнем в узле y удалением 
поддеревьев F 
а) Если узел y не является корнем дерева F, то удаляем из дерева 
2) ранга i, образу-
F, поддерево F 
ем одно дерево ранга i + 1, чей корень z является узлом с наименьшим 
2. Вставляем в дерево F вновь 
ключом среди корней деревьев F, F 
полученное толстое дерево с корнем в узле z, вместо поддерева с кор-
нем в узле у. Если узел z оказывается нарушенным, инкрементируем 
di+1. Значение i-го разряда делаем нулевым. 

у. Из трёх толстых деревьев (F, F 

1, F 

1, F 

1, F 

1, F 

б) Если узел y корень дерева F, то удаляем дерево F из кучи, Из 
2) ранга i, образуем одно дерево ранга 
трёх толстых деревьев (F, F 
i,  чей  корень z  является  узлом  с  наименьшим  ключом  среди  ключей 
2. Вставляем вновь полученное толстое дере-
корней деревьев F, F 
во с корнем в узле z, в кучу. Значение i-го разряда делаем нулевым. 
2.  Если ранг y больше чем i + 1, то, по условию регулярности счет-
чика нарушений, узел y должен иметь хотя бы одного сына w ран-
га     i + 1, который не является i + 1-ранговым нарушением, и два          
i-ранговых сына w должны быть также ненарушенными. Тогда за-
меняем  два  нарушенных  i-ранговых  сына  узла  y  на  два  хороших     
i-ранговых сына узла w. Тем самым мы свели задачу к случаю 1. 

Можно доказать, что рассматриваемая операция не испортит регуляр-

ности счётчика. 

 

273

 

 

 

 

i-го 

разряда 

Инкрементирование 

нарушений 
(IncCountViolation (i, p)). Используя описанную выше операцию фикса-
ции, можно осуществить инкрементирование i-го разряда счётчика нару-
шений следующими операторами.  
FixCountViolation (i); FixCountViolation (CountViolation 
[i]^.ForwardPointer); 

счетчика 

InsertViolation(i, pNode); 
CountViolation[i].Value:= CountViolation[i].Value + 1; 
FixCountViolation (i); FixCountViolation (CountViolation 

[i]^.ForwardPointer); 

Трудоёмкость O(1). 
Удаления  нарушения  из  кучи.  Заметим,  что  удаление  нарушения  из 
кучи подразумевает наличие в куче этого нарушения, пусть это наруше-
ние ранга i. Тогда, значение i-го разряда для счётчика нарушений не равно 
нулю. Следовательно уменьшение этого значения на единицу не испортит 
регулярности и не потребует обновления, каких-либо указателей. Необхо-
димо  лишь  уменьшить  на  единицу  значение  переменной  CountViolation 
[i].Value  и  обработать  указатели  FirstViolation  и  SecondViolation.  Оче-
видно, что трудоёмкость этой операции O(1).  

Нахождения узла с минимальным значением ключа среди всех на-
рушений.  Для  реализации  этой  функции  предлагается  перебрать  все  на-
рушения до максимального ранга и найти среди них узел с минимальным 
весом. Трудоёмкость данной операции O(log n). 

Основные операции: 
Операция  make-heap  заключается  в  инициализации  счётчиков,  тру-

доёмкость O(1). 

Трудоёмкость O(1).  

Операция  FindMin  возвращает  указатель  на  минимальный  элемент. 

Операция Insert(key). Чтобы выполнить эту операцию, делаем новый 
элемент отдельным деревом и выполняем процедуру вставки нового эле-
мента ранга 0 в корневой счётчик. После этого, если необходимо, коррек-
тируем значение указателя на минимальный элемент.  

Операция  уменьшения  ключа  DecreaseKey(∆, p).  Чтобы  выполнить 
эту операцию поступим следующим образом. Пусть x – узел, на который 
указывает указатель p. Вычитаем ∆ из ключа узла х. Если новый ключ х 
меньше  минимального  ключа  кучи  H,  обмениваем  ключ  элемента  p,  с 
ключом минимального элемента. Новых нарушений операция не создаст. 

 274

 

 

Пусть  r  –  ранг  x.  Если  x  –  нарушаемый  узел,  добавляем  x  как  новое             
r-ранговое  нарушение  инкрементированием  r-ой  цифры  dr  счетчика  на-
рушений. Трудоёмкость O(1). 

Операция DeleteMin выполняется следующим образом. Удаляем под-
дерево с корнем в минимальном узле из леса. Минимальность этого эле-
мента гарантирует нам, что среди его детей нарушений порядка кучи не 
было. То есть, нет необходимости, работать со счётчиком нарушений. За-
тем  вставляем  в  кучу  все  деревья  с  корнями,  расположенными  в  детях 
удаляемого узла. Очевидно, что новый минимальный ключ – либо в корне 
дерева леса, либо в нарушенном узле. Делаем поиск нового минимального 
элемента среди корней деревьев и нарушенных узлов. 

Если минимальный элемент оказался в нарушенном узле, то обмени-
ваем его с элементом, хранимым в корне этого дерева, корректируя кор-
невой счётчик, если это необходимо. После замены, новый минимум – в 
корне дерева леса. Этот корень будет новым минимальным узлом. Трудо-
ёмкость операции равна О(Log n). 

Операция удаления элемента. Выполняется с помощью DecreaseKey 

и затем DeleteMin. Трудоёмкость операции О(Log n). 

Операция  Meld(h1,  h2).  Выполняется  следующим  образом.  Первый 
шаг – фиксируются все нарушения в куче с меньшим максимальным ран-
гом (разрывая связь произвольно). Не уменьшая общности, считаем, что 
эта  куча  –  h2.  Пройти  по  счетчику  нарушений  h2  от  младшей  цифры  к 
старшей, пропуская цифры со значением 0. Для i-ой цифры di ≠ 0 делаем 
операцию фиксирования на каждой цифре, показываемой прямым указа-
телем di, если эта цифра имеет значение 2. Затем, если di = 2, фиксируем 
di. Если di = 1, преобразуем это i-ранговое нарушение в (i + 1)-ранговое 
нарушение как при фиксировании, используя i-рангового брата нарушен-
ного узла вместо (несуществующего) другого i-рангового нарушения. 

Как  только  h2  не  будет  содержать  каких-либо  нарушений,  вставить 
корни из корневого счетчика h2 в корневой счетчик h1 инкрементирова-
нием  соответствующих  цифр.  Если  минимальный  узел  h2  содержит 
меньший ключ, чем минимальный узел h1, установить новым минималь-
ным  узлом  h1  минимальный  узел  h2.  Вернуть  модифицированную  кучу 
h1 в качестве результата Meld. Трудоёмкость операции равна О(Log n). 

Операция DeleteViolation. Для освобождения кучи от нарушений дос-

таточно выполнить операторы 

 

For  i:=  0  to  h2^.MaxRank  do  If  (CountViolation[i].Value  =  2)  then  Fix-

 

275

 

 

CountViolation( i);  

 

For i:= 0 to h2^.MaxRank do If (CountViolation[i].Value = 1) then 
{IncCountViolation(i, SearchBrather (CountViolation[i].FirstViolation)); 
FixCountViolation(i)} 
Основываясь на описанной выше реализации, толстой кучи получаем 
следующий  результат.  В  толстых  кучах  операции  FindMin,  Insert  и 
DecraseKey выполняются за время O(1), а Delete, DeleteMin и Meld – за 
время O(log n). 

Замечания.  Существует  альтернативное  представление  избыточных 
счетчиков. Вместо одной записи на цифру, можно использовать одну за-
пись на блок одинаковых цифр. Инкрементирование любой цифры можно 
выполнить  за  время  O(1),  используя  это  альтернативное  представление. 
Преимущество этого представления – возможность расширить счетчик на 
произвольное число одинаковых цифр за постоянное время. 

Бродал описывает кучевидную структуру, которая теоретически луч-
ше, чем толстые кучи, так как их временная оценка для Meld O(1) в худ-
шем случае. Структура Бродала, однако, намного сложнее толстых куч. 

 276

 

 

Сводные сведения о трудоемкости операций  

с приоритетными очередями 

Трудоемкость операций над различными реализациями приоритетной очереди в 
худшем случае: 

 

d-куча 

левосто-
ронняя куча

O(1) 

ВСТАВИТЬ  O(logd n)  O(log n) 
O(1) 
МИН 
УДАЛИТЬ 
O(d logd n)  O(log n) 
МИН 
УДАЛИТЬ  O(d logd n)  O(log n) 
УМЕНЬШИТ
O(logd n)  O(log n) 
Ь КЛЮЧ 
O(log n) 
СЛИТЬ 
– 
ОБРАЗОВАТ
Ь ОЧЕРЕДЬ  O(n) 
O(n) 
n
*где F =
+k

log,1max{

}
1

. 

k

само-
ленивая 
органи-
левосто-
зующая-
ронняя 
ся куча 
куча 
O(n) 
O(1) 
O(F)*  O(1) 
O(F)*  O(n) 
O(1)  … 
O(1)  … 
O(1) 
O(n)  … 

O(n) 

биноми-
альная 
очередь 

ленивая 
биноми-
альная 
очередь 

фибо-
наччие-
ва куча 

слабо-
расту-
щая куча 
(run-
relaxed) 

куча Бро-
дала 

O(1)  O(1) 
O(1)  O(1) 

O(1) 
O(1) 

O(log n)  O(1) 
O(1) 
O(1) 
O(log n)  O(n)  … 
O(log n)  … 
… 
… 
O(log n)  … 
 
O(log n)  O(1) 
O(n) 
 

 

O(log n)  O(log n) 
O(log n)  O(log n) 
O(1) 
O(1) 
O(log n)  O(1) 
O(1) 
O(1) 

2. Амортизационная трудоемкость выполнения операций: 

лени-
вая 
лево-
сто-
рон-
няя 
куча

d-куча 

левосто-
ронняя 
куча 

само-
органи-
зующая-
ся куча

биноми-
альная 
очередь

ленивая 
биноми-
альная 
очередь 

фибо-
наччие-
ва куча

тонкая 
куча 
(thin 
heap) 

жирная
куча (fa
heap)

O(1) 

O(1) 

O(1) 
O(1) 

O(logd n)  O(log n) O(1) O(log n) O(1) 
O(1) 

O(1)  … 

O(1)
O(1)
O(d logd n) O(log n) …  O(log n) O(log n) O(log n)  O(log n) O(log n) O(log n
O(d logd n) O(log n) O(1) … 
O(log n) O(log n) O(log n
O(1) 
O(1)
O(logd n)  O(log n) O(1) … 
O(1)  O(log n
O(1)
O(1) 

O(log n) … 
O(log n) … 
O(log n) O(1) O(log n) O(log n) O(1) 

O(n)  O(n) … 

O(1) 
O(1) 
O(1) 

O(1) 
O(1) 

O(1) 
O(1) 

O(n) 

O(n) 

 

– 

277

 

ВСТАВИТЬ 
МИН 
УДАЛИТЬ МИН 
УДАЛИТЬ 
УМЕНЬШИТЬ 
КЛЮЧ 
СЛИТЬ 
ОБРАЗОВАТЬ 
ОЧЕРЕДЬ 

 

 

Глава 5. ПОИСКОВЫЕ ДЕРЕВЬЯ 

5.1. Двоичные деревья поиска 

Общие  сведения.  Деревья  поиска  предназначены  для  представления 
словарей как абстрактного типа данных. Также как и приоритетные оче-
реди  они  представляют  взвешенные  множества,  но  с  другим  набором 
операций, а именно:  

Insert – вставка элемента со своим ключом, 

•  Search – поиск элемента с заданным ключом, 
•  Minimum – поиск элемента с минимальным ключом, 
•  Maximum – поиск элемента с максимальным ключом, 
•  Predecessor – поиск элемента с предыдущим ключом, 
•  Successor – поиск элемента со следующим ключом, 
• 
•  Delete – удаление указанного элемента. 
Считается, что каждый элемент словаря имеет ключ (вес), принимаю-
щий значение из какого-либо линейно упорядоченного множества. Таким 
множеством может быть, например, числовое множество или множество 
слов в некотором алфавите. В последнем случае в качестве линейного по-
рядка  можно  рассматривать  лексикографический  порядок.  Таким  обра-
зом, дерево поиска может быть использовано и как словарь, и как приори-
тетная очередь. 

Время  выполнения  основных  операций  пропорционально  высоте  де-
рева. Если каждый внутренний узел двоичного дерева имеет ровно двух 
потомков, то его высота и время выполнения основных операций пропор-
циональны  логарифму  числа  узлов.  Напротив,  если  дерево  представляет 
собой  линейную  цепочку  из  n  узлов,  это  время  вырастает  до  Θ(n).  Из-
вестно, что высота случайного двоичного дерева поиска есть Ο (lоg n), так 
что в этом случае время выполнения основных операций есть Θ(lоg n). 

Конечно,  возникающие  на  практике  двоичные  деревья  поиска  могут 
быть далеки от случайных. Однако, приняв специальные меры по балан-
сировке деревьев, мы можем гарантировать, что высота деревьев с n уз-
лами  будет Ο  (lоg  n).  Ниже  рассмотрим  один  из  подходов  такого  рода 
(красно-черные  деревья  и  как  частный случай АВЛ-деревья). Будут рас-
смотрены также Б-деревья, которые особенно удобны для данных, храня-
щихся во вторичной памяти с произвольным доступом (на диске). 

 

 
 
 

 

 

 278

 

 

Представление двоичных деревьев поиска. Двоичным деревом по-
иска  называется  корневое  двоичное  дерево,  каждому  узлу  которого  по-
ставлен в соответствие взвешенный элемент. При этом для каждого узла x 
выполняется следующее условие. 

Веса всех узлов левого поддерева с корнем x меньше или равны весу 
узла x, а веса узлов его правого поддерева больше или равны весу узла x. 

Представляется такое дерево узлами следующего вида 
Node = (element, key, left, right, parent) 

Доступ к дереву T осуществляется с помощью ссылки root. 
Процедура Walk (x) обходит все узлы поддерева с корнем в узле x и 

 

печатает их ключи в неубывающем порядке. 
  Procedure Walk (x); 
  begin  
 
 

 

if (x ≠ nil) then {WALK (left[x]); write (key[x]); WALK (right[x])} 
end. 
Свойство  упорядоченности  гарантирует  правильность  алгоритма. 
Время работы на дереве с n вершинами есть Θ(n), каждая вершина обра-
батывается один раз. Оператор Walk(root) напечатает ключи всех элемен-
тов в неубывающем порядке. 

Заметим, что порядок, при котором корень предшествует узлам обоих 
поддеревьев, называется preorder; порядок, в котором корень следует за 
ними, называется postorder. 

Упражнения 
1. Нарисуйте двоичные деревья поиска высоты 2, 3, 4, 5 и 6 для одного 

и того же множества ключей 1, 4, 5, 10, 16, 17, 21. 

2.  Напишите  нерекурсивный  алгоритм,  печатающий  ключи  в  двоич-

 

 

 

 

 

ном дереве поиска в неубывающем порядке. 

3.  Напишите  рекурсивные  алгоритмы  для  обхода  деревьев  в  различ-
ных порядках (preorder, postorder). Как и раньше, время работы должно 
быть O(n) (где n – число вершин). 

4. Покажите, что любой алгоритм построения двоичного дерева поис-
ка, содержащего заданные n элементов, требует времени Ώ(n⋅log n). Вос-
пользуйтесь тем, что сортировка n чисел требует Ώ(n⋅log n) действий. 

 
Операции с двоичным поисковым деревом. Покажем, что двоичные 

 

279

 

 

поисковые  деревья  позволяют  выполнять  операции  Search,  Minimum, 
Maximum, Successor и Predecessor за время Ο (h) , где h – высота дерева. 

1. Поиск (Search). Процедура поиска получает на вход искомый ключ 
k и указатель x на корень поддерева, в котором производится поиск. Она 
возвращает указатель на вершину с ключом k (если такая есть) или nil (ес-
ли такой вершины нет). 
Procedure Search (x, k); 
begin  
if (x = nil) or (k = key [x]) then Return x; 
if (k < key [x]) then Return Search (left[x], k) else  

 

Return Search (right[x], k)  

 

end. 
В процессе поиска мы двигаемся от корня, сравнивая ключ k с клю-
чом, хранящимся в текущей вершине x. Если они равны, поиск заверша-
ется.  Если  k < key[x],  то  поиск  продолжается  в  левом  поддереве  x.  Если 
k > key[x], то поиск продолжается в правом поддереве. Длина пути поиска 
не превосходит высоты дерева, поэтому время поиска есть O(h) (где h – 
высота дерева). 

 

 

Итеративная версия процедуры Поиск 

 

Procedure IterativeSearch (x, k); 
begin 
While (x ≠ nil) and (k ≠ key [x]) do  
If k < key [x] then x:= left[x] else x:= right[x];  
Return (x)  
end. 
Минимум  и  Максимум.  Элемент  с  минимальным  ключом  в  дереве 
поиска можно найти, пройдя от корня по указателям left пока не упремся 
в nil. Процедура Minimum(x) возвращает указатель на найденный элемент 
поддерева с корнем x. 
Procedure Minimum(x); 
begin While left [x] ≠ nil do x:= left[x]; Return (x) end. 
Алгоритм Maximum симметричен: 

 

 

Procedure Maximum(x); 
begin While (right [x] ≠ nil) do x:= right[x]; Return (x) end. 

 

 280

 

 

Оба алгоритма требуют времени O(h), где h – высота дерева (посколь-

ку двигаются по дереву только вниз). 

 

Следующий и предыдущий элементы. Если x − указатель на неко-
торый  узел  дерева,  то  процедура  Successor(x)  возвращает  указатель  на 
узел со следующим за x элементом или nil, если указанный элемент по-
следний в дереве. 
Procedure Successor(x); 
begin 
If (right[x] ≠ nil) then Return Minimum (right[x]); 
y:= p[x];  
while (y ≠ nil) and (x=right [y]) do {x:= y; y:= parent[y]}; 
Return y  
end. 
Приведенная  процедура  отдельно  рассматривает  два  случая.  Если 
правое поддерево вершины x не пусто, то следующий за x элемент – ми-
нимальный  элемент  в  этом  поддереве  и  равен  Minimum(right[x]).  Если 
правое поддерево вершины x пусто, то идем от x вверх, пока не найдем 
вершину, являющуюся левым сыном своего родителя. Этот родитель (ес-
ли  он  есть)  и  будет  искомым  элементом.  Время  работы  процедуры 
Successor на дереве высоты h есть Ο (h), так как мы двигаемся либо толь-
ко вверх, либо только вниз. Процедура Predecessor симметрична. 

 

Упражнения 
1.  Пусть  поиск  ключа  в  двоичном  дереве  завершается  в  листе.  Рас-
смотрим три множества: A – элементы слева от пути поиска, B – элементы 
на пути и C – справа от пути. Верно ли, что для любых трех ключей a ∈ 
A, b ∈ B и c ∈ C выполняются неравенства a ≤ b ≤ c. 

2.  Докажите,  что  k  последовательных  вызовов  процедуры  Successor 
выполняются за Ο(k + h) шагов (h – высота дерева) независимо от того, с 
какой вершины мы начинаем. 

3. Пусть T – двоичное дерево поиска, все ключи в котором различны,  
x – его лист, а y – родитель узла x. Покажите, что key [y] является сосед-
ним с key [x] ключом (следующим или предыдущим). 

 

Добавление элемента.  Процедура  Insert (T, z)  добавляет  заданный 
элемент  в  подходящее  место  дерева  T.  Параметром  процедуры  является 
указатель  z  на  новую  вершину,  в  которую  помещены  значения  key [z], 
left [z] = nil, и right [z] = nil. В ходе работы процедура изменяет дерево T и 

 

281

 

 

(возможно) некоторые поля вершины z, после чего новая вершина с дан-
ным значением ключа оказывается вставленной в подходящее место дере-
ва. 
Procedure Insert(T, z); 
begin 
y := nil; x := root; 
while (x ≠ nil) do {y := x; if key[z] < key[x] then x := left[x] else 
x := right[x]}; 
p [z] := y; 
if y = nil then root := z else if key[z] < key[y] then left[y] := z else 
right [y]:= z 

end. 

Подобно процедурам Search и IterativeSearch, процедура Insert дви-
гается вниз по дереву, начав с его корня. При этом в вершине y сохраня-
ется указатель на родителя вершины x. Сравнивая key [z] с key [x], проце-
дура решает, куда идти – налево или направо. Процесс завершается, когда 
x становится равным nil. Этот nil стоит как раз там, куда надо поместить 
z, что и делается. Очевидно, добавление требует времени Ο (h) для дерева 
высоты h. 

Удаление элемента.  Параметром  процедуры  удаления  является  ука-
затель z на удаляемую вершину. При удалении возможны три случая. Ес-
ли  у  z  нет  детей,  для  удаления  z  достаточно  поместить  nil  в  соответст-
вующее поле его родителя вместо z. Если у z есть один ребенок, можно 
вырезать z, соединив его родителя напрямую с его ребенком. Если же де-
тей двое, находим следующий за z элемент y; у него нет левого ребенка. 
Теперь можно скопировать ключ и дополнительные данные из вершины y 
в вершину z, а саму вершину y удалить описанным выше способом. 

 

Упражнения 
1. Напишите рекурсивный вариант процедуры Insert. 
2. Напишите процедуру Delete удаляющую элемент z из дерева T. 
3. Набор из n чисел можно отсортировать, сначала добавив их один за 
другим в двоичное дерево поиска с помощью процедуры Insert, а потом 
обойти дерево с помощью процедуры Walk. Оцените время работы такого 
алгоритма. 

4. Покажите, что, если вершина двоичного дерева поиска имеет двоих 
детей, то следующая за ней вершина не имеет левого ребенка, а предше-
ствующая – правого. 

 282

 

 

Случайные двоичные деревья поиска. Поскольку основные опера-
ции с двоичными деревьями поиска требуют времени Ο (h), где h – высота 
дерева,  важно  знать,  какова  высота  «типичного»  дерева.  Для  этого  при-
нимают какие-то статистические предположения о распределении ключей 
и  последовательности  выполняемых  операций.  К  сожалению,  в  общем 
случае  ситуация  трудна  для  анализа.  Если  определить  случайное  двоич-
ное дерево из n различных ключей как дерево, получающееся из пустого 
дерева добавлением этих ключей в случайном порядке, считая все n! пе-
рестановок  равновероятными,  то  можно  доказать,  что  средняя  высота 
случайного двоичного дерева поиска, построенного по n различным клю-
чам, равна Ο (log n). 

 

 

5.2. Красно-черные деревья 

Мы видели, что основные операции с двоичным поисковым деревом 
высоты h могут быть выполнены за  Ο (h) действий. Деревья эффективны, 
если  их  высота  мала,  но  если  не  принимать  специальные  меры  при  вы-
полнении операций, малая высота не гарантируется, и в этом случае дере-
вья не более эффективны, чем списки. 

Для  повышения  эффективности  операций,  используют  различные 
приемы перестройки деревьев, так чтобы высота дерева была величиной 
Ο (log n).  Такие  приемы  называются  балансировкой  деревьев.  При  этом 
используются  разные  критерии  качества  балансировки.  Одним  из  видов 
сбалансированных  деревьев  поиска  являются  так  называемые  красно-
черные деревья, для которых предусмотрены операции балансировки, га-
рантирующие оценку высоты величиной Ο (log n). 

смысле  АВЛ-деревьями 

Частным  случаем  такой  балансировки  является  АВЛ-балансировка, 
при  которой  у  каждого  узла  высота  его  левого  поддерева  отличается  от 
высоты правого не более чем на единицу. Заметим, что наихудшими в не-
котором 
являются  деревья  Фибоначчи 
Th (h = 0, 1,  2, …), определяемые следующим образом: T0 – пустое дере-
во. T1 – дерево, состоящее из одного узла. При h >1 дерево Th состоит из 
корня  с  левым  поддеревом  Th–1  и  правым  –  Th–2.  Не  трудно  видеть,  что 
при заданной величине h, дерево Th имеет наименьшее число узлов среди 
всех АВЛ-деревьев высоты h. 

Для  удобства  поисковые  деревья  будем  расширять,  вводя  дополни-
тельный фиктивный узел (nil-узел) и считая его потомком каждого узла 
исходного дерева, у которого нет правого или левого или обоих потомков, 
его же считаем родителем корня. 

 

283

 

 

Красно-черное  дерево  –  это  расширенное  двоичное  дерево  поиска, 

вершины которого разделены на красные (red) и черные (black) так, что 

1. Каждый узел либо красный, либо черный. 
2. Каждый лист (nil-узел) – черный. 
3. Если узел красный, то оба его ребенка черные. 
4.  Все  пути,  идущие  вниз  от  корня  к  листьям,  содержат  одинаковое 

количество черных узлов. 

Свойства 1–4 называют RB-свойствами. Узлы красно-черного дерева 

будем представлять записями вида 

Node = (color, key, left, right, parent). 

Комбинаторные  свойства  красно-черных  деревьев.  Для  произ-
вольного узла x определим черную высоту bh (x) как количество черных 
узлов на пути из x в некоторый лист, не считая сам узел x. По свойству 4 
эта сумма не зависит от выбранного листа. Черной высотой дерева будем 
считать черную высоту его корня. 

Пусть size[x] – количество внутренних узлов в поддереве с корнем x 

Лемма 1. Для произвольного узла x красно-черного дерева выполняет-

(nil-узлы не считаются). 

ся неравенство 

size[x] ≥ 2bh(x) – 1. 

Доказательство.  Если x  – лист, то bh(x) = 0 и size[x] = 0, следова-
тельно,  утверждение  леммы  выполнено.  Далее,  пусть для узлов left [x] и 
right [x] утверждение леммы справедливо, то есть 

 тогда 

 

size [left [x]] ≥ 2bh(left [x]) – 1, и size [right [x]] ≥ 2bh(right

 

[x]) – 1, 

size [x] = size [left [x]] + size [right [x]] + 1 ≥  

≥ (2bh(left
= 2bh(left [x])+2bh(right

 

[x]) – 1) + (2bh (right[x]) –1 ) + 1 = 
[x]) – 1 ≥ 2bh

 

(x)–1 + 2bh(x)–1 – 1 ≥ 2bh(x) – 1. 
Предпоследнее неравенство справедливо в силу соотношения  

 

bh (left [x]) ≥ (bh (x) – 1) и bh (right [x]) ≥ (bh (x) – 1). 

Лемма 2. Красно-черное дерево с n внутренними узлами (nil-листья не 

считаются) имеет высоту не больше 2lоg (n + 1). 

Доказательство.  Обозначим  высоту  дерева  через  h.  Согласно  свой-
ству 3, по меньшей мере, половину всех вершин на пути от корня к листу, 

 

 

 

 

 

 

 

 

 

 284

 

 

не  считая  корень,  составляют  черные  вершины.  Следовательно,  черная 
высота дерева не меньше h/2. Тогда n ≥ 2h/2 – 1 и, переходя к логарифмам, 
получаем log (n + 1) ≥ h/2, или h ≤ 2 log (n + 1). Лемма доказана. 

Полученная  оценка  высоты  красно-черных  деревьев  гарантирует  вы-
полнение операций Search, Minimum, Maximum, Successor и Predecessor 
с красно-черными деревьями за время Ο (log n). Сложнее обстоит дело с 
процедурами  Insert  и  Delete:  проблема  в  том,  что  они  могут  испортить 
структуру  красно-черного  дерева,  нарушив  RB-свойства.  Поэтому  эти 
процедуры придется модифицировать. Ниже увидим, как можно реализо-
вать их за время Ο (log n) с сохранением RB-свойств. 

Упражнения 
1. Предположим, что корень красно-черного дерева красный. Если мы 

покрасим его в черный цвет, останется ли дерево красно-черным? 

2. Покажите, что самый длинный путь вниз от вершины x к листу не 

более чем вдвое длиннее самого короткого такого пути. 

3. Какое наибольшее и наименьшее количество внутренних узлов мо-

жет быть в красно-черном дереве черной высоты k? 

Вращения  это  манипуляции  с  красно-черными  деревьями  с  целью 
восстановления  RB-свойств  в  случае  их  нарушения.  Их  используют  при 
реализации  операций  Insert  и  Delete.  Вращение  представляет  собой  ло-
кальную операцию, при которой меняется несколько указателей, но свой-
ство упорядоченности сохраняется. 

На рис. 1 показаны два взаимно обратных вращения: левое и правое. 

 

 

 
 
 
 
 
 
 
 
 

 

 

 

y 

x 

γ 

α

β 

Правое вращение

Левое вращение

Рис. 1 

α

x

β 

y

γ 

Левое вращение возможно в любом узле x, правый ребенок которой 
(назовем  его y)  не  является  листом (nil). После вращения y оказывается 
корнем поддерева, x – левым ребенком узла y, а бывший левый ребенок y 
– правым ребенком узла x. 

 

285

 

 

Упражнения 
1. Покажите, что левое и правое вращения можно осуществить за вре-

мя O(1). 

2.  Напишите  процедуры,  LeftRotate(T, x)  и  RightRotate(T, x)  реали-

зующие левое и правое вращение в дереве T относительно узла x. 

3. Пусть a, b и c – произвольные узлы в поддеревьях α, β и γ на рис. 1 
(справа). Как изменится глубина a, b и c при выполнении левого враще-
ния? 

4.  Покажите,  что  произвольное  двоичное  дерево  поиска  с  n  узлами 
может быть преобразовано в любое другое дерево с тем же числом узлов 
(и теми же ключами) с помощью Ο (n) вращений. (Указание: сначала по-
кажите, что n – 1 правых вращений достаточно, чтобы преобразовать лю-
бое дерево в идущую вправо цепочку. 

5.  Напишите  процедуры  Insert(T, x)  и  Delete(T, x),  добавляющую  и 

удаляющую элемент x из дерева T за время O (log n). 

6. Разработайте алгоритм объединения двух красно-черных деревьев в 

одно красно-черное дерево за время O (log n). 

 

Комбинаторные свойства АВЛ-деревьев. АВЛ-балансировка по оп-
ределению требует, чтобы для каждого узла высота его правого поддерева 
отличалась от высоты левого не более чем на единицу. 

Пусть nk  –  минимальное  число  узлов в АВЛ-дереве высоты k. Тогда    

n0 = 1, n1 = 2, n2 = 4, nk = nk–1 + nk–2 + 1, при k ≥ 2. 

Пусть α = (1+√5) / 2 (положительный корень уравнения x2 – x – 1). 
Теорема. Для любого k ≥ 3 выполняется неравенство nk ≥ α k+1. 
Доказательство.  Непосредственно  проверяется  базис  индукции         

n3 ≥ α4, n4 ≥ α5. 

Предположим,  что  при  k = l  выполняется  nk ≥ αk+1  и  докажем  при 
k = l + 1.  Действительно,  nl+1 = n + nl–1 + 1 > αl+1 + αl + 1 > αl+2.  Докажем 
последнее в цепочке неравенство αl+1 + αl + 1 ≤ αl+2, тогда αl+2 − αl+1 − αl 
− – 1 ≥ 0 или αl(α2 − α − 1) − 1 ≥ 0 и –1 ≥ 0, противоречие. 

Следствие. Для любого АВЛ-дерева высоты k с n узлами выполняется 
неравенство  k + 1 < logα n = logα 2 log2 n ≈ 1,44… log2 n,  обеспечивает 
«логарифмическую  трудоемкость»  выполнения  основных  операций  с 
АВЛ-деревом. 

Замечания. Идея балансировки двоичных деревьев поиска принадле-
жит Г.М. Адельсону-Вельскому и Е.М. Ландису, предложившим в 1962 г. 
класс  сбалансированных  деревьев,  называемых  теперь  АВЛ-деревьями. 

 286

 

 

Баланс поддерживается с помощью процедуры вращения. Для его восста-
новления в дереве с n узлами после добавления или удаления узла может 
потребоваться θ(log n) вращений. 

Еще  один  класс  деревьев  поиска,  называемых  2-3-деревьями,  был 
предложен  Хопкрофтом  в  1970  г.  Здесь  баланс  поддерживается  за  счет 
изменения степеней узлов. Обобщение 2-3-деревьев предложили Байер и 
Мак Крейт. Их деревья называются Б-деревьями, которые мы рассмотрим 
в следующем разделе. 

Красно-черные  деревья  предложил Байер, назвав их симметричными 
двоичными Б-деревьями. Гибас и Седжвик подробно изучили их свойства 
и предложили использовать для наглядности красный и черный цвета. 

Из многих других вариаций на тему сбалансированных деревьев наи-
более любопытны, видимо, расширяющиеся деревья, которые придумали 
Слеатор  и  Тарьян.  Эти  деревья  являются  саморегулирующимися.  Хоро-
шее описание расширяющихся деревьев дал Тарьян. Расширяющиеся де-
ревья  поддерживают  баланс  без  использования  дополнительных  полей 
(типа цвета). Вместо этого расширяющие операции, включающие враще-
ния, выполняются при каждом обращении к дереву. Учетная стоимость в 
расчете  на  одну  операцию  с  деревом  для  расширяющихся  деревьев  со-
ставляет O (log n). 
Упражнение 
1.  Напишите  процедуру  Insert(T, z)  для  вставки  элемента  z  в  АВЛ-

2. Напишите процедуру Delete(T, z) для удаления элемента z из АВЛ-

 

 

 

дерево T. 

дерева T. 

5.3. Б-деревья 

Б-деревья  это  один  из  видов  сбалансированных  деревьев,  при  кото-
ром  обеспечивается  эффективное  хранение  информации  на  магнитных 
дисках  и  других  устройствах  с  прямым  доступом.  Б-деревья  похожи  на 
красно-черные деревья. Разница в том, что в Б-дереве узел может иметь 
много детей, на практике до тысячи, в зависимости от характеристик ис-
пользуемого диска. Благодаря этому константа в оценке O (log n) для вы-
соты дерева существенно меньше, чем для черно-красных деревьев. Как и 
черно-красные  деревья,  Б-деревья  позволяют  реализовать  многие  опера-
ции с множествами размера n за время O (log n). 

Узел x, хранящий n[x] ключей, имеет n[x] + 1 детей. Хранящиеся в x 
ключи  служат  границами,  разделяющими  всех  ее  потомков  на  n[x]  +  1 

 

287

 

 

групп; за каждую группу отвечает один из детей x. При поиске в Б-дереве 
мы сравниваем искомый ключ с n[x] ключами, хранящимися в x, и по ре-
зультатам сравнения выбираем одного из n[x] + 1 потомков. 

Особенности  работы  со  структурами,  данных  размещаемых  на 
диске. Алгоритмы, работающие с Б-деревьями, хранят в оперативной па-
мяти лишь небольшую часть всей информации (фиксированное число сек-
торов). 

Диск рассматривается как большой участок памяти, работа с которым 
происходит следующим образом: перед тем как работать с объектом x, мы 
должны выполнить специальную операцию Disk-Read(x) (чтение с диска). 
После внесения изменений в наш объект x, мы выполняем операцию Disk-
Write (x) (запись на диск). 

Время работы программы в основном определяется количеством этих 
операций, так что имеет смысл читать/записывать, возможно, больше ин-
формации за один раз и сделать так, чтобы узел Б-дерева заполнял полно-
стью один сектор диска. Таким образом, степень ветвления (число детей 
узла) определяется размером сектора. 

Типичная степень ветвления Б-деревьев находится между 50 и 2000 в 
зависимости  от  размера  элемента.  Увеличение  степени  ветвления  резко 
сокращает высоту дерева, и тем самым число обращений к диску, при по-
иске. Например, Б-дерево степени 1001 и высоты 2, может хранить более 
миллиарда  ключей.  Учитывая,  что  корень  можно  постоянно  хранить  в 
оперативной  памяти,  достаточно  двух  обращений  к  диску,  при  поиске 
нужного ключа. 

Считаем,  что  дополнительная  прикладная  информация,  связанная  с 
ключом, хранится в том же узле дерева. На практике это не всегда удобно, 
и в реальном алгоритме узел может содержать лишь ссылку на сектор, где 
хранится  эта  дополнительная  информация.  Считаем,  что  при  перемеще-
ниях ключа дополнительная информация (или ссылка на нее) перемеща-
ется вместе с ним. Тем самым элементом Б-дерева будет ключ вместе со 
связанной с ним информацией. 

Замечание.  Часто  используется  другая  организация  Б-деревьев,  при 
которой  сопутствующая  информация  помещается  в  листьях,  где  больше 
места,  так  как  не  надо  хранить  ключи,  а  во  внутренних  узлах  хранятся 
только ключи и указатели на детей. 

Определение Б-дерева. Б-деревом называют корневое дерево, устро-

енное следующим образом: Каждый узел x содержит поля: 

•  n[x] – количество ключей, хранящихся в ней; 

 288

 

 

•  key1[x], key2[x], … , keyn[x][x] – сами ключи в неубывающем порядке; 
•  leaf [x] – булевское значение, истинное, когда узел х является лис-

Если х – внутренний узел, то он также содержит  
•  c1[x], c2[x], …, cn[x]+1[x] – указатели на ее детей в количестве n[x] + 

1. У листьев детей нет, и эти поля для них не определены. 

•  Все листья находятся на одной и той же глубине, равной высоте де-

том. 

рева. 

•  Возможное число ключей, хранящихся в одном узле, определяется 
параметром t ≥ 2, которое называется минимальной степенью Б-де-
рева. 

•  Для каждого некорневого узла x, выполняются неравенства (t – 1) ≤ 
≤ n[x] ≤ (2t – 1). Таким образом, число детей у любой внутреннего 
узла (кроме корня) находится в пределах от t до 2t. 

•  Если  дерево  не  пусто,  то  в  корне  должен  храниться  хотя  бы  один 

ключ. Узел, хранящий ровно 2t – 1 ключей, назовется полным. 

Ключи  keyi[x]  служат  границами,  разделяющими  значения  ключей  в 

•  c1[x] ссылается на поддерево, ключи в котором меньше чем key1[x], 
•  ci[x] при I = 2, 3, …, n ссылается на поддерево, ключи в котором на-

ходятся в пределах от keyi–1[x] до keyi[x], 

•  cn[x]+1[x]  ссылается  на  поддерево,  ключи  в  котором  больше  чем 

поддеревьях. Точнее,  

keyn[x][x]. 

В простейшем случае, кода t = 2, у каждого внутреннего узла 2, 3 или 
4 ребенка, и мы получаем так называемое 2-3-4 дерево. Для эффективной 
работы с диском на практике t надо брать достаточно большим. Число об-
ращений к диску для большинства операций пропорционально высоте Б-
дерева. Оценим сверху эту высоту. 

Теорема. Для всякого Б-дерева Т высоты h и минимальной степени t, 

хранящего n ≥ 1 ключей, выполнено неравенство h ≤ logt (n+1/2). 

Доказательство. Наименьшее число узлов в дереве высоты h будет в 
случае, если степень каждого узла минимальна, то есть у корня 2 ребенка, 
а у внутренних узлов по t детей. В этом случае на глубине 1 мы имеем 2 
узла, на глубине 2 имеем 2t узлов, на глубине 3 имеем 2t2 узлов... на глу-
бине h имеем 2th–1 узлов. При этом в корне хранится один ключ, а во всех 
остальных узлах по t – 1 ключей. Таким образом, получаем неравенство 

 

 

289

 

 

n ≥ 1+ (t – 1)

h

∑

i

1
=

1
−

2

⋅

it

 = 1 + 2 (t – 1) ((t

h – 1)/(t – 1)) = 2th – 1, 

 откуда следует утверждение теоремы. 

Как  и  для  красно-черных  деревьев,  высота  Б-дерева  с  n  узлами  есть 
O (log n),  но  основание  логарифма  для  Б-деревьев  гораздо  больше,  что 
примерно в log t раз сокращает количество обращений к диску. 

Основные  операции  с  Б-деревьями.  Можем  считать,  что  корень       

Б-дерева всегда находится в оперативной памяти, то есть операция чтения 
с диска для корня никогда не требуется; однако всякий раз, когда мы из-
меняем корень, мы должны его сохранять на диске. Все узлы, передавае-
мые как параметры, уже считаны с диска. Все процедуры обрабатывают 
дерево за один проход от корня к листьям. 

Поиск в Б-дереве. Поиск в Б-дереве похож на поиск в двоичном де-
реве. Разница в том, что в каждом узле x мы выбираем один вариант из 
(n[x]  +  1),  а  не  из  двух.  При  поиске  просматриваются  узлыы  дерева  от 
корня к листу. Поэтому число обращений к диску есть θ(h) = θ(logt n), где 
h  –  высота  дерева,  а  n  –  количество  ключей.  Так  как  n[x] ≤ 2t,  то  цикл 
while O(t) раз, и время вычислений равно O(th) = O(t⋅logt n). 

Создание  пустого  Б-дерева.  Пустое  дерево  создается  с  помощью 
процедуры, которая находит место на диске для нового узла и размещает 
его. Считаем, что это можно реализовать за время O(1) и не использовать 
операцию чтения с диска. 

Узел y до преобразования имел 2t детей; после преобразования в нем 
остается  t  наименьших  из  них,  а  остальные  t  становятся  детьми  нового 
узла  z,  который  в  свою  очередь  становится  ребенком  узла  x.  Ключ-
медиана  узла  y  добавляется  к  узлу  x  и  становится  разделителем  между 
узлом y и следующим за ним узлом z. 

Добавление  элемента  в  Б-дерево.  При  выполнении  этой  операции 
используется процедура разбиения полного (с 2t − 1 ключами) узла y на 
два узла, имеющие по t − 1 элементов в каждом. При этом ключ-медиана 
keyt[y] отправляется к родителю x узла y и становится разделителем двух 
полученных узлов. Это возможно, если узел x неполон. Если y – корень, 
процедура работает аналогично. В этом случае высота дерева увеличива-
ется на единицу. 

Процедура Insert добавляет элемент k в Б-дерево T, пройдя один раз 
от корня к листу. На это требуется время O(th) = O(t·logt n) и O(h) обра-
щений к диску, если высота дерева h. По ходу дела с помощью процедуры 

 290

 

 

Удаление элемента из Б-дерева. Удаление элемента из Б-дерева про-
исходит  аналогично  добавлению,  хотя  немного  сложнее.  Читателю  пре-
доставляется возможность разработать процедуру удаления, которая тре-
бует O(h) обращений к диску для Б-дерева высоты h, при этом вся проце-
дура требует O(t·h) = O(t·logt n). 

В заключение заметим, что сбалансированные деревья и Б-деревья об-
суждаются в книгах Кнута, Ахо, Хопкрофта и Ульмана и Седжвика. Под-
робный обзор Б-деревьев дан в книге Кормена и др. Гибас и Седжвик рас-
смотрели взаимосвязи между разными видами сбалансированных деревь-
ев, включая красно-черные и 2-3-4 деревья. 

разбиения  разделяются  встречающиеся  полные  узлы.  Заметим,  что  если 
полный узел имеет неполного родителя, то его можно разделить, так как в 
родителе  есть  место  для  дополнительного  ключа,  поэтому,  поднимаясь 
вверх, доходим до неполного листа, куда и добавляем новый элемент. 

В 1970 г. Хопкрофт предложил понятие 2-3 деревьев, которые явились 
предшественниками Б-деревьев и 2-3-4 деревьев. В этих деревьях каждая 
внутренняя  вершина  имеет  2  или  3  детей.  Б-деревья  были  определены 
Байером и Мак Крейтом в 1972 г. 
 

 

291

